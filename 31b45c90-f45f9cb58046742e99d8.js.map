{"version":3,"file":"31b45c90-f45f9cb58046742e99d8.js","mappings":"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","sources":["webpack://dale-tristan-hutchinson/./node_modules/tabster/dist/tabster.esm.js"],"sourcesContent":["import { nativeFocus, KEYBORG_FOCUSIN, createKeyborg, disposeKeyborg } from 'keyborg';\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst TabsterAttributeName = \"data-tabster\";\nconst TabsterDummyInputAttributeName = \"data-tabster-dummy\";\nconst DeloserEventName = \"tabster:deloser\";\nconst ModalizerActiveEventName = \"tabster:modalizer:active\";\nconst ModalizerInactiveEventName = \"tabster:modalizer:inactive\";\nconst ModalizerFocusInEventName = \"tabster:modalizer:focusin\";\nconst ModalizerFocusOutEventName = \"tabster:modalizer:focusout\";\nconst ModalizerBeforeFocusOutEventName = \"tabster:modalizer:beforefocusout\";\nconst MoverEventName = \"tabster:mover\";\nconst FocusInEventName = \"tabster:focusin\";\nconst FocusOutEventName = \"tabster:focusout\";\nconst ObservedElementAccesibilities = {\n  Any: 0,\n  Accessible: 1,\n  Focusable: 2\n};\nconst RestoreFocusOrders = {\n  History: 0,\n  DeloserDefault: 1,\n  RootDefault: 2,\n  DeloserFirst: 3,\n  RootFirst: 4\n};\nconst Visibilities = {\n  Invisible: 0,\n  PartiallyVisible: 1,\n  Visible: 2\n};\nconst RestorerTypes = {\n  Source: 0,\n  Target: 1\n};\nconst MoverDirections = {\n  Both: 0,\n  Vertical: 1,\n  Horizontal: 2,\n  Grid: 3,\n  GridLinear: 4\n};\nconst GroupperTabbabilities = {\n  Unlimited: 0,\n  Limited: 1,\n  LimitedTrapFocus: 2\n};\nconst SysDummyInputsPositions = {\n  Auto: 0,\n  Inside: 1,\n  Outside: 2\n};\n\nvar Types = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    TabsterAttributeName: TabsterAttributeName,\n    TabsterDummyInputAttributeName: TabsterDummyInputAttributeName,\n    DeloserEventName: DeloserEventName,\n    ModalizerActiveEventName: ModalizerActiveEventName,\n    ModalizerInactiveEventName: ModalizerInactiveEventName,\n    ModalizerFocusInEventName: ModalizerFocusInEventName,\n    ModalizerFocusOutEventName: ModalizerFocusOutEventName,\n    ModalizerBeforeFocusOutEventName: ModalizerBeforeFocusOutEventName,\n    MoverEventName: MoverEventName,\n    FocusInEventName: FocusInEventName,\n    FocusOutEventName: FocusOutEventName,\n    ObservedElementAccesibilities: ObservedElementAccesibilities,\n    RestoreFocusOrders: RestoreFocusOrders,\n    Visibilities: Visibilities,\n    RestorerTypes: RestorerTypes,\n    MoverDirections: MoverDirections,\n    GroupperTabbabilities: GroupperTabbabilities,\n    SysDummyInputsPositions: SysDummyInputsPositions\n});\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nfunction getTabsterOnElement(tabster, element) {\n  var _a;\n\n  return (_a = tabster.storageEntry(element)) === null || _a === void 0 ? void 0 : _a.tabster;\n}\nfunction updateTabsterByAttribute(tabster, element, dispose) {\n  var _a, _b;\n\n  const newAttrValue = dispose || tabster._noop ? undefined : element.getAttribute(TabsterAttributeName);\n  let entry = tabster.storageEntry(element);\n  let newAttr;\n\n  if (newAttrValue) {\n    if (newAttrValue !== ((_a = entry === null || entry === void 0 ? void 0 : entry.attr) === null || _a === void 0 ? void 0 : _a.string)) {\n      try {\n        const newValue = JSON.parse(newAttrValue);\n\n        if (typeof newValue !== \"object\") {\n          throw new Error(`Value is not a JSON object, got '${newAttrValue}'.`);\n        }\n\n        newAttr = {\n          string: newAttrValue,\n          object: newValue\n        };\n      } catch (e) {\n        if (process.env.NODE_ENV === 'development') {\n          console.error(`data-tabster attribute error: ${e}`, element);\n        }\n      }\n    } else {\n      return;\n    }\n  } else if (!entry) {\n    return;\n  }\n\n  if (!entry) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    entry = tabster.storageEntry(element, true);\n  }\n\n  if (!entry.tabster) {\n    entry.tabster = {};\n  }\n\n  const tabsterOnElement = entry.tabster || {};\n  const oldTabsterProps = ((_b = entry.attr) === null || _b === void 0 ? void 0 : _b.object) || {};\n  const newTabsterProps = (newAttr === null || newAttr === void 0 ? void 0 : newAttr.object) || {};\n\n  for (const key of Object.keys(oldTabsterProps)) {\n    if (!newTabsterProps[key]) {\n      if (key === \"root\") {\n        const root = tabsterOnElement[key];\n\n        if (root) {\n          tabster.root.onRoot(root, true);\n        }\n      }\n\n      switch (key) {\n        case \"deloser\":\n        case \"root\":\n        case \"groupper\":\n        case \"modalizer\":\n        case \"restorer\":\n        case \"mover\":\n          // eslint-disable-next-line no-case-declarations\n          const part = tabsterOnElement[key];\n\n          if (part) {\n            part.dispose();\n            delete tabsterOnElement[key];\n          }\n\n          break;\n\n        case \"observed\":\n          delete tabsterOnElement[key];\n\n          if (tabster.observedElement) {\n            tabster.observedElement.onObservedElementUpdate(element);\n          }\n\n          break;\n\n        case \"focusable\":\n        case \"outline\":\n        case \"uncontrolled\":\n        case \"sys\":\n          delete tabsterOnElement[key];\n          break;\n      }\n    }\n  }\n\n  for (const key of Object.keys(newTabsterProps)) {\n    const sys = newTabsterProps.sys;\n\n    switch (key) {\n      case \"deloser\":\n        if (tabsterOnElement.deloser) {\n          tabsterOnElement.deloser.setProps(newTabsterProps.deloser);\n        } else {\n          if (tabster.deloser) {\n            tabsterOnElement.deloser = tabster.deloser.createDeloser(element, newTabsterProps.deloser);\n          } else if (process.env.NODE_ENV === 'development') {\n            console.error(\"Deloser API used before initialization, please call `getDeloser()`\");\n          }\n        }\n\n        break;\n\n      case \"root\":\n        if (tabsterOnElement.root) {\n          tabsterOnElement.root.setProps(newTabsterProps.root);\n        } else {\n          tabsterOnElement.root = tabster.root.createRoot(element, newTabsterProps.root, sys);\n        }\n\n        tabster.root.onRoot(tabsterOnElement.root);\n        break;\n\n      case \"modalizer\":\n        if (tabsterOnElement.modalizer) {\n          tabsterOnElement.modalizer.setProps(newTabsterProps.modalizer);\n        } else {\n          if (tabster.modalizer) {\n            tabsterOnElement.modalizer = tabster.modalizer.createModalizer(element, newTabsterProps.modalizer, sys);\n          } else if (process.env.NODE_ENV === 'development') {\n            console.error(\"Modalizer API used before initialization, please call `getModalizer()`\");\n          }\n        }\n\n        break;\n\n      case \"restorer\":\n        if (tabsterOnElement.restorer) {\n          tabsterOnElement.restorer.setProps(newTabsterProps.restorer);\n        } else {\n          if (tabster.restorer) {\n            if (newTabsterProps.restorer) {\n              tabsterOnElement.restorer = tabster.restorer.createRestorer(element, newTabsterProps.restorer);\n            }\n          } else if (process.env.NODE_ENV === 'development') {\n            console.error(\"Restorer API used before initialization, please call `getRestorer()`\");\n          }\n        }\n\n        break;\n\n      case \"focusable\":\n        tabsterOnElement.focusable = newTabsterProps.focusable;\n        break;\n\n      case \"groupper\":\n        if (tabsterOnElement.groupper) {\n          tabsterOnElement.groupper.setProps(newTabsterProps.groupper);\n        } else {\n          if (tabster.groupper) {\n            tabsterOnElement.groupper = tabster.groupper.createGroupper(element, newTabsterProps.groupper, sys);\n          } else if (process.env.NODE_ENV === 'development') {\n            console.error(\"Groupper API used before initialization, please call `getGroupper()`\");\n          }\n        }\n\n        break;\n\n      case \"mover\":\n        if (tabsterOnElement.mover) {\n          tabsterOnElement.mover.setProps(newTabsterProps.mover);\n        } else {\n          if (tabster.mover) {\n            tabsterOnElement.mover = tabster.mover.createMover(element, newTabsterProps.mover, sys);\n          } else if (process.env.NODE_ENV === 'development') {\n            console.error(\"Mover API used before initialization, please call `getMover()`\");\n          }\n        }\n\n        break;\n\n      case \"observed\":\n        if (tabster.observedElement) {\n          tabsterOnElement.observed = newTabsterProps.observed;\n          tabster.observedElement.onObservedElementUpdate(element);\n        } else if (process.env.NODE_ENV === 'development') {\n          console.error(\"ObservedElement API used before initialization, please call `getObservedElement()`\");\n        }\n\n        break;\n\n      case \"uncontrolled\":\n        tabsterOnElement.uncontrolled = newTabsterProps.uncontrolled;\n        break;\n\n      case \"outline\":\n        if (tabster.outline) {\n          tabsterOnElement.outline = newTabsterProps.outline;\n        } else if (process.env.NODE_ENV === 'development') {\n          console.error(\"Outline API used before initialization, please call `getOutline()`\");\n        }\n\n        break;\n\n      case \"sys\":\n        tabsterOnElement.sys = newTabsterProps.sys;\n        break;\n\n      default:\n        console.error(`Unknown key '${key}' in data-tabster attribute value.`);\n    }\n  }\n\n  if (newAttr) {\n    entry.attr = newAttr;\n  } else {\n    if (Object.keys(tabsterOnElement).length === 0) {\n      delete entry.tabster;\n      delete entry.attr;\n    }\n\n    tabster.storageEntry(element, false);\n  }\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nfunction createEventTarget(getWindow) {\n  const global = getWindow();\n\n  try {\n    if (global.EventTarget) {\n      return new global.EventTarget();\n    }\n  } catch (error) {\n    // thrown if EventTarget is not constructable or doesn't exit\n    if (!(error instanceof TypeError)) {\n      throw error;\n    }\n  }\n\n  return global.document.createElement(\"div\");\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nlet _isBrokenIE11;\n\nconst _DOMRect = typeof DOMRect !== \"undefined\" ? DOMRect : class {\n  constructor(x, y, width, height) {\n    this.left = x || 0;\n    this.top = y || 0;\n    this.right = (x || 0) + (width || 0);\n    this.bottom = (y || 0) + (height || 0);\n  }\n\n};\n\nlet _uidCounter = 0;\n\ntry {\n  // IE11 only accepts `filter` argument as a function (not object with the `acceptNode`\n  // property as the docs define). Also `entityReferenceExpansion` argument is not\n  // optional. And it throws exception when the above arguments aren't there.\n  document.createTreeWalker(document, NodeFilter.SHOW_ELEMENT);\n  _isBrokenIE11 = false;\n} catch (e) {\n  _isBrokenIE11 = true;\n}\n\nconst _updateDummyInputsTimeout = 100;\nfunction getInstanceContext(getWindow) {\n  const win = getWindow();\n  let ctx = win.__tabsterInstanceContext;\n\n  if (!ctx) {\n    ctx = {\n      elementByUId: {},\n      basics: {\n        Promise: win.Promise || undefined,\n        WeakRef: win.WeakRef || undefined\n      },\n      containerBoundingRectCache: {},\n      lastContainerBoundingRectCacheId: 0,\n      fakeWeakRefs: [],\n      fakeWeakRefsStarted: false\n    };\n    win.__tabsterInstanceContext = ctx;\n  }\n\n  return ctx;\n}\nfunction disposeInstanceContext(win) {\n  const ctx = win.__tabsterInstanceContext;\n\n  if (ctx) {\n    ctx.elementByUId = {};\n    delete ctx.WeakRef;\n    ctx.containerBoundingRectCache = {};\n\n    if (ctx.containerBoundingRectCacheTimer) {\n      win.clearTimeout(ctx.containerBoundingRectCacheTimer);\n    }\n\n    if (ctx.fakeWeakRefsTimer) {\n      win.clearTimeout(ctx.fakeWeakRefsTimer);\n    }\n\n    ctx.fakeWeakRefs = [];\n    delete win.__tabsterInstanceContext;\n  }\n}\nfunction createWeakMap(win) {\n  const ctx = win.__tabsterInstanceContext;\n  return new ((ctx === null || ctx === void 0 ? void 0 : ctx.basics.WeakMap) || WeakMap)();\n}\n\nclass FakeWeakRef {\n  constructor(target) {\n    this._target = target;\n  }\n\n  deref() {\n    return this._target;\n  }\n\n  static cleanup(fwr, forceRemove) {\n    if (!fwr._target) {\n      return true;\n    }\n\n    if (forceRemove || !documentContains(fwr._target.ownerDocument, fwr._target)) {\n      delete fwr._target;\n      return true;\n    }\n\n    return false;\n  }\n\n}\n\nclass WeakHTMLElement {\n  constructor(getWindow, element, data) {\n    const context = getInstanceContext(getWindow);\n    let ref;\n\n    if (context.WeakRef) {\n      ref = new context.WeakRef(element);\n    } else {\n      ref = new FakeWeakRef(element);\n      context.fakeWeakRefs.push(ref);\n    }\n\n    this._ref = ref;\n    this._data = data;\n  }\n\n  get() {\n    const ref = this._ref;\n    let element;\n\n    if (ref) {\n      element = ref.deref();\n\n      if (!element) {\n        delete this._ref;\n      }\n    }\n\n    return element;\n  }\n\n  getData() {\n    return this._data;\n  }\n\n}\nfunction cleanupFakeWeakRefs(getWindow, forceRemove) {\n  const context = getInstanceContext(getWindow);\n  context.fakeWeakRefs = context.fakeWeakRefs.filter(e => !FakeWeakRef.cleanup(e, forceRemove));\n}\nfunction startFakeWeakRefsCleanup(getWindow) {\n  const context = getInstanceContext(getWindow);\n\n  if (!context.fakeWeakRefsStarted) {\n    context.fakeWeakRefsStarted = true;\n    context.WeakRef = getWeakRef(context);\n  }\n\n  if (!context.fakeWeakRefsTimer) {\n    context.fakeWeakRefsTimer = getWindow().setTimeout(() => {\n      context.fakeWeakRefsTimer = undefined;\n      cleanupFakeWeakRefs(getWindow);\n      startFakeWeakRefsCleanup(getWindow);\n    }, 2 * 60 * 1000); // 2 minutes.\n  }\n}\nfunction stopFakeWeakRefsCleanupAndClearStorage(getWindow) {\n  const context = getInstanceContext(getWindow);\n  context.fakeWeakRefsStarted = false;\n\n  if (context.fakeWeakRefsTimer) {\n    getWindow().clearTimeout(context.fakeWeakRefsTimer);\n    context.fakeWeakRefsTimer = undefined;\n    context.fakeWeakRefs = [];\n  }\n}\nfunction createElementTreeWalker(doc, root, acceptNode) {\n  // IE11 will throw an exception when the TreeWalker root is not an Element.\n  if (root.nodeType !== Node.ELEMENT_NODE) {\n    return undefined;\n  } // TypeScript isn't aware of IE11 behaving badly.\n\n\n  const filter = _isBrokenIE11 ? acceptNode : {\n    acceptNode\n  };\n  return doc.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, filter, // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore: We still don't want to completely break IE11, so, entityReferenceExpansion argument is not optional.\n  false\n  /* Last argument is not optional for IE11! */\n  );\n}\nfunction getBoundingRect(getWindow, element) {\n  let cacheId = element.__tabsterCacheId;\n  const context = getInstanceContext(getWindow);\n  const cached = cacheId ? context.containerBoundingRectCache[cacheId] : undefined;\n\n  if (cached) {\n    return cached.rect;\n  }\n\n  const scrollingElement = element.ownerDocument && element.ownerDocument.documentElement;\n\n  if (!scrollingElement) {\n    return new _DOMRect();\n  } // A bounding rect of the top-level element contains the whole page regardless of the\n  // scrollbar. So, we improvise a little and limiting the final result...\n\n\n  let left = 0;\n  let top = 0;\n  let right = scrollingElement.clientWidth;\n  let bottom = scrollingElement.clientHeight;\n\n  if (element !== scrollingElement) {\n    const r = element.getBoundingClientRect();\n    left = Math.max(left, r.left);\n    top = Math.max(top, r.top);\n    right = Math.min(right, r.right);\n    bottom = Math.min(bottom, r.bottom);\n  }\n\n  const rect = new _DOMRect(left < right ? left : -1, top < bottom ? top : -1, left < right ? right - left : 0, top < bottom ? bottom - top : 0);\n\n  if (!cacheId) {\n    cacheId = \"r-\" + ++context.lastContainerBoundingRectCacheId;\n    element.__tabsterCacheId = cacheId;\n  }\n\n  context.containerBoundingRectCache[cacheId] = {\n    rect,\n    element\n  };\n\n  if (!context.containerBoundingRectCacheTimer) {\n    context.containerBoundingRectCacheTimer = window.setTimeout(() => {\n      context.containerBoundingRectCacheTimer = undefined;\n\n      for (const cId of Object.keys(context.containerBoundingRectCache)) {\n        delete context.containerBoundingRectCache[cId].element.__tabsterCacheId;\n      }\n\n      context.containerBoundingRectCache = {};\n    }, 50);\n  }\n\n  return rect;\n}\nfunction isElementVerticallyVisibleInContainer(getWindow, element, tolerance) {\n  const container = getScrollableContainer(element);\n\n  if (!container) {\n    return false;\n  }\n\n  const containerRect = getBoundingRect(getWindow, container);\n  const elementRect = element.getBoundingClientRect();\n  const intersectionTolerance = elementRect.height * (1 - tolerance);\n  const topIntersection = Math.max(0, containerRect.top - elementRect.top);\n  const bottomIntersection = Math.max(0, elementRect.bottom - containerRect.bottom);\n  const totalIntersection = topIntersection + bottomIntersection;\n  return totalIntersection === 0 || totalIntersection <= intersectionTolerance;\n}\nfunction scrollIntoView(getWindow, element, alignToTop) {\n  // Built-in DOM's scrollIntoView() is cool, but when we have nested containers,\n  // it scrolls all of them, not just the deepest one. So, trying to work it around.\n  const container = getScrollableContainer(element);\n\n  if (container) {\n    const containerRect = getBoundingRect(getWindow, container);\n    const elementRect = element.getBoundingClientRect();\n\n    if (alignToTop) {\n      container.scrollTop += elementRect.top - containerRect.top;\n    } else {\n      container.scrollTop += elementRect.bottom - containerRect.bottom;\n    }\n  }\n}\nfunction getScrollableContainer(element) {\n  const doc = element.ownerDocument;\n\n  if (doc) {\n    for (let el = element.parentElement; el; el = el.parentElement) {\n      if (el.scrollWidth > el.clientWidth || el.scrollHeight > el.clientHeight) {\n        return el;\n      }\n    }\n\n    return doc.documentElement;\n  }\n\n  return null;\n}\nfunction makeFocusIgnored(element) {\n  element.__shouldIgnoreFocus = true;\n}\nfunction shouldIgnoreFocus(element) {\n  return !!element.__shouldIgnoreFocus;\n}\nfunction getUId(wnd) {\n  const rnd = new Uint32Array(4);\n\n  if (wnd.crypto && wnd.crypto.getRandomValues) {\n    wnd.crypto.getRandomValues(rnd);\n  } else if (wnd.msCrypto && wnd.msCrypto.getRandomValues) {\n    wnd.msCrypto.getRandomValues(rnd);\n  } else {\n    for (let i = 0; i < rnd.length; i++) {\n      rnd[i] = 0xffffffff * Math.random();\n    }\n  }\n\n  const srnd = [];\n\n  for (let i = 0; i < rnd.length; i++) {\n    srnd.push(rnd[i].toString(36));\n  }\n\n  srnd.push(\"|\");\n  srnd.push((++_uidCounter).toString(36));\n  srnd.push(\"|\");\n  srnd.push(Date.now().toString(36));\n  return srnd.join(\"\");\n}\nfunction getElementUId(getWindow, element) {\n  const context = getInstanceContext(getWindow);\n  let uid = element.__tabsterElementUID;\n\n  if (!uid) {\n    uid = element.__tabsterElementUID = getUId(getWindow());\n  }\n\n  if (!context.elementByUId[uid] && documentContains(element.ownerDocument, element)) {\n    context.elementByUId[uid] = new WeakHTMLElement(getWindow, element);\n  }\n\n  return uid;\n}\nfunction getWindowUId(win) {\n  let uid = win.__tabsterCrossOriginWindowUID;\n\n  if (!uid) {\n    uid = win.__tabsterCrossOriginWindowUID = getUId(win);\n  }\n\n  return uid;\n}\nfunction clearElementCache(getWindow, parent) {\n  const context = getInstanceContext(getWindow);\n\n  for (const key of Object.keys(context.elementByUId)) {\n    const wel = context.elementByUId[key];\n    const el = wel && wel.get();\n\n    if (el && parent) {\n      if (!parent.contains(el)) {\n        continue;\n      }\n    }\n\n    delete context.elementByUId[key];\n  }\n} // IE11 doesn't have document.contains()...\n\nfunction documentContains(doc, element) {\n  var _a;\n\n  return !!((_a = doc === null || doc === void 0 ? void 0 : doc.body) === null || _a === void 0 ? void 0 : _a.contains(element));\n}\nfunction matchesSelector(element, selector) {\n  const matches = element.matches || element.matchesSelector || element.msMatchesSelector || element.webkitMatchesSelector;\n  return matches && matches.call(element, selector);\n}\nfunction getPromise(getWindow) {\n  const context = getInstanceContext(getWindow);\n\n  if (context.basics.Promise) {\n    return context.basics.Promise;\n  }\n\n  throw new Error(\"No Promise defined.\");\n}\nfunction getWeakRef(context) {\n  return context.basics.WeakRef;\n}\nlet _lastTabsterPartId = 0;\nclass TabsterPart {\n  constructor(tabster, element, props) {\n    const getWindow = tabster.getWindow;\n    this._tabster = tabster;\n    this._element = new WeakHTMLElement(getWindow, element);\n    this._props = { ...props\n    };\n    this.id = \"i\" + ++_lastTabsterPartId;\n  }\n\n  getElement() {\n    return this._element.get();\n  }\n\n  getProps() {\n    return this._props;\n  }\n\n  setProps(props) {\n    this._props = { ...props\n    };\n  }\n\n}\n/**\r\n * Dummy HTML elements that are used as focus sentinels for the DOM enclosed within them\r\n */\n\nclass DummyInput {\n  constructor(getWindow, isOutside, props, element) {\n    var _a;\n\n    this._focusIn = e => {\n      const input = this.input;\n\n      if (this.onFocusIn && input) {\n        const relatedTarget = DummyInputManager.getLastPhantomFrom() || e.relatedTarget;\n        this.onFocusIn(this, this._isBackward(true, input, relatedTarget), relatedTarget);\n      }\n    };\n\n    this._focusOut = e => {\n      this.useDefaultAction = false;\n      const input = this.input;\n\n      if (this.onFocusOut && input) {\n        const relatedTarget = e.relatedTarget;\n        this.onFocusOut(this, this._isBackward(false, input, relatedTarget), relatedTarget);\n      }\n    };\n\n    const win = getWindow();\n    const input = win.document.createElement(\"i\");\n    input.tabIndex = 0;\n    input.setAttribute(\"role\", \"none\");\n    input.setAttribute(TabsterDummyInputAttributeName, \"\");\n    input.setAttribute(\"aria-hidden\", \"true\");\n    const style = input.style;\n    style.position = \"fixed\";\n    style.width = style.height = \"1px\";\n    style.opacity = \"0.001\";\n    style.zIndex = \"-1\";\n    style.setProperty(\"content-visibility\", \"hidden\");\n    makeFocusIgnored(input);\n    this.input = input;\n    this.isFirst = props.isFirst;\n    this.isOutside = isOutside;\n    this._isPhantom = (_a = props.isPhantom) !== null && _a !== void 0 ? _a : false;\n    input.addEventListener(\"focusin\", this._focusIn);\n    input.addEventListener(\"focusout\", this._focusOut);\n    input.__tabsterDummyContainer = element;\n\n    if (this._isPhantom) {\n      this._disposeTimer = win.setTimeout(() => {\n        delete this._disposeTimer;\n        this.dispose();\n      }, 0);\n\n      this._clearDisposeTimeout = () => {\n        if (this._disposeTimer) {\n          win.clearTimeout(this._disposeTimer);\n          delete this._disposeTimer;\n        }\n\n        delete this._clearDisposeTimeout;\n      };\n    }\n  }\n\n  dispose() {\n    var _a;\n\n    if (this._clearDisposeTimeout) {\n      this._clearDisposeTimeout();\n    }\n\n    const input = this.input;\n\n    if (!input) {\n      return;\n    }\n\n    delete this.onFocusIn;\n    delete this.onFocusOut;\n    delete this.input;\n    input.removeEventListener(\"focusin\", this._focusIn);\n    input.removeEventListener(\"focusout\", this._focusOut);\n    delete input.__tabsterDummyContainer;\n    (_a = input.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(input);\n  }\n\n  setTopLeft(top, left) {\n    var _a;\n\n    const style = (_a = this.input) === null || _a === void 0 ? void 0 : _a.style;\n\n    if (style) {\n      style.top = `${top}px`;\n      style.left = `${left}px`;\n    }\n  }\n\n  _isBackward(isIn, current, previous) {\n    return isIn && !previous ? !this.isFirst : !!(previous && current.compareDocumentPosition(previous) & Node.DOCUMENT_POSITION_FOLLOWING);\n  }\n\n}\nconst DummyInputManagerPriorities = {\n  Root: 1,\n  Modalizer: 2,\n  Mover: 3,\n  Groupper: 4\n};\nclass DummyInputManager {\n  constructor(tabster, element, priority, sys, outsideByDefault, callForDefaultAction) {\n    this._element = element;\n    this._instance = new DummyInputManagerCore(tabster, element, this, priority, sys, outsideByDefault, callForDefaultAction);\n\n    this.moveOut = backwards => {\n      var _a;\n\n      (_a = this._instance) === null || _a === void 0 ? void 0 : _a.moveOut(backwards);\n    };\n\n    this.moveOutWithDefaultAction = backwards => {\n      var _a;\n\n      (_a = this._instance) === null || _a === void 0 ? void 0 : _a.moveOutWithDefaultAction(backwards);\n    };\n  }\n\n  _setHandlers(onFocusIn, onFocusOut) {\n    this._onFocusIn = onFocusIn;\n    this._onFocusOut = onFocusOut;\n  }\n\n  getHandler(isIn) {\n    return isIn ? this._onFocusIn : this._onFocusOut;\n  }\n\n  setTabbable(tabbable) {\n    var _a;\n\n    (_a = this._instance) === null || _a === void 0 ? void 0 : _a.setTabbable(this, tabbable);\n  }\n\n  dispose() {\n    if (this._instance) {\n      this._instance.dispose(this);\n\n      delete this._instance;\n    }\n\n    delete this._onFocusIn;\n    delete this._onFocusOut;\n  }\n\n  static getLastPhantomFrom() {\n    const ret = DummyInputManager._lastPhantomFrom;\n    delete DummyInputManager._lastPhantomFrom;\n    return ret;\n  }\n\n  static moveWithPhantomDummy(tabster, element, moveOutside, isBackward) {\n    const dummy = new DummyInput(tabster.getWindow, true, {\n      isPhantom: true,\n      isFirst: true\n    });\n    const input = dummy.input;\n\n    if (input) {\n      const parent = element.parentElement;\n\n      if (parent) {\n        let insertBefore = moveOutside && !isBackward || !moveOutside && isBackward ? element.nextElementSibling : element;\n\n        if (insertBefore) {\n          if (isBackward) {\n            const beforeBefore = insertBefore.previousElementSibling;\n\n            if (beforeBefore && beforeBefore.__tabsterDummyContainer) {\n              insertBefore = beforeBefore;\n            }\n          } else if (insertBefore.__tabsterDummyContainer) {\n            insertBefore = insertBefore.nextElementSibling;\n          }\n        }\n\n        parent.insertBefore(input, insertBefore);\n        DummyInputManager._lastPhantomFrom = element;\n        tabster.getWindow().setTimeout(() => {\n          delete DummyInputManager._lastPhantomFrom;\n        }, 0);\n        nativeFocus(input);\n      }\n    }\n  }\n\n}\n\nfunction setDummyInputDebugValue(dummy, wrappers) {\n  var _a;\n\n  const what = {\n    1: \"Root\",\n    2: \"Modalizer\",\n    3: \"Mover\",\n    4: \"Groupper\"\n  };\n  (_a = dummy.input) === null || _a === void 0 ? void 0 : _a.setAttribute(TabsterDummyInputAttributeName, [`isFirst=${dummy.isFirst}`, `isOutside=${dummy.isOutside}`, ...wrappers.map(w => `(${what[w.priority]}, tabbable=${w.tabbable})`)].join(\", \"));\n}\n\nclass DummyInputObserver {\n  constructor(win) {\n    this._updateQueue = new Set();\n    this._lastUpdateQueueTime = 0;\n    this._changedParents = new WeakSet();\n    this._dummies = new Map();\n\n    this._domChanged = parent => {\n      var _a;\n\n      if (this._changedParents.has(parent)) {\n        return;\n      }\n\n      this._changedParents.add(parent);\n\n      if (this._updateDummyInputsTimer) {\n        return;\n      }\n\n      this._updateDummyInputsTimer = (_a = this._win) === null || _a === void 0 ? void 0 : _a.call(this).setTimeout(() => {\n        delete this._updateDummyInputsTimer;\n\n        for (const [dummy, callback] of this._dummies) {\n          const dummyParent = dummy.parentElement;\n\n          if (!dummyParent || this._changedParents.has(dummyParent)) {\n            callback();\n          }\n        }\n\n        this._changedParents = new WeakSet();\n      }, _updateDummyInputsTimeout);\n    };\n\n    this._win = win;\n  }\n\n  add(dummy, callback) {\n    this._dummies.set(dummy, callback);\n\n    this.domChanged = this._domChanged;\n  }\n\n  remove(dummy) {\n    const dummyInputElements = this._dummies;\n    dummyInputElements.delete(dummy);\n\n    if (dummyInputElements.size === 0) {\n      delete this.domChanged;\n    }\n  }\n\n  dispose() {\n    var _a;\n\n    const win = (_a = this._win) === null || _a === void 0 ? void 0 : _a.call(this);\n\n    if (this._updateTimer) {\n      win === null || win === void 0 ? void 0 : win.clearTimeout(this._updateTimer);\n      delete this._updateTimer;\n    }\n\n    if (this._updateDummyInputsTimer) {\n      win === null || win === void 0 ? void 0 : win.clearTimeout(this._updateDummyInputsTimer);\n      delete this._updateDummyInputsTimer;\n    }\n\n    this._changedParents = new WeakSet();\n\n    this._dummies.clear();\n\n    delete this._win;\n  }\n\n  updatePositions(compute) {\n    if (!this._win) {\n      // As this is a public method, we make sure that it has no effect when\n      // called after dispose().\n      return;\n    }\n\n    this._updateQueue.add(compute);\n\n    this._lastUpdateQueueTime = Date.now();\n\n    this._scheduledUpdatePositions();\n  }\n\n  _scheduledUpdatePositions() {\n    var _a;\n\n    if (this._updateTimer) {\n      return;\n    }\n\n    this._updateTimer = (_a = this._win) === null || _a === void 0 ? void 0 : _a.call(this).setTimeout(() => {\n      delete this._updateTimer; // updatePositions() might be called quite a lot during the scrolling.\n      // So, instead of clearing the timeout and scheduling a new one, we\n      // check if enough time has passed since the last updatePositions() call\n      // and only schedule a new one if not.\n      // At maximum, we will update dummy inputs positions\n      // _updateDummyInputsTimeout * 2 after the last updatePositions() call.\n\n      if (this._lastUpdateQueueTime + _updateDummyInputsTimeout <= Date.now()) {\n        // A cache for current bulk of updates to reduce getComputedStyle() calls.\n        const scrollTopLeftCache = new Map();\n        const setTopLeftCallbacks = [];\n\n        for (const compute of this._updateQueue) {\n          setTopLeftCallbacks.push(compute(scrollTopLeftCache));\n        }\n\n        this._updateQueue.clear(); // We're splitting the computation of offsets and setting them to avoid extra\n        // reflows.\n\n\n        for (const setTopLeft of setTopLeftCallbacks) {\n          setTopLeft();\n        } // Explicitly clear to not hold references till the next garbage collection.\n\n\n        scrollTopLeftCache.clear();\n      } else {\n        this._scheduledUpdatePositions();\n      }\n    }, _updateDummyInputsTimeout);\n  }\n\n}\n/**\r\n * Parent class that encapsulates the behaviour of dummy inputs (focus sentinels)\r\n */\n\nclass DummyInputManagerCore {\n  constructor(tabster, element, manager, priority, sys, outsideByDefault, callForDefaultAction) {\n    this._wrappers = [];\n    this._isOutside = false;\n    this._transformElements = new Set();\n\n    this._onFocusIn = (dummyInput, isBackward, relatedTarget) => {\n      this._onFocus(true, dummyInput, isBackward, relatedTarget);\n    };\n\n    this._onFocusOut = (dummyInput, isBackward, relatedTarget) => {\n      this._onFocus(false, dummyInput, isBackward, relatedTarget);\n    };\n\n    this.moveOut = backwards => {\n      var _a;\n\n      const first = this._firstDummy;\n      const last = this._lastDummy;\n\n      if (first && last) {\n        // For the sake of performance optimization, the dummy input\n        // position in the DOM updates asynchronously from the DOM change.\n        // Calling _ensurePosition() to make sure the position is correct.\n        this._ensurePosition();\n\n        const firstInput = first.input;\n        const lastInput = last.input;\n        const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();\n\n        if (firstInput && lastInput && element) {\n          let toFocus;\n\n          if (backwards) {\n            firstInput.tabIndex = 0;\n            toFocus = firstInput;\n          } else {\n            lastInput.tabIndex = 0;\n            toFocus = lastInput;\n          }\n\n          if (toFocus) {\n            nativeFocus(toFocus);\n          }\n        }\n      }\n    };\n    /**\r\n     * Prepares to move focus out of the given element by focusing\r\n     * one of the dummy inputs and setting the `useDefaultAction` flag\r\n     * @param backwards focus moving to an element behind the given element\r\n     */\n\n\n    this.moveOutWithDefaultAction = backwards => {\n      var _a;\n\n      const first = this._firstDummy;\n      const last = this._lastDummy;\n\n      if (first && last) {\n        // For the sake of performance optimization, the dummy input\n        // position in the DOM updates asynchronously from the DOM change.\n        // Calling _ensurePosition() to make sure the position is correct.\n        this._ensurePosition();\n\n        const firstInput = first.input;\n        const lastInput = last.input;\n        const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();\n\n        if (firstInput && lastInput && element) {\n          let toFocus;\n\n          if (backwards) {\n            if (!first.isOutside && this._tabster.focusable.isFocusable(element, true, true, true)) {\n              toFocus = element;\n            } else {\n              first.useDefaultAction = true;\n              firstInput.tabIndex = 0;\n              toFocus = firstInput;\n            }\n          } else {\n            last.useDefaultAction = true;\n            lastInput.tabIndex = 0;\n            toFocus = lastInput;\n          }\n\n          if (toFocus) {\n            nativeFocus(toFocus);\n          }\n        }\n      }\n    };\n\n    this.setTabbable = (manager, tabbable) => {\n      var _a, _b;\n\n      for (const w of this._wrappers) {\n        if (w.manager === manager) {\n          w.tabbable = tabbable;\n          break;\n        }\n      }\n\n      const wrapper = this._getCurrent();\n\n      if (wrapper) {\n        const tabIndex = wrapper.tabbable ? 0 : -1;\n        let input = (_a = this._firstDummy) === null || _a === void 0 ? void 0 : _a.input;\n\n        if (input) {\n          input.tabIndex = tabIndex;\n        }\n\n        input = (_b = this._lastDummy) === null || _b === void 0 ? void 0 : _b.input;\n\n        if (input) {\n          input.tabIndex = tabIndex;\n        }\n      }\n\n      if (process.env.NODE_ENV === 'development') {\n        this._firstDummy && setDummyInputDebugValue(this._firstDummy, this._wrappers);\n        this._lastDummy && setDummyInputDebugValue(this._lastDummy, this._wrappers);\n      }\n    };\n    /**\r\n     * Adds dummy inputs as the first and last child of the given element\r\n     * Called each time the children under the element is mutated\r\n     */\n\n\n    this._addDummyInputs = () => {\n      if (this._addTimer) {\n        return;\n      }\n\n      this._addTimer = this._getWindow().setTimeout(() => {\n        delete this._addTimer;\n\n        this._ensurePosition();\n\n        if (process.env.NODE_ENV === 'development') {\n          this._firstDummy && setDummyInputDebugValue(this._firstDummy, this._wrappers);\n          this._lastDummy && setDummyInputDebugValue(this._lastDummy, this._wrappers);\n        }\n\n        this._addTransformOffsets();\n      }, 0);\n    };\n\n    this._addTransformOffsets = () => {\n      this._tabster._dummyObserver.updatePositions(this._computeTransformOffsets);\n    };\n\n    this._computeTransformOffsets = scrollTopLeftCache => {\n      var _a, _b;\n\n      const from = ((_a = this._firstDummy) === null || _a === void 0 ? void 0 : _a.input) || ((_b = this._lastDummy) === null || _b === void 0 ? void 0 : _b.input);\n      const transformElements = this._transformElements;\n      const newTransformElements = new Set();\n      let scrollTop = 0;\n      let scrollLeft = 0;\n\n      const win = this._getWindow();\n\n      for (let element = from; element && element.nodeType === Node.ELEMENT_NODE; element = element.parentElement) {\n        let scrollTopLeft = scrollTopLeftCache.get(element); // getComputedStyle() and element.scrollLeft/Top() cause style recalculation,\n        // so we cache the result across all elements in the current bulk.\n\n        if (scrollTopLeft === undefined) {\n          const transform = win.getComputedStyle(element).transform;\n\n          if (transform && transform !== \"none\") {\n            scrollTopLeft = {\n              scrollTop: element.scrollTop,\n              scrollLeft: element.scrollLeft\n            };\n          }\n\n          scrollTopLeftCache.set(element, scrollTopLeft || null);\n        }\n\n        if (scrollTopLeft) {\n          newTransformElements.add(element);\n\n          if (!transformElements.has(element)) {\n            element.addEventListener(\"scroll\", this._addTransformOffsets);\n          }\n\n          scrollTop += scrollTopLeft.scrollTop;\n          scrollLeft += scrollTopLeft.scrollLeft;\n        }\n      }\n\n      for (const el of transformElements) {\n        if (!newTransformElements.has(el)) {\n          el.removeEventListener(\"scroll\", this._addTransformOffsets);\n        }\n      }\n\n      this._transformElements = newTransformElements;\n      return () => {\n        var _a, _b;\n\n        (_a = this._firstDummy) === null || _a === void 0 ? void 0 : _a.setTopLeft(scrollTop, scrollLeft);\n        (_b = this._lastDummy) === null || _b === void 0 ? void 0 : _b.setTopLeft(scrollTop, scrollLeft);\n      };\n    };\n\n    const el = element.get();\n\n    if (!el) {\n      throw new Error(\"No element\");\n    }\n\n    this._tabster = tabster;\n    this._getWindow = tabster.getWindow;\n    this._callForDefaultAction = callForDefaultAction;\n    const instance = el.__tabsterDummy;\n\n    (instance || this)._wrappers.push({\n      manager,\n      priority,\n      tabbable: true\n    });\n\n    if (instance) {\n      if (process.env.NODE_ENV === 'development') {\n        this._firstDummy && setDummyInputDebugValue(this._firstDummy, instance._wrappers);\n        this._lastDummy && setDummyInputDebugValue(this._lastDummy, instance._wrappers);\n      }\n\n      return instance;\n    }\n\n    el.__tabsterDummy = this; // Some elements allow only specific types of direct descendants and we need to\n    // put our dummy inputs inside or outside of the element accordingly.\n\n    const forcedDummyPosition = sys === null || sys === void 0 ? void 0 : sys.dummyInputsPosition;\n    const tagName = el.tagName;\n    this._isOutside = !forcedDummyPosition ? (outsideByDefault || tagName === \"UL\" || tagName === \"OL\" || tagName === \"TABLE\") && !(tagName === \"LI\" || tagName === \"TD\" || tagName === \"TH\") : forcedDummyPosition === SysDummyInputsPositions.Outside;\n    this._firstDummy = new DummyInput(this._getWindow, this._isOutside, {\n      isFirst: true\n    }, element);\n    this._lastDummy = new DummyInput(this._getWindow, this._isOutside, {\n      isFirst: false\n    }, element); // We will be checking dummy input parents to see if their child list have changed.\n    // So, it is enough to have just one of the inputs observed, because\n    // both dummy inputs always have the same parent.\n\n    const dummyElement = this._firstDummy.input;\n    dummyElement && tabster._dummyObserver.add(dummyElement, this._addDummyInputs);\n    this._firstDummy.onFocusIn = this._onFocusIn;\n    this._firstDummy.onFocusOut = this._onFocusOut;\n    this._lastDummy.onFocusIn = this._onFocusIn;\n    this._lastDummy.onFocusOut = this._onFocusOut;\n    this._element = element;\n\n    this._addDummyInputs();\n  }\n\n  dispose(manager, force) {\n    var _a, _b, _c, _d;\n\n    const wrappers = this._wrappers = this._wrappers.filter(w => w.manager !== manager && !force);\n\n    if (process.env.NODE_ENV === 'development') {\n      this._firstDummy && setDummyInputDebugValue(this._firstDummy, wrappers);\n      this._lastDummy && setDummyInputDebugValue(this._lastDummy, wrappers);\n    }\n\n    if (wrappers.length === 0) {\n      delete ((_a = this._element) === null || _a === void 0 ? void 0 : _a.get()).__tabsterDummy;\n\n      for (const el of this._transformElements) {\n        el.removeEventListener(\"scroll\", this._addTransformOffsets);\n      }\n\n      this._transformElements.clear();\n\n      const win = this._getWindow();\n\n      if (this._addTimer) {\n        win.clearTimeout(this._addTimer);\n        delete this._addTimer;\n      }\n\n      const dummyElement = (_b = this._firstDummy) === null || _b === void 0 ? void 0 : _b.input;\n      dummyElement && this._tabster._dummyObserver.remove(dummyElement);\n      (_c = this._firstDummy) === null || _c === void 0 ? void 0 : _c.dispose();\n      (_d = this._lastDummy) === null || _d === void 0 ? void 0 : _d.dispose();\n    }\n  }\n\n  _onFocus(isIn, dummyInput, isBackward, relatedTarget) {\n    var _a;\n\n    const wrapper = this._getCurrent();\n\n    if (wrapper && (!dummyInput.useDefaultAction || this._callForDefaultAction)) {\n      (_a = wrapper.manager.getHandler(isIn)) === null || _a === void 0 ? void 0 : _a(dummyInput, isBackward, relatedTarget);\n    }\n  }\n\n  _getCurrent() {\n    this._wrappers.sort((a, b) => {\n      if (a.tabbable !== b.tabbable) {\n        return a.tabbable ? -1 : 1;\n      }\n\n      return a.priority - b.priority;\n    });\n\n    return this._wrappers[0];\n  }\n\n  _ensurePosition() {\n    var _a, _b, _c;\n\n    const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();\n    const firstDummyInput = (_b = this._firstDummy) === null || _b === void 0 ? void 0 : _b.input;\n    const lastDummyInput = (_c = this._lastDummy) === null || _c === void 0 ? void 0 : _c.input;\n\n    if (!element || !firstDummyInput || !lastDummyInput) {\n      return;\n    }\n\n    if (this._isOutside) {\n      const elementParent = element.parentElement;\n\n      if (elementParent) {\n        const nextSibling = element.nextElementSibling;\n\n        if (nextSibling !== lastDummyInput) {\n          elementParent.insertBefore(lastDummyInput, nextSibling);\n        }\n\n        if (element.previousElementSibling !== firstDummyInput) {\n          elementParent.insertBefore(firstDummyInput, element);\n        }\n      }\n    } else {\n      if (element.lastElementChild !== lastDummyInput) {\n        element.appendChild(lastDummyInput);\n      }\n\n      const firstElementChild = element.firstElementChild;\n\n      if (firstElementChild && firstElementChild !== firstDummyInput) {\n        element.insertBefore(firstDummyInput, firstElementChild);\n      }\n    }\n  }\n\n}\n\nfunction getLastChild(container) {\n  let lastChild = null;\n\n  for (let i = container.lastElementChild; i; i = i.lastElementChild) {\n    lastChild = i;\n  }\n\n  return lastChild || undefined;\n}\nfunction getAdjacentElement(from, prev) {\n  let cur = from;\n  let adjacent = null;\n\n  while (cur && !adjacent) {\n    adjacent = prev ? cur.previousElementSibling : cur.nextElementSibling;\n    cur = cur.parentElement;\n  }\n\n  return adjacent || undefined;\n}\nfunction triggerEvent(target, name, details) {\n  const event = document.createEvent(\"HTMLEvents\");\n  event.initEvent(name, true, true);\n  event.details = details;\n  target.dispatchEvent(event);\n  return !event.defaultPrevented;\n}\nfunction augmentAttribute(tabster, element, name, value // Restore original value when undefined.\n) {\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const entry = tabster.storageEntry(element, true);\n  let ret = false;\n\n  if (!entry.aug) {\n    if (value === undefined) {\n      return ret;\n    }\n\n    entry.aug = {};\n  }\n\n  if (value === undefined) {\n    if (name in entry.aug) {\n      const origVal = entry.aug[name];\n      delete entry.aug[name];\n\n      if (origVal === null) {\n        element.removeAttribute(name);\n      } else {\n        element.setAttribute(name, origVal);\n      }\n\n      ret = true;\n    }\n  } else {\n    let origValue;\n\n    if (!(name in entry.aug)) {\n      origValue = element.getAttribute(name);\n    }\n\n    if (origValue !== undefined && origValue !== value) {\n      entry.aug[name] = origValue;\n\n      if (value === null) {\n        element.removeAttribute(name);\n      } else {\n        element.setAttribute(name, value);\n      }\n\n      ret = true;\n    }\n  }\n\n  if (value === undefined && Object.keys(entry.aug).length === 0) {\n    delete entry.aug;\n    tabster.storageEntry(element, false);\n  }\n\n  return ret;\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nfunction getTabsterAttribute(props, plain) {\n  const attr = JSON.stringify(props);\n\n  if (plain === true) {\n    return attr;\n  }\n\n  return {\n    [TabsterAttributeName]: attr\n  };\n}\n/**\r\n * Updates Tabster props object with new props.\r\n * @param element an element to set data-tabster attribute on.\r\n * @param props current Tabster props to update.\r\n * @param newProps new Tabster props to add.\r\n *  When the value of a property in newProps is undefined, the property\r\n *  will be removed from the attribute.\r\n */\n\nfunction mergeTabsterProps(props, newProps) {\n  for (const key of Object.keys(newProps)) {\n    const value = newProps[key];\n\n    if (value) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      props[key] = value;\n    } else {\n      delete props[key];\n    }\n  }\n}\n/**\r\n * Sets or updates Tabster attribute of the element.\r\n * @param element an element to set data-tabster attribute on.\r\n * @param newProps new Tabster props to set.\r\n * @param update if true, newProps will be merged with the existing props.\r\n *  When true and the value of a property in newProps is undefined, the property\r\n *  will be removed from the attribute.\r\n */\n\nfunction setTabsterAttribute(element, newProps, update) {\n  let props;\n\n  if (update) {\n    const attr = element.getAttribute(TabsterAttributeName);\n\n    if (attr) {\n      try {\n        props = JSON.parse(attr);\n      } catch (e) {\n        if (process.env.NODE_ENV === 'development') {\n          console.error(`data-tabster attribute error: ${e}`, element);\n        }\n      }\n    }\n  }\n\n  if (!props) {\n    props = {};\n  }\n\n  mergeTabsterProps(props, newProps);\n\n  if (Object.keys(props).length > 0) {\n    element.setAttribute(TabsterAttributeName, getTabsterAttribute(props, true));\n  } else {\n    element.removeAttribute(TabsterAttributeName);\n  }\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nfunction _setInformativeStyle$3(weakElement, remove, id) {\n  if (process.env.NODE_ENV === 'development') {\n    const element = weakElement.get();\n\n    if (element) {\n      if (remove) {\n        element.style.removeProperty(\"--tabster-root\");\n      } else {\n        element.style.setProperty(\"--tabster-root\", id + \",\");\n      }\n    }\n  }\n}\n\nclass RootDummyManager extends DummyInputManager {\n  constructor(tabster, element, setFocused, sys) {\n    super(tabster, element, DummyInputManagerPriorities.Root, sys, undefined, true);\n\n    this._onDummyInputFocus = dummyInput => {\n      var _a;\n\n      if (dummyInput.useDefaultAction) {\n        // When we've reached the last focusable element, we want to let the browser\n        // to move the focus outside of the page. In order to do that we're synchronously\n        // calling focus() of the dummy input from the Tab key handler and allowing\n        // the default action to move the focus out.\n        this._setFocused(false, true);\n      } else {\n        // The only way a dummy input gets focused is during the keyboard navigation.\n        this._tabster.keyboardNavigation.setNavigatingWithKeyboard(true);\n\n        const element = this._element.get();\n\n        if (element) {\n          this._setFocused(true, true);\n\n          const toFocus = this._tabster.focusedElement.getFirstOrLastTabbable(dummyInput.isFirst, {\n            container: element,\n            ignoreAccessibility: true\n          });\n\n          if (toFocus) {\n            nativeFocus(toFocus);\n            return;\n          }\n        }\n\n        (_a = dummyInput.input) === null || _a === void 0 ? void 0 : _a.blur();\n      }\n    };\n\n    this._setHandlers(this._onDummyInputFocus);\n\n    this._tabster = tabster;\n    this._setFocused = setFocused;\n  }\n\n}\n\nclass Root extends TabsterPart {\n  constructor(tabster, element, onDispose, props, sys) {\n    super(tabster, element, props);\n    this._isFocused = false;\n\n    this._setFocused = (hasFocused, fromAdjacent) => {\n      if (this._setFocusedTimer) {\n        this._tabster.getWindow().clearTimeout(this._setFocusedTimer);\n\n        delete this._setFocusedTimer;\n      }\n\n      if (this._isFocused === hasFocused) {\n        return;\n      }\n\n      const element = this._element.get();\n\n      if (element) {\n        if (hasFocused) {\n          this._isFocused = true;\n          triggerEvent(this._tabster.root.eventTarget, \"focus\", {\n            element,\n            fromAdjacent\n          });\n        } else {\n          this._setFocusedTimer = this._tabster.getWindow().setTimeout(() => {\n            delete this._setFocusedTimer;\n            this._isFocused = false;\n            triggerEvent(this._tabster.root.eventTarget, \"blur\", {\n              element,\n              fromAdjacent\n            });\n          }, 0);\n        }\n      }\n    };\n\n    this._onFocus = e => {\n      var _a;\n\n      const win = this._tabster.getWindow();\n\n      if (this._setTabbableTimer) {\n        win.clearTimeout(this._setTabbableTimer);\n        delete this._setTabbableTimer;\n      }\n\n      if (e) {\n        const ctx = RootAPI.getTabsterContext(this._tabster, e);\n\n        if (ctx) {\n          this._setFocused(ctx.root.getElement() === this._element.get());\n        }\n\n        if (!ctx || ctx.uncontrolled || this._tabster.rootDummyInputs) {\n          (_a = this._dummyManager) === null || _a === void 0 ? void 0 : _a.setTabbable(false);\n          return;\n        }\n      } else {\n        this._setFocused(false);\n      }\n\n      this._setTabbableTimer = win.setTimeout(() => {\n        var _a;\n\n        delete this._setTabbableTimer;\n        (_a = this._dummyManager) === null || _a === void 0 ? void 0 : _a.setTabbable(true);\n      }, 0);\n    };\n\n    this._onDispose = onDispose;\n    const win = tabster.getWindow;\n    this.uid = getElementUId(win, element);\n    this._sys = sys;\n\n    if (tabster.controlTab || tabster.rootDummyInputs) {\n      this.addDummyInputs();\n    }\n\n    tabster.focusedElement.subscribe(this._onFocus);\n\n    this._add();\n  }\n\n  addDummyInputs() {\n    if (!this._dummyManager) {\n      this._dummyManager = new RootDummyManager(this._tabster, this._element, this._setFocused, this._sys);\n    }\n  }\n\n  dispose() {\n    var _a;\n\n    this._onDispose(this);\n\n    const win = this._tabster.getWindow();\n\n    if (this._setFocusedTimer) {\n      win.clearTimeout(this._setFocusedTimer);\n      delete this._setFocusedTimer;\n    }\n\n    if (this._setTabbableTimer) {\n      win.clearTimeout(this._setTabbableTimer);\n      delete this._setTabbableTimer;\n    }\n\n    (_a = this._dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();\n\n    this._remove();\n  }\n\n  moveOutWithDefaultAction(isBackward) {\n    const dummyManager = this._dummyManager;\n\n    if (dummyManager) {\n      dummyManager.moveOutWithDefaultAction(isBackward);\n    } else {\n      const el = this.getElement();\n\n      if (el) {\n        RootDummyManager.moveWithPhantomDummy(this._tabster, el, true, isBackward);\n      }\n    }\n  }\n\n  _add() {\n    if (process.env.NODE_ENV === 'development') {\n      _setInformativeStyle$3(this._element, false, this.uid);\n    }\n  }\n\n  _remove() {\n    if (process.env.NODE_ENV === 'development') {\n      _setInformativeStyle$3(this._element, true);\n    }\n  }\n\n} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\nclass RootAPI {\n  constructor(tabster, autoRoot) {\n    this._autoRootWaiting = false;\n    this._roots = {};\n    this._forceDummy = false;\n    this.rootById = {};\n\n    this._autoRootCreate = () => {\n      var _a;\n\n      const doc = this._win().document;\n\n      const body = doc.body;\n\n      if (body) {\n        this._autoRootUnwait(doc);\n\n        const props = this._autoRoot;\n\n        if (props) {\n          setTabsterAttribute(body, {\n            root: props\n          }, true);\n          updateTabsterByAttribute(this._tabster, body);\n          return (_a = getTabsterOnElement(this._tabster, body)) === null || _a === void 0 ? void 0 : _a.root;\n        }\n      } else if (!this._autoRootWaiting) {\n        this._autoRootWaiting = true;\n        doc.addEventListener(\"readystatechange\", this._autoRootCreate);\n      }\n\n      return undefined;\n    };\n\n    this._onRootDispose = root => {\n      delete this._roots[root.id];\n    };\n\n    this._tabster = tabster;\n    this._win = tabster.getWindow;\n    this._autoRoot = autoRoot;\n    this.eventTarget = createEventTarget(this._win);\n    tabster.queueInit(() => {\n      if (this._autoRoot) {\n        this._autoRootCreate();\n      }\n    });\n  }\n\n  _autoRootUnwait(doc) {\n    doc.removeEventListener(\"readystatechange\", this._autoRootCreate);\n    this._autoRootWaiting = false;\n  }\n\n  dispose() {\n    const win = this._win();\n\n    this._autoRootUnwait(win.document);\n\n    delete this._autoRoot;\n    Object.keys(this._roots).forEach(rootId => {\n      if (this._roots[rootId]) {\n        this._roots[rootId].dispose();\n\n        delete this._roots[rootId];\n      }\n    });\n    this.rootById = {};\n  }\n\n  createRoot(element, props, sys) {\n    if (process.env.NODE_ENV === 'development') ;\n\n    const newRoot = new Root(this._tabster, element, this._onRootDispose, props, sys);\n    this._roots[newRoot.id] = newRoot;\n\n    if (this._forceDummy) {\n      newRoot.addDummyInputs();\n    }\n\n    return newRoot;\n  }\n\n  addDummyInputs() {\n    this._forceDummy = true;\n    const roots = this._roots;\n\n    for (const id of Object.keys(roots)) {\n      roots[id].addDummyInputs();\n    }\n  }\n\n  static getRootByUId(getWindow, id) {\n    const tabster = getWindow().__tabsterInstance;\n\n    return tabster && tabster.root.rootById[id];\n  }\n  /**\r\n   * Fetches the tabster context for an element walking up its ancestors\r\n   *\r\n   * @param tabster Tabster instance\r\n   * @param element The element the tabster context should represent\r\n   * @param options Additional options\r\n   * @returns undefined if the element is not a child of a tabster root, otherwise all applicable tabster behaviours and configurations\r\n   */\n\n\n  static getTabsterContext(tabster, element, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _a, _b, _c, _d;\n\n    if (!element.ownerDocument) {\n      return undefined;\n    }\n\n    const {\n      checkRtl,\n      referenceElement\n    } = options;\n    const getParent = tabster.getParent; // Normally, the initialization starts on the next tick after the tabster\n    // instance creation. However, if the application starts using it before\n    // the next tick, we need to make sure the initialization is done.\n\n    tabster.drainInitQueue();\n    let root;\n    let modalizer;\n    let groupper;\n    let mover;\n    let isExcludedFromMover = false;\n    let isGroupperFirst;\n    let modalizerInGroupper;\n    let isRtl;\n    let uncontrolled;\n    let curElement = referenceElement || element;\n    const ignoreKeydown = {};\n\n    while (curElement && (!root || checkRtl)) {\n      const tabsterOnElement = getTabsterOnElement(tabster, curElement);\n\n      if (checkRtl && isRtl === undefined) {\n        const dir = curElement.dir;\n\n        if (dir) {\n          isRtl = dir.toLowerCase() === \"rtl\";\n        }\n      }\n\n      if (!tabsterOnElement) {\n        curElement = getParent(curElement);\n        continue;\n      }\n\n      const tagName = curElement.tagName;\n\n      if (tabsterOnElement.uncontrolled || tagName === \"IFRAME\" || tagName === \"WEBVIEW\") {\n        uncontrolled = curElement;\n      }\n\n      if (!mover && ((_a = tabsterOnElement.focusable) === null || _a === void 0 ? void 0 : _a.excludeFromMover) && !groupper) {\n        isExcludedFromMover = true;\n      }\n\n      const curModalizer = tabsterOnElement.modalizer;\n      const curGroupper = tabsterOnElement.groupper;\n      const curMover = tabsterOnElement.mover;\n\n      if (!modalizer && curModalizer) {\n        modalizer = curModalizer;\n      }\n\n      if (!groupper && curGroupper && (!modalizer || curModalizer)) {\n        if (modalizer) {\n          // Modalizer dominates the groupper when they are on the same node and the groupper is active.\n          if (!curGroupper.isActive() && curGroupper.getProps().tabbability && modalizer.userId !== ((_b = tabster.modalizer) === null || _b === void 0 ? void 0 : _b.activeId)) {\n            modalizer = undefined;\n            groupper = curGroupper;\n          }\n\n          modalizerInGroupper = curGroupper;\n        } else {\n          groupper = curGroupper;\n        }\n      }\n\n      if (!mover && curMover && (!modalizer || curModalizer) && (!curGroupper || curElement !== element)) {\n        mover = curMover;\n        isGroupperFirst = !!groupper && groupper !== curGroupper;\n      }\n\n      if (tabsterOnElement.root) {\n        root = tabsterOnElement.root;\n      }\n\n      if ((_c = tabsterOnElement.focusable) === null || _c === void 0 ? void 0 : _c.ignoreKeydown) {\n        Object.assign(ignoreKeydown, tabsterOnElement.focusable.ignoreKeydown);\n      }\n\n      curElement = getParent(curElement);\n    } // No root element could be found, try to get an auto root\n\n\n    if (!root) {\n      const rootAPI = tabster.root;\n      const autoRoot = rootAPI._autoRoot;\n\n      if (autoRoot) {\n        if ((_d = element.ownerDocument) === null || _d === void 0 ? void 0 : _d.body) {\n          root = rootAPI._autoRootCreate();\n        }\n      }\n    }\n\n    if (groupper && !mover) {\n      isGroupperFirst = true;\n    }\n\n    if (process.env.NODE_ENV === 'development' && !root) {\n      if (modalizer || groupper || mover) {\n        console.error(\"Tabster Root is required for Mover, Groupper and Modalizer to work.\");\n      }\n    }\n\n    const shouldIgnoreKeydown = event => !!ignoreKeydown[event.key];\n\n    return root ? {\n      root,\n      modalizer,\n      groupper,\n      mover,\n      isGroupperFirst,\n      modalizerInGroupper,\n      isRtl: checkRtl ? !!isRtl : undefined,\n      uncontrolled,\n      isExcludedFromMover,\n      ignoreKeydown: shouldIgnoreKeydown\n    } : undefined;\n  }\n\n  static getRoot(tabster, element) {\n    var _a;\n\n    for (let el = element; el; el = el.parentElement) {\n      const root = (_a = getTabsterOnElement(tabster, el)) === null || _a === void 0 ? void 0 : _a.root;\n\n      if (root) {\n        return root;\n      }\n    }\n\n    return undefined;\n  }\n\n  onRoot(root, removed) {\n    if (removed) {\n      delete this.rootById[root.uid];\n    } else {\n      this.rootById[root.uid] = root;\n    }\n  }\n\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst _containerHistoryLength = 10;\nclass DeloserItemBase {}\nclass DeloserItem extends DeloserItemBase {\n  constructor(tabster, deloser) {\n    super();\n    this.uid = deloser.uid;\n    this._tabster = tabster;\n    this._deloser = deloser;\n  }\n\n  belongsTo(deloser) {\n    return deloser === this._deloser;\n  }\n\n  unshift(element) {\n    this._deloser.unshift(element);\n  }\n\n  async focusAvailable() {\n    const available = this._deloser.findAvailable();\n\n    return available ? this._tabster.focusedElement.focus(available) : false;\n  }\n\n  async resetFocus() {\n    const getWindow = this._tabster.getWindow;\n    return getPromise(getWindow).resolve(this._deloser.resetFocus());\n  }\n\n}\nclass DeloserHistoryByRootBase {\n  constructor(tabster, rootUId) {\n    this._history = [];\n    this._tabster = tabster;\n    this.rootUId = rootUId;\n  }\n\n  getLength() {\n    return this._history.length;\n  }\n\n  removeDeloser(deloser) {\n    this._history = this._history.filter(c => !c.belongsTo(deloser));\n  }\n\n  hasDeloser(deloser) {\n    return this._history.some(d => d.belongsTo(deloser));\n  }\n\n}\n\nclass DeloserHistoryByRoot extends DeloserHistoryByRootBase {\n  unshiftToDeloser(deloser, element) {\n    let item;\n\n    for (let i = 0; i < this._history.length; i++) {\n      if (this._history[i].belongsTo(deloser)) {\n        item = this._history[i];\n\n        this._history.splice(i, 1);\n\n        break;\n      }\n    }\n\n    if (!item) {\n      item = new DeloserItem(this._tabster, deloser);\n    }\n\n    item.unshift(element);\n\n    this._history.unshift(item);\n\n    this._history.splice(_containerHistoryLength, this._history.length - _containerHistoryLength);\n  }\n\n  async focusAvailable(from) {\n    let skip = !!from;\n\n    for (const i of this._history) {\n      if (from && i.belongsTo(from)) {\n        skip = false;\n      }\n\n      if (!skip && (await i.focusAvailable())) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  async resetFocus(from) {\n    let skip = !!from;\n    const resetQueue = {};\n\n    for (const i of this._history) {\n      if (from && i.belongsTo(from)) {\n        skip = false;\n      }\n\n      if (!skip && !resetQueue[i.uid]) {\n        resetQueue[i.uid] = i;\n      }\n    } // Nothing is found, at least try to reset.\n\n\n    for (const id of Object.keys(resetQueue)) {\n      if (await resetQueue[id].resetFocus()) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n}\n\nclass DeloserHistory {\n  constructor(tabster) {\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    this._history = [];\n    this._tabster = tabster;\n  }\n\n  dispose() {\n    this._history = [];\n  }\n\n  process(element) {\n    var _a;\n\n    const ctx = RootAPI.getTabsterContext(this._tabster, element);\n    const rootUId = ctx && ctx.root.uid;\n    const deloser = DeloserAPI.getDeloser(this._tabster, element);\n\n    if (!rootUId || !deloser) {\n      return undefined;\n    }\n\n    const historyByRoot = this.make(rootUId, () => new DeloserHistoryByRoot(this._tabster, rootUId));\n\n    if (!ctx || !ctx.modalizer || ((_a = ctx.modalizer) === null || _a === void 0 ? void 0 : _a.isActive())) {\n      historyByRoot.unshiftToDeloser(deloser, element);\n    }\n\n    return deloser;\n  }\n\n  make(rootUId, createInstance) {\n    let historyByRoot;\n\n    for (let i = 0; i < this._history.length; i++) {\n      const hbr = this._history[i];\n\n      if (hbr.rootUId === rootUId) {\n        historyByRoot = hbr;\n\n        this._history.splice(i, 1);\n\n        break;\n      }\n    }\n\n    if (!historyByRoot) {\n      historyByRoot = createInstance();\n    }\n\n    this._history.unshift(historyByRoot);\n\n    this._history.splice(_containerHistoryLength, this._history.length - _containerHistoryLength);\n\n    return historyByRoot;\n  }\n\n  removeDeloser(deloser) {\n    this._history.forEach(i => {\n      i.removeDeloser(deloser);\n    });\n\n    this._history = this._history.filter(i => i.getLength() > 0);\n  }\n\n  async focusAvailable(from) {\n    let skip = !!from;\n\n    for (const h of this._history) {\n      if (from && h.hasDeloser(from)) {\n        skip = false;\n      }\n\n      if (!skip && (await h.focusAvailable(from))) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  async resetFocus(from) {\n    let skip = !!from;\n\n    for (const h of this._history) {\n      if (from && h.hasDeloser(from)) {\n        skip = false;\n      }\n\n      if (!skip && (await h.resetFocus(from))) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n}\n\nfunction _setInformativeStyle$2(weakElement, remove, isActive, snapshotIndex) {\n  if (process.env.NODE_ENV === 'development') {\n    const element = weakElement.get();\n\n    if (element) {\n      if (remove) {\n        element.style.removeProperty(\"--tabster-deloser\");\n      } else {\n        element.style.setProperty(\"--tabster-deloser\", (isActive ? \"active\" : \"inactive\") + \",\" + (\"snapshot-\" + snapshotIndex));\n      }\n    }\n  }\n}\n\nfunction buildElementSelector(element, withClass, withIndex) {\n  const selector = [];\n  const escapeRegExp = /(:|\\.|\\[|\\]|,|=|@)/g;\n  const escapeReplaceValue = \"\\\\$1\";\n  const elementId = element.getAttribute(\"id\");\n\n  if (elementId) {\n    selector.push(\"#\" + elementId.replace(escapeRegExp, escapeReplaceValue));\n  }\n\n  if (withClass !== false && element.className) {\n    element.className.split(\" \").forEach(cls => {\n      cls = cls.trim();\n\n      if (cls) {\n        selector.push(\".\" + cls.replace(escapeRegExp, escapeReplaceValue));\n      }\n    });\n  }\n\n  let index = 0;\n  let el;\n\n  if (withIndex !== false && selector.length === 0) {\n    el = element;\n\n    while (el) {\n      index++;\n      el = el.previousElementSibling;\n    }\n\n    selector.unshift(\":nth-child(\" + index + \")\");\n  }\n\n  selector.unshift(element.tagName.toLowerCase());\n  return selector.join(\"\");\n}\n\nfunction buildSelector(element) {\n  if (!documentContains(element.ownerDocument, element)) {\n    return undefined;\n  }\n\n  const selector = [buildElementSelector(element)];\n  let el = element.parentElement;\n\n  while (el) {\n    const isBody = el.tagName === \"BODY\";\n    selector.unshift(buildElementSelector(el, false, !isBody));\n\n    if (isBody) {\n      break;\n    }\n\n    el = el.parentElement;\n  }\n\n  return selector.join(\" \");\n}\n\nclass Deloser extends TabsterPart {\n  constructor(tabster, element, onDispose, props) {\n    super(tabster, element, props);\n    this._isActive = false;\n    this._history = [[]];\n    this._snapshotIndex = 0;\n\n    this.isActive = () => {\n      return this._isActive;\n    };\n\n    this.setSnapshot = index => {\n      this._snapshotIndex = index;\n\n      if (this._history.length > index + 1) {\n        this._history.splice(index + 1, this._history.length - index - 1);\n      }\n\n      if (!this._history[index]) {\n        this._history[index] = [];\n      }\n\n      if (process.env.NODE_ENV === 'development') {\n        _setInformativeStyle$2(this._element, false, this._isActive, this._snapshotIndex);\n      }\n    };\n\n    this.focusFirst = () => {\n      const e = this._element.get();\n\n      return !!e && this._tabster.focusedElement.focusFirst({\n        container: e\n      });\n    };\n\n    this.focusDefault = () => {\n      const e = this._element.get();\n\n      return !!e && this._tabster.focusedElement.focusDefault(e);\n    };\n\n    this.resetFocus = () => {\n      const e = this._element.get();\n\n      return !!e && this._tabster.focusedElement.resetFocus(e);\n    };\n\n    this.clearHistory = preserveExisting => {\n      const element = this._element.get();\n\n      if (!element) {\n        this._history[this._snapshotIndex] = [];\n        return;\n      }\n\n      this._history[this._snapshotIndex] = this._history[this._snapshotIndex].filter(we => {\n        const e = we.get();\n        return e && preserveExisting ? element.contains(e) : false;\n      });\n    };\n\n    this.uid = getElementUId(tabster.getWindow, element);\n    this._onDispose = onDispose;\n\n    if (process.env.NODE_ENV === 'development') {\n      _setInformativeStyle$2(this._element, false, this._isActive, this._snapshotIndex);\n    }\n  }\n\n  dispose() {\n    this._remove();\n\n    this._onDispose(this);\n\n    this._isActive = false;\n    this._snapshotIndex = 0;\n    this._props = {};\n    this._history = [];\n  }\n\n  setActive(active) {\n    this._isActive = active;\n\n    if (process.env.NODE_ENV === 'development') {\n      _setInformativeStyle$2(this._element, false, this._isActive, this._snapshotIndex);\n    }\n  }\n\n  getActions() {\n    return {\n      focusDefault: this.focusDefault,\n      focusFirst: this.focusFirst,\n      resetFocus: this.resetFocus,\n      clearHistory: this.clearHistory,\n      setSnapshot: this.setSnapshot,\n      isActive: this.isActive\n    };\n  }\n\n  unshift(element) {\n    let cur = this._history[this._snapshotIndex];\n    cur = this._history[this._snapshotIndex] = cur.filter(we => {\n      const e = we.get();\n      return e && e !== element;\n    });\n    cur.unshift(new WeakHTMLElement(this._tabster.getWindow, element, buildSelector(element)));\n\n    while (cur.length > _containerHistoryLength) {\n      cur.pop();\n    }\n  }\n\n  findAvailable() {\n    const element = this._element.get();\n\n    if (!element || !this._tabster.focusable.isVisible(element)) {\n      return null;\n    }\n\n    let restoreFocusOrder = this._props.restoreFocusOrder;\n    let available = null;\n    const ctx = RootAPI.getTabsterContext(this._tabster, element);\n\n    if (!ctx) {\n      return null;\n    }\n\n    const root = ctx.root;\n    const rootElement = root.getElement();\n\n    if (!rootElement) {\n      return null;\n    }\n\n    if (restoreFocusOrder === undefined) {\n      restoreFocusOrder = root.getProps().restoreFocusOrder;\n    }\n\n    if (restoreFocusOrder === RestoreFocusOrders.RootDefault) {\n      available = this._tabster.focusable.findDefault({\n        container: rootElement\n      });\n    }\n\n    if (!available && restoreFocusOrder === RestoreFocusOrders.RootFirst) {\n      available = this._findFirst(rootElement);\n    }\n\n    if (available) {\n      return available;\n    }\n\n    const availableInHistory = this._findInHistory();\n\n    const availableDefault = this._tabster.focusable.findDefault({\n      container: element\n    });\n\n    const availableFirst = this._findFirst(element);\n\n    if (availableInHistory && restoreFocusOrder === RestoreFocusOrders.History) {\n      return availableInHistory;\n    }\n\n    if (availableDefault && restoreFocusOrder === RestoreFocusOrders.DeloserDefault) {\n      return availableDefault;\n    }\n\n    if (availableFirst && restoreFocusOrder === RestoreFocusOrders.DeloserFirst) {\n      return availableFirst;\n    }\n\n    return availableDefault || availableInHistory || availableFirst || null;\n  }\n\n  customFocusLostHandler(element) {\n    return triggerEvent(element, DeloserEventName, this.getActions());\n  }\n\n  _findInHistory() {\n    const cur = this._history[this._snapshotIndex].slice(0);\n\n    this.clearHistory(true);\n\n    for (let i = 0; i < cur.length; i++) {\n      const we = cur[i];\n      const e = we.get();\n\n      const element = this._element.get();\n\n      if (e && element && element.contains(e)) {\n        if (this._tabster.focusable.isFocusable(e)) {\n          return e;\n        }\n      } else if (!this._props.noSelectorCheck) {\n        // Element is not in the DOM, try to locate the node by it's\n        // selector. This might return not exactly the right node,\n        // but it would be easily fixable by having more detailed selectors.\n        const selector = we.getData();\n\n        if (selector && element) {\n          let els;\n\n          try {\n            els = element.ownerDocument.querySelectorAll(selector);\n          } catch (e) {\n            if (process.env.NODE_ENV === 'development') {\n              // This should never happen, unless there is some bug in buildElementSelector().\n              console.error(`Failed to querySelectorAll('${selector}')`);\n            }\n\n            continue;\n          }\n\n          for (let i = 0; i < els.length; i++) {\n            const el = els[i];\n\n            if (el && this._tabster.focusable.isFocusable(el)) {\n              return el;\n            }\n          }\n        }\n      }\n    }\n\n    return null;\n  }\n\n  _findFirst(element) {\n    if (this._tabster.keyboardNavigation.isNavigatingWithKeyboard()) {\n      const first = this._tabster.focusable.findFirst({\n        container: element,\n        ignoreUncontrolled: true,\n        useActiveModalizer: true\n      });\n\n      if (first) {\n        return first;\n      }\n    }\n\n    return null;\n  }\n\n  _remove() {\n    if (process.env.NODE_ENV === 'development') {\n      _setInformativeStyle$2(this._element, true);\n    }\n  }\n\n} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\nclass DeloserAPI {\n  constructor(tabster, props) {\n    /**\r\n     * Tracks if focus is inside a deloser\r\n     */\n    this._inDeloser = false;\n    this._isRestoringFocus = false;\n    this._isPaused = false;\n\n    this._onFocus = e => {\n      if (this._restoreFocusTimer) {\n        this._win().clearTimeout(this._restoreFocusTimer);\n\n        this._restoreFocusTimer = undefined;\n      }\n\n      if (!e) {\n        this._scheduleRestoreFocus();\n\n        return;\n      }\n\n      const deloser = this._history.process(e);\n\n      if (deloser) {\n        this._activate(deloser);\n      } else {\n        this._deactivate();\n      }\n    };\n\n    this._onDeloserDispose = deloser => {\n      this._history.removeDeloser(deloser);\n\n      if (deloser.isActive()) {\n        this._scheduleRestoreFocus();\n      }\n    };\n\n    this._tabster = tabster;\n    this._win = tabster.getWindow;\n    this._history = new DeloserHistory(tabster);\n    tabster.queueInit(() => {\n      this._tabster.focusedElement.subscribe(this._onFocus);\n\n      const doc = this._win().document;\n\n      const activeElement = doc.activeElement;\n\n      if (activeElement && activeElement !== doc.body) {\n        // Adding currently focused element to the deloser history.\n        this._onFocus(activeElement);\n      }\n    });\n    const autoDeloser = props === null || props === void 0 ? void 0 : props.autoDeloser;\n\n    if (autoDeloser) {\n      this._autoDeloser = autoDeloser;\n    }\n  }\n\n  dispose() {\n    const win = this._win();\n\n    if (this._restoreFocusTimer) {\n      win.clearTimeout(this._restoreFocusTimer);\n      this._restoreFocusTimer = undefined;\n    }\n\n    if (this._autoDeloserInstance) {\n      this._autoDeloserInstance.dispose();\n\n      delete this._autoDeloserInstance;\n      delete this._autoDeloser;\n    }\n\n    this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n    this._history.dispose();\n\n    delete this._curDeloser;\n  }\n\n  createDeloser(element, props) {\n    var _a;\n\n    if (process.env.NODE_ENV === 'development') ;\n\n    const deloser = new Deloser(this._tabster, element, this._onDeloserDispose, props);\n\n    if (element.contains((_a = this._tabster.focusedElement.getFocusedElement()) !== null && _a !== void 0 ? _a : null)) {\n      this._activate(deloser);\n    }\n\n    return deloser;\n  }\n\n  getActions(element) {\n    for (let e = element; e; e = e.parentElement) {\n      const tabsterOnElement = getTabsterOnElement(this._tabster, e);\n\n      if (tabsterOnElement && tabsterOnElement.deloser) {\n        return tabsterOnElement.deloser.getActions();\n      }\n    }\n\n    return undefined;\n  }\n\n  pause() {\n    this._isPaused = true;\n\n    if (this._restoreFocusTimer) {\n      this._win().clearTimeout(this._restoreFocusTimer);\n\n      this._restoreFocusTimer = undefined;\n    }\n  }\n\n  resume(restore) {\n    this._isPaused = false;\n\n    if (restore) {\n      this._scheduleRestoreFocus();\n    }\n  }\n  /**\r\n   * Activates and sets the current deloser\r\n   */\n\n\n  _activate(deloser) {\n    const curDeloser = this._curDeloser;\n\n    if (curDeloser !== deloser) {\n      this._inDeloser = true;\n      curDeloser === null || curDeloser === void 0 ? void 0 : curDeloser.setActive(false);\n      deloser.setActive(true);\n      this._curDeloser = deloser;\n    }\n  }\n  /**\r\n   * Called when focus should no longer be in a deloser\r\n   */\n\n\n  _deactivate() {\n    var _a;\n\n    this._inDeloser = false;\n    (_a = this._curDeloser) === null || _a === void 0 ? void 0 : _a.setActive(false);\n    this._curDeloser = undefined;\n  }\n\n  _scheduleRestoreFocus(force) {\n    if (this._isPaused || this._isRestoringFocus) {\n      return;\n    }\n\n    const restoreFocus = async () => {\n      this._restoreFocusTimer = undefined;\n\n      const lastFocused = this._tabster.focusedElement.getLastFocusedElement();\n\n      if (!force && (this._isRestoringFocus || !this._inDeloser || !!(lastFocused === null || lastFocused === void 0 ? void 0 : lastFocused.offsetParent))) {\n        return;\n      }\n\n      const curDeloser = this._curDeloser;\n\n      if (curDeloser) {\n        if (lastFocused && curDeloser.customFocusLostHandler(lastFocused)) {\n          return;\n        }\n\n        const el = curDeloser.findAvailable();\n\n        if (el && this._tabster.focusedElement.focus(el)) {\n          return;\n        }\n      }\n\n      this._deactivate();\n\n      this._isRestoringFocus = true;\n\n      if (!(await this._history.focusAvailable(null))) {\n        await this._history.resetFocus(null);\n      }\n\n      this._isRestoringFocus = false;\n    };\n\n    if (force) {\n      restoreFocus();\n    } else {\n      this._restoreFocusTimer = this._win().setTimeout(restoreFocus, 100);\n    }\n  }\n\n  static getDeloser(tabster, element) {\n    var _a;\n\n    let root;\n\n    for (let e = element; e; e = e.parentElement) {\n      const tabsterOnElement = getTabsterOnElement(tabster, e);\n\n      if (tabsterOnElement) {\n        if (!root) {\n          root = tabsterOnElement.root;\n        }\n\n        const deloser = tabsterOnElement.deloser;\n\n        if (deloser) {\n          return deloser;\n        }\n      }\n    }\n\n    const deloserAPI = tabster.deloser && tabster.deloser;\n\n    if (deloserAPI) {\n      if (deloserAPI._autoDeloserInstance) {\n        return deloserAPI._autoDeloserInstance;\n      }\n\n      const autoDeloserProps = deloserAPI._autoDeloser;\n\n      if (root && !deloserAPI._autoDeloserInstance && autoDeloserProps) {\n        const body = (_a = element.ownerDocument) === null || _a === void 0 ? void 0 : _a.body;\n\n        if (body) {\n          deloserAPI._autoDeloserInstance = new Deloser(tabster, body, tabster.deloser._onDeloserDispose, autoDeloserProps);\n        }\n      }\n\n      return deloserAPI._autoDeloserInstance;\n    }\n\n    return undefined;\n  }\n\n  static getHistory(instance) {\n    return instance._history;\n  }\n\n  static forceRestoreFocus(instance) {\n    instance._scheduleRestoreFocus(true);\n  }\n\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nclass Subscribable {\n  constructor() {\n    this._callbacks = [];\n  }\n\n  dispose() {\n    this._callbacks = [];\n    delete this._val;\n  }\n\n  subscribe(callback) {\n    const callbacks = this._callbacks;\n    const index = callbacks.indexOf(callback);\n\n    if (index < 0) {\n      callbacks.push(callback);\n    }\n  }\n\n  subscribeFirst(callback) {\n    const callbacks = this._callbacks;\n    const index = callbacks.indexOf(callback);\n\n    if (index >= 0) {\n      callbacks.splice(index, 1);\n    }\n\n    callbacks.unshift(callback);\n  }\n\n  unsubscribe(callback) {\n    const index = this._callbacks.indexOf(callback);\n\n    if (index >= 0) {\n      this._callbacks.splice(index, 1);\n    }\n  }\n\n  setVal(val, details) {\n    if (this._val === val) {\n      return;\n    }\n\n    this._val = val;\n\n    this._callCallbacks(val, details);\n  }\n\n  getVal() {\n    return this._val;\n  }\n\n  trigger(val, details) {\n    this._callCallbacks(val, details);\n  }\n\n  _callCallbacks(val, details) {\n    this._callbacks.forEach(callback => callback(val, details));\n  }\n\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst _transactionTimeout = 1500;\nconst _pingTimeout = 3000;\nconst _targetIdUp = \"up\";\nconst CrossOriginTransactionTypes = {\n  Bootstrap: 1,\n  FocusElement: 2,\n  State: 3,\n  GetElement: 4,\n  RestoreFocusInDeloser: 5,\n  Ping: 6\n};\n\nclass CrossOriginDeloserItem extends DeloserItemBase {\n  constructor(tabster, deloser, trasactions) {\n    super();\n    this._deloser = deloser;\n    this._transactions = trasactions;\n  }\n\n  belongsTo(deloser) {\n    return deloser.deloserUId === this._deloser.deloserUId;\n  }\n\n  async focusAvailable() {\n    const data = { ...this._deloser,\n      reset: false\n    };\n    return this._transactions.beginTransaction(RestoreFocusInDeloserTransaction, data).then(value => !!value);\n  }\n\n  async resetFocus() {\n    const data = { ...this._deloser,\n      reset: true\n    };\n    return this._transactions.beginTransaction(RestoreFocusInDeloserTransaction, data).then(value => !!value);\n  }\n\n}\n\nclass CrossOriginDeloserHistoryByRoot extends DeloserHistoryByRootBase {\n  constructor(tabster, rootUId, transactions) {\n    super(tabster, rootUId);\n    this._transactions = transactions;\n  }\n\n  unshift(deloser) {\n    let item;\n\n    for (let i = 0; i < this._history.length; i++) {\n      if (this._history[i].belongsTo(deloser)) {\n        item = this._history[i];\n\n        this._history.splice(i, 1);\n\n        break;\n      }\n    }\n\n    if (!item) {\n      item = new CrossOriginDeloserItem(this._tabster, deloser, this._transactions);\n    }\n\n    this._history.unshift(item);\n\n    this._history.splice(10, this._history.length - 10);\n  }\n\n  async focusAvailable() {\n    for (const i of this._history) {\n      if (await i.focusAvailable()) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  async resetFocus() {\n    for (const i of this._history) {\n      if (await i.resetFocus()) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n}\n\nclass CrossOriginTransaction {\n  constructor(tabster, getOwner, knownTargets, value, timeout, sentTo, targetId, sendUp) {\n    this._inProgress = {};\n    this._isDone = false;\n    this._isSelfResponding = false;\n    this._sentCount = 0;\n    this.tabster = tabster;\n    this.owner = getOwner;\n    this.ownerId = getWindowUId(getOwner());\n    this.id = getUId(getOwner());\n    this.beginData = value;\n    this._knownTargets = knownTargets;\n    this._sentTo = sentTo || {\n      [this.ownerId]: true\n    };\n    this.targetId = targetId;\n    this.sendUp = sendUp;\n    this.timeout = timeout;\n    this._promise = new (getPromise(getOwner))((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n  }\n\n  getTargets(knownTargets) {\n    return this.targetId === _targetIdUp ? this.sendUp ? {\n      [_targetIdUp]: {\n        send: this.sendUp\n      }\n    } : null : this.targetId ? knownTargets[this.targetId] ? {\n      [this.targetId]: {\n        send: knownTargets[this.targetId].send\n      }\n    } : null : Object.keys(knownTargets).length === 0 && this.sendUp ? {\n      [_targetIdUp]: {\n        send: this.sendUp\n      }\n    } : Object.keys(knownTargets).length > 0 ? knownTargets : null;\n  }\n\n  begin(selfResponse) {\n    const targets = this.getTargets(this._knownTargets);\n    const sentTo = { ...this._sentTo\n    };\n\n    if (targets) {\n      for (const id of Object.keys(targets)) {\n        sentTo[id] = true;\n      }\n    }\n\n    const data = {\n      transaction: this.id,\n      type: this.type,\n      isResponse: false,\n      timestamp: Date.now(),\n      owner: this.ownerId,\n      sentto: sentTo,\n      timeout: this.timeout,\n      beginData: this.beginData\n    };\n\n    if (this.targetId) {\n      data.target = this.targetId;\n    }\n\n    if (selfResponse) {\n      this._isSelfResponding = true;\n      selfResponse(data).then(value => {\n        this._isSelfResponding = false;\n\n        if (value !== undefined) {\n          if (!this.endData) {\n            this.endData = value;\n          }\n        }\n\n        if (this.endData || this._sentCount === 0) {\n          this.end();\n        }\n      });\n    }\n\n    if (targets) {\n      for (const id of Object.keys(targets)) {\n        if (!(id in this._sentTo)) {\n          this._send(targets[id].send, id, data);\n        }\n      }\n    }\n\n    if (this._sentCount === 0 && !this._isSelfResponding) {\n      this.end();\n    }\n\n    return this._promise;\n  }\n\n  _send(send, targetId, data) {\n    if (this._inProgress[targetId] === undefined) {\n      this._inProgress[targetId] = true;\n      this._sentCount++;\n      send(data);\n    }\n  }\n\n  end(error) {\n    if (this._isDone) {\n      return;\n    }\n\n    this._isDone = true;\n\n    if (this.endData === undefined && error) {\n      if (this._reject) {\n        this._reject(error);\n      }\n    } else if (this._resolve) {\n      this._resolve(this.endData);\n    }\n  }\n\n  onResponse(data) {\n    const endData = data.endData;\n\n    if (endData !== undefined && !this.endData) {\n      this.endData = endData;\n    }\n\n    const inProgressId = data.target === _targetIdUp ? _targetIdUp : data.owner;\n\n    if (this._inProgress[inProgressId]) {\n      this._inProgress[inProgressId] = false;\n      this._sentCount--;\n\n      if (this.endData || this._sentCount === 0 && !this._isSelfResponding) {\n        this.end();\n      }\n    }\n  }\n\n}\n\nclass BootstrapTransaction extends CrossOriginTransaction {\n  constructor() {\n    super(...arguments);\n    this.type = CrossOriginTransactionTypes.Bootstrap;\n  }\n\n  static shouldForward() {\n    return false;\n  }\n\n  static async makeResponse(tabster) {\n    return {\n      isNavigatingWithKeyboard: tabster.keyboardNavigation.isNavigatingWithKeyboard()\n    };\n  }\n\n}\n\nclass FocusElementTransaction extends CrossOriginTransaction {\n  constructor() {\n    super(...arguments);\n    this.type = CrossOriginTransactionTypes.FocusElement;\n  }\n\n  static shouldSelfRespond() {\n    return true;\n  }\n\n  static shouldForward(tabster, data, getOwner) {\n    const el = GetElementTransaction.findElement(tabster, getOwner, data.beginData);\n    return !el || !tabster.focusable.isFocusable(el);\n  }\n\n  static async makeResponse(tabster, data, getOwner, ownerId, transactions, forwardResult) {\n    const el = GetElementTransaction.findElement(tabster, getOwner, data.beginData);\n    return !!el && tabster.focusedElement.focus(el, true) || !!(await forwardResult);\n  }\n\n}\n\nconst CrossOriginStates = {\n  Focused: 1,\n  Blurred: 2,\n  Observed: 3,\n  DeadWindow: 4,\n  KeyboardNavigation: 5,\n  Outline: 6\n};\n\nclass StateTransaction extends CrossOriginTransaction {\n  constructor() {\n    super(...arguments);\n    this.type = CrossOriginTransactionTypes.State;\n  }\n\n  static shouldSelfRespond(tabster, data) {\n    return data.state !== CrossOriginStates.DeadWindow && data.state !== CrossOriginStates.KeyboardNavigation;\n  }\n\n  static async makeResponse(tabster, data, getOwner, ownerId, transactions, forwardResult, isSelfResponse) {\n    const timestamp = data.timestamp;\n    const beginData = data.beginData;\n\n    if (timestamp && beginData) {\n      switch (beginData.state) {\n        case CrossOriginStates.Focused:\n          return StateTransaction._makeFocusedResponse(tabster, timestamp, beginData, transactions, isSelfResponse);\n\n        case CrossOriginStates.Blurred:\n          return StateTransaction._makeBlurredResponse(tabster, timestamp, beginData, transactions.ctx);\n\n        case CrossOriginStates.Observed:\n          return StateTransaction._makeObservedResponse(tabster, beginData);\n\n        case CrossOriginStates.DeadWindow:\n          return StateTransaction._makeDeadWindowResponse(tabster, beginData, transactions, forwardResult);\n\n        case CrossOriginStates.KeyboardNavigation:\n          return StateTransaction._makeKeyboardNavigationResponse(tabster, transactions.ctx, beginData.isNavigatingWithKeyboard);\n\n        case CrossOriginStates.Outline:\n          return StateTransaction._makeOutlineResponse(tabster, transactions.ctx, beginData.outline);\n      }\n    }\n\n    return true;\n  }\n\n  static createElement(tabster, beginData) {\n    return beginData.uid ? new CrossOriginElement(tabster, beginData.uid, beginData.ownerUId, beginData.id, beginData.rootUId, beginData.observedName, beginData.observedDetails) : null;\n  }\n\n  static async _makeFocusedResponse(tabster, timestamp, beginData, transactions, isSelfResponse) {\n    const element = StateTransaction.createElement(tabster, beginData);\n\n    if (beginData && beginData.ownerUId && element) {\n      transactions.ctx.focusOwner = beginData.ownerUId;\n      transactions.ctx.focusOwnerTimestamp = timestamp;\n\n      if (!isSelfResponse && beginData.rootUId && beginData.deloserUId) {\n        const deloserAPI = tabster.deloser;\n\n        if (deloserAPI) {\n          const history = DeloserAPI.getHistory(deloserAPI);\n          const deloser = {\n            ownerUId: beginData.ownerUId,\n            deloserUId: beginData.deloserUId,\n            rootUId: beginData.rootUId\n          };\n          const historyItem = history.make(beginData.rootUId, () => new CrossOriginDeloserHistoryByRoot(tabster, deloser.rootUId, transactions));\n          historyItem.unshift(deloser);\n        }\n      }\n\n      CrossOriginFocusedElementState.setVal( // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      tabster.crossOrigin.focusedElement, element, {\n        isFocusedProgrammatically: beginData.isFocusedProgrammatically\n      });\n    }\n\n    return true;\n  }\n\n  static async _makeBlurredResponse(tabster, timestamp, beginData, context) {\n    if (beginData && (beginData.ownerUId === context.focusOwner || beginData.force) && (!context.focusOwnerTimestamp || context.focusOwnerTimestamp < timestamp)) {\n      CrossOriginFocusedElementState.setVal( // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      tabster.crossOrigin.focusedElement, undefined, {});\n    }\n\n    return true;\n  }\n\n  static async _makeObservedResponse(tabster, beginData) {\n    const name = beginData.observedName;\n    const element = StateTransaction.createElement(tabster, beginData);\n\n    if (name && element) {\n      CrossOriginObservedElementState.trigger( // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      tabster.crossOrigin.observedElement, element, {\n        names: [name],\n        details: beginData.observedDetails\n      });\n    }\n\n    return true;\n  }\n\n  static async _makeDeadWindowResponse(tabster, beginData, transactions, forwardResult) {\n    const deadUId = beginData && beginData.ownerUId;\n\n    if (deadUId) {\n      transactions.removeTarget(deadUId);\n    }\n\n    return forwardResult.then(() => {\n      if (deadUId === transactions.ctx.focusOwner) {\n        const deloserAPI = tabster.deloser;\n\n        if (deloserAPI) {\n          DeloserAPI.forceRestoreFocus(deloserAPI);\n        }\n      }\n\n      return true;\n    });\n  }\n\n  static async _makeKeyboardNavigationResponse(tabster, context, isNavigatingWithKeyboard) {\n    if (isNavigatingWithKeyboard !== undefined && tabster.keyboardNavigation.isNavigatingWithKeyboard() !== isNavigatingWithKeyboard) {\n      context.ignoreKeyboardNavigationStateUpdate = true;\n      tabster.keyboardNavigation.setNavigatingWithKeyboard(isNavigatingWithKeyboard);\n      context.ignoreKeyboardNavigationStateUpdate = false;\n    }\n\n    return true;\n  }\n\n  static async _makeOutlineResponse(tabster, context, props) {\n    if (context.origOutlineSetup) {\n      context.origOutlineSetup.call( // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      tabster.outline, props);\n    }\n\n    return true;\n  }\n\n}\n\nclass GetElementTransaction extends CrossOriginTransaction {\n  constructor() {\n    super(...arguments);\n    this.type = CrossOriginTransactionTypes.GetElement;\n  }\n\n  static shouldSelfRespond() {\n    return true;\n  }\n\n  static findElement(tabster, getOwner, data) {\n    let element;\n\n    if (data && (!data.ownerId || data.ownerId === getWindowUId(getOwner()))) {\n      if (data.id) {\n        element = getOwner().document.getElementById(data.id);\n\n        if (element && data.rootId) {\n          const ctx = RootAPI.getTabsterContext(tabster, element);\n\n          if (!ctx || ctx.root.uid !== data.rootId) {\n            return null;\n          }\n        }\n      } else if (data.uid) {\n        const ref = getInstanceContext(getOwner).elementByUId[data.uid];\n        element = ref && ref.get();\n      } else if (data.observedName) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        element = tabster.observedElement.getElement(data.observedName, data.accessibility);\n      }\n    }\n\n    return element || null;\n  }\n\n  static getElementData(tabster, element, getOwner, context, ownerUId) {\n    const deloser = DeloserAPI.getDeloser(tabster, element);\n    const ctx = RootAPI.getTabsterContext(tabster, element);\n    const tabsterOnElement = getTabsterOnElement(tabster, element);\n    const observed = tabsterOnElement && tabsterOnElement.observed;\n    return {\n      uid: getElementUId(getOwner, element),\n      ownerUId,\n      id: element.id || undefined,\n      rootUId: ctx ? ctx.root.uid : undefined,\n      deloserUId: deloser ? getDeloserUID(getOwner, context, deloser) : undefined,\n      observedName: observed && observed.names && observed.names[0],\n      observedDetails: observed && observed.details\n    };\n  }\n\n  static async makeResponse(tabster, data, getOwner, ownerUId, transactions, forwardResult) {\n    const beginData = data.beginData;\n    let element;\n    let dataOut;\n\n    if (beginData === undefined) {\n      element = tabster.focusedElement.getFocusedElement();\n    } else if (beginData) {\n      element = GetElementTransaction.findElement(tabster, getOwner, beginData) || undefined;\n    }\n\n    if (!element && beginData) {\n      const name = beginData.observedName;\n      const timeout = data.timeout;\n      const accessibility = beginData.accessibility;\n\n      if (name && timeout) {\n        const e = await new (getPromise(getOwner))(resolve => {\n          let isWaitElementResolved = false;\n          let isForwardResolved = false;\n          let isResolved = false; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n          tabster.observedElement.waitElement(name, timeout, accessibility).result.then(value => {\n            isWaitElementResolved = true;\n\n            if (!isResolved && (value || isForwardResolved)) {\n              isResolved = true;\n              resolve({\n                element: value\n              });\n            }\n          });\n          forwardResult.then(value => {\n            isForwardResolved = true;\n\n            if (!isResolved && (value || isWaitElementResolved)) {\n              isResolved = true;\n              resolve({\n                crossOrigin: value\n              });\n            }\n          });\n        });\n\n        if (e.element) {\n          element = e.element;\n        } else if (e.crossOrigin) {\n          dataOut = e.crossOrigin;\n        }\n      }\n    }\n\n    return element ? GetElementTransaction.getElementData(tabster, element, getOwner, transactions.ctx, ownerUId) : dataOut;\n  }\n\n}\n\nclass RestoreFocusInDeloserTransaction extends CrossOriginTransaction {\n  constructor() {\n    super(...arguments);\n    this.type = CrossOriginTransactionTypes.RestoreFocusInDeloser;\n  }\n\n  static async makeResponse(tabster, data, getOwner, ownerId, transactions, forwardResult) {\n    const forwardRet = await forwardResult;\n    const begin = !forwardRet && data.beginData;\n    const uid = begin && begin.deloserUId;\n    const deloser = uid && transactions.ctx.deloserByUId[uid];\n    const deloserAPI = tabster.deloser;\n\n    if (begin && deloser && deloserAPI) {\n      const history = DeloserAPI.getHistory(deloserAPI);\n      return begin.reset ? history.resetFocus(deloser) : history.focusAvailable(deloser);\n    }\n\n    return !!forwardRet;\n  }\n\n}\n\nclass PingTransaction extends CrossOriginTransaction {\n  constructor() {\n    super(...arguments);\n    this.type = CrossOriginTransactionTypes.Ping;\n  }\n\n  static shouldForward() {\n    return false;\n  }\n\n  static async makeResponse() {\n    return true;\n  }\n\n}\n\nclass CrossOriginTransactions {\n  constructor(tabster, getOwner, context) {\n    this._knownTargets = {};\n    this._transactions = {};\n    this._isDefaultSendUp = false;\n    this.isSetUp = false;\n\n    this._onMessage = e => {\n      if (e.data.owner === this._ownerUId || !this._tabster) {\n        return;\n      } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n      const data = e.data;\n      let transactionId;\n\n      if (!data || !(transactionId = data.transaction) || !data.type || !data.timestamp || !data.owner || !data.sentto) {\n        return;\n      }\n\n      let knownTarget = this._knownTargets[data.owner];\n\n      if (!knownTarget && e.send && data.owner !== this._ownerUId) {\n        knownTarget = this._knownTargets[data.owner] = {\n          send: e.send\n        };\n      }\n\n      if (knownTarget) {\n        knownTarget.last = Date.now();\n      }\n\n      if (data.isResponse) {\n        const t = this._transactions[transactionId];\n\n        if (t && t.transaction && t.transaction.type === data.type) {\n          t.transaction.onResponse(data);\n        }\n      } else {\n        const Transaction = this._getTransactionClass(data.type);\n\n        const forwardResult = this.forwardTransaction(data);\n\n        if (Transaction && e.send) {\n          Transaction.makeResponse(this._tabster, data, this._owner, this._ownerUId, this, forwardResult, false).then(r => {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const response = {\n              transaction: data.transaction,\n              type: data.type,\n              isResponse: true,\n              timestamp: Date.now(),\n              owner: this._ownerUId,\n              timeout: data.timeout,\n              sentto: {},\n              target: data.target === _targetIdUp ? _targetIdUp : data.owner,\n              endData: r\n            };\n            e.send(response);\n          });\n        }\n      }\n    };\n\n    this._onPageHide = () => {\n      this._dead();\n    };\n\n    this._onBrowserMessage = e => {\n      if (e.source === this._owner()) {\n        return;\n      } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n      const send = data => {\n        if (e.source && e.source.postMessage) {\n          // eslint-disable-next-line @typescript-eslint/ban-types\n          e.source.postMessage(JSON.stringify(data), \"*\");\n        }\n      };\n\n      try {\n        this._onMessage({\n          data: JSON.parse(e.data),\n          send\n        });\n      } catch (e) {\n        /* Ignore */\n      }\n    };\n\n    this._tabster = tabster;\n    this._owner = getOwner;\n    this._ownerUId = getWindowUId(getOwner());\n    this.ctx = context;\n  }\n\n  setup(sendUp) {\n    if (this.isSetUp) {\n      if (process.env.NODE_ENV === 'development') {\n        console.error(\"CrossOrigin is already set up.\");\n      }\n    } else {\n      this.isSetUp = true;\n      this.setSendUp(sendUp);\n\n      this._owner().addEventListener(\"pagehide\", this._onPageHide);\n\n      this._ping();\n    }\n\n    return this._onMessage;\n  }\n\n  setSendUp(sendUp) {\n    if (!this.isSetUp) {\n      throw new Error(\"CrossOrigin is not set up.\");\n    }\n\n    this.sendUp = sendUp || undefined;\n\n    const owner = this._owner();\n\n    if (sendUp === undefined) {\n      if (!this._isDefaultSendUp) {\n        if (owner.document) {\n          this._isDefaultSendUp = true;\n\n          if (owner.parent && owner.parent !== owner && owner.parent.postMessage) {\n            this.sendUp = ( // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            data) => {\n              owner.parent.postMessage(JSON.stringify(data), \"*\");\n            };\n          }\n\n          owner.addEventListener(\"message\", this._onBrowserMessage);\n        }\n      }\n    } else if (this._isDefaultSendUp) {\n      owner.removeEventListener(\"message\", this._onBrowserMessage);\n      this._isDefaultSendUp = false;\n    }\n\n    return this._onMessage;\n  }\n\n  async dispose() {\n    const owner = this._owner();\n\n    if (this._pingTimer) {\n      owner.clearTimeout(this._pingTimer);\n      this._pingTimer = undefined;\n    }\n\n    owner.removeEventListener(\"message\", this._onBrowserMessage);\n    owner.removeEventListener(\"pagehide\", this._onPageHide);\n    await this._dead();\n    delete this._deadPromise;\n\n    for (const id of Object.keys(this._transactions)) {\n      const t = this._transactions[id];\n\n      if (t.timer) {\n        owner.clearTimeout(t.timer);\n        delete t.timer;\n      }\n\n      t.transaction.end();\n    }\n\n    this._knownTargets = {};\n    delete this.sendUp;\n  }\n\n  beginTransaction(Transaction, value, timeout, sentTo, targetId, withReject) {\n    if (!this._owner) {\n      return getPromise(this._owner).reject();\n    }\n\n    const transaction = new Transaction(this._tabster, this._owner, this._knownTargets, value, timeout, sentTo, targetId, this.sendUp);\n    let selfResponse;\n\n    if (Transaction.shouldSelfRespond && Transaction.shouldSelfRespond(this._tabster, value, this._owner, this._ownerUId)) {\n      selfResponse = data => {\n        return Transaction.makeResponse(this._tabster, data, this._owner, this._ownerUId, this, getPromise(this._owner).resolve(undefined), true);\n      };\n    }\n\n    return this._beginTransaction(transaction, timeout, selfResponse, withReject);\n  }\n\n  removeTarget(uid) {\n    delete this._knownTargets[uid];\n  }\n\n  _beginTransaction(transaction, timeout, selfResponse, withReject) {\n    const owner = this._owner();\n\n    const wrapper = {\n      transaction,\n      timer: owner.setTimeout(() => {\n        delete wrapper.timer;\n        transaction.end(\"Cross origin transaction timed out.\");\n      }, _transactionTimeout + (timeout || 0))\n    };\n    this._transactions[transaction.id] = wrapper;\n    const ret = transaction.begin(selfResponse);\n    ret.catch(() => {\n      /**/\n    }).finally(() => {\n      if (wrapper.timer) {\n        owner.clearTimeout(wrapper.timer);\n      }\n\n      delete this._transactions[transaction.id];\n    });\n    return ret.then(value => value, withReject ? undefined : () => undefined);\n  }\n\n  forwardTransaction( // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  data // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ) {\n    const owner = this._owner;\n    let targetId = data.target;\n\n    if (targetId === this._ownerUId) {\n      return getPromise(owner).resolve();\n    }\n\n    const Transaction = this._getTransactionClass(data.type);\n\n    if (Transaction) {\n      if (Transaction.shouldForward === undefined || Transaction.shouldForward(this._tabster, data, owner, this._ownerUId)) {\n        const sentTo = data.sentto;\n\n        if (targetId === _targetIdUp) {\n          targetId = undefined;\n          sentTo[this._ownerUId] = true;\n        }\n\n        delete sentTo[_targetIdUp];\n        return this._beginTransaction(new Transaction(this._tabster, owner, this._knownTargets, data.beginData, data.timeout, sentTo, targetId, this.sendUp), data.timeout);\n      } else {\n        return getPromise(owner).resolve();\n      }\n    }\n\n    return getPromise(owner).reject(`Unknown transaction type ${data.type}`);\n  }\n\n  _getTransactionClass(type // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ) {\n    switch (type) {\n      case CrossOriginTransactionTypes.Bootstrap:\n        return BootstrapTransaction;\n\n      case CrossOriginTransactionTypes.FocusElement:\n        return FocusElementTransaction;\n\n      case CrossOriginTransactionTypes.State:\n        return StateTransaction;\n\n      case CrossOriginTransactionTypes.GetElement:\n        return GetElementTransaction;\n\n      case CrossOriginTransactionTypes.RestoreFocusInDeloser:\n        return RestoreFocusInDeloserTransaction;\n\n      case CrossOriginTransactionTypes.Ping:\n        return PingTransaction;\n\n      default:\n        return null;\n    }\n  }\n\n  async _dead() {\n    if (!this._deadPromise && this.ctx.focusOwner === this._ownerUId) {\n      this._deadPromise = this.beginTransaction(StateTransaction, {\n        ownerUId: this._ownerUId,\n        state: CrossOriginStates.DeadWindow\n      });\n    }\n\n    if (this._deadPromise) {\n      await this._deadPromise;\n    }\n  }\n\n  async _ping() {\n    if (this._pingTimer) {\n      return;\n    }\n\n    let deadWindows;\n    const now = Date.now();\n    const targets = Object.keys(this._knownTargets).filter(uid => now - (this._knownTargets[uid].last || 0) > _pingTimeout);\n\n    if (this.sendUp) {\n      targets.push(_targetIdUp);\n    }\n\n    if (targets.length) {\n      await getPromise(this._owner).all(targets.map(uid => this.beginTransaction(PingTransaction, undefined, undefined, undefined, uid, true).then(() => true, () => {\n        if (uid !== _targetIdUp) {\n          if (!deadWindows) {\n            deadWindows = {};\n          }\n\n          deadWindows[uid] = true;\n          delete this._knownTargets[uid];\n        }\n\n        return false;\n      })));\n    }\n\n    if (deadWindows) {\n      const focused = await this.beginTransaction(GetElementTransaction, undefined);\n\n      if (!focused && this.ctx.focusOwner && this.ctx.focusOwner in deadWindows) {\n        await this.beginTransaction(StateTransaction, {\n          ownerUId: this._ownerUId,\n          state: CrossOriginStates.Blurred,\n          force: true\n        });\n        const deloserAPI = this._tabster.deloser;\n\n        if (deloserAPI) {\n          DeloserAPI.forceRestoreFocus(deloserAPI);\n        }\n      }\n    }\n\n    this._pingTimer = this._owner().setTimeout(() => {\n      this._pingTimer = undefined;\n\n      this._ping();\n    }, _pingTimeout);\n  }\n\n}\n\nclass CrossOriginElement {\n  constructor(tabster, uid, ownerId, id, rootId, observedName, observedDetails) {\n    this._tabster = tabster;\n    this.uid = uid;\n    this.ownerId = ownerId;\n    this.id = id;\n    this.rootId = rootId;\n    this.observedName = observedName;\n    this.observedDetails = observedDetails;\n  }\n\n  focus(noFocusedProgrammaticallyFlag, noAccessibleCheck) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this._tabster.crossOrigin.focusedElement.focus(this, noFocusedProgrammaticallyFlag, noAccessibleCheck);\n  }\n\n}\nclass CrossOriginFocusedElementState extends Subscribable {\n  constructor(transactions) {\n    super();\n    this._transactions = transactions;\n  }\n\n  async focus(element, noFocusedProgrammaticallyFlag, noAccessibleCheck) {\n    return this._focus({\n      uid: element.uid,\n      id: element.id,\n      rootId: element.rootId,\n      ownerId: element.ownerId,\n      observedName: element.observedName\n    }, noFocusedProgrammaticallyFlag, noAccessibleCheck);\n  }\n\n  async focusById(elementId, rootId, noFocusedProgrammaticallyFlag, noAccessibleCheck) {\n    return this._focus({\n      id: elementId,\n      rootId\n    }, noFocusedProgrammaticallyFlag, noAccessibleCheck);\n  }\n\n  async focusByObservedName(observedName, timeout, rootId, noFocusedProgrammaticallyFlag, noAccessibleCheck) {\n    return this._focus({\n      observedName,\n      rootId\n    }, noFocusedProgrammaticallyFlag, noAccessibleCheck, timeout);\n  }\n\n  async _focus(elementData, noFocusedProgrammaticallyFlag, noAccessibleCheck, timeout) {\n    return this._transactions.beginTransaction(FocusElementTransaction, { ...elementData,\n      noFocusedProgrammaticallyFlag,\n      noAccessibleCheck\n    }, timeout).then(value => !!value);\n  }\n\n  static setVal(instance, val, details) {\n    instance.setVal(val, details);\n  }\n\n}\nclass CrossOriginObservedElementState extends Subscribable {\n  constructor(tabster, transactions) {\n    super();\n    this._lastRequestFocusId = 0;\n    this._tabster = tabster;\n    this._transactions = transactions;\n  }\n\n  async getElement(observedName, accessibility) {\n    return this.waitElement(observedName, 0, accessibility);\n  }\n\n  async waitElement(observedName, timeout, accessibility) {\n    return this._transactions.beginTransaction(GetElementTransaction, {\n      observedName,\n      accessibility\n    }, timeout).then(value => value ? StateTransaction.createElement(this._tabster, value) : null);\n  }\n\n  async requestFocus(observedName, timeout) {\n    const requestId = ++this._lastRequestFocusId;\n    return this.waitElement(observedName, timeout, ObservedElementAccesibilities.Focusable).then(element => this._lastRequestFocusId === requestId && element ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this._tabster.crossOrigin.focusedElement.focus(element, true) : false);\n  }\n\n  static trigger(instance, element, details) {\n    instance.trigger(element, details);\n  }\n\n}\nclass CrossOriginAPI {\n  constructor(tabster) {\n    this._init = () => {\n      const tabster = this._tabster;\n      tabster.keyboardNavigation.subscribe(this._onKeyboardNavigationStateChanged);\n      tabster.focusedElement.subscribe(this._onFocus); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n      tabster.observedElement.subscribe(this._onObserved);\n\n      if (!this._ctx.origOutlineSetup) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this._ctx.origOutlineSetup = tabster.outline.setup; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n        tabster.outline.setup = this._outlineSetup;\n      }\n\n      this._transactions.beginTransaction(BootstrapTransaction, undefined, undefined, undefined, _targetIdUp).then(data => {\n        if (data && this._tabster.keyboardNavigation.isNavigatingWithKeyboard() !== data.isNavigatingWithKeyboard) {\n          this._ctx.ignoreKeyboardNavigationStateUpdate = true;\n\n          this._tabster.keyboardNavigation.setNavigatingWithKeyboard(data.isNavigatingWithKeyboard);\n\n          this._ctx.ignoreKeyboardNavigationStateUpdate = false;\n        }\n      });\n    };\n\n    this._onKeyboardNavigationStateChanged = value => {\n      if (!this._ctx.ignoreKeyboardNavigationStateUpdate) {\n        this._transactions.beginTransaction(StateTransaction, {\n          state: CrossOriginStates.KeyboardNavigation,\n          ownerUId: getWindowUId(this._win()),\n          isNavigatingWithKeyboard: value\n        });\n      }\n    };\n\n    this._onFocus = element => {\n      const win = this._win();\n\n      const ownerUId = getWindowUId(win);\n\n      if (this._blurTimer) {\n        win.clearTimeout(this._blurTimer);\n        this._blurTimer = undefined;\n      }\n\n      if (element) {\n        this._transactions.beginTransaction(StateTransaction, { ...GetElementTransaction.getElementData(this._tabster, element, this._win, this._ctx, ownerUId),\n          state: CrossOriginStates.Focused\n        });\n      } else {\n        this._blurTimer = win.setTimeout(() => {\n          this._blurTimer = undefined;\n\n          if (this._ctx.focusOwner && this._ctx.focusOwner === ownerUId) {\n            this._transactions.beginTransaction(GetElementTransaction, undefined).then(value => {\n              if (!value && this._ctx.focusOwner === ownerUId) {\n                this._transactions.beginTransaction(StateTransaction, {\n                  ownerUId,\n                  state: CrossOriginStates.Blurred,\n                  force: false\n                });\n              }\n            });\n          }\n        }, 0);\n      }\n    };\n\n    this._onObserved = (element, details) => {\n      var _a;\n\n      const d = GetElementTransaction.getElementData(this._tabster, element, this._win, this._ctx, getWindowUId(this._win()));\n      d.state = CrossOriginStates.Observed;\n      d.observedName = (_a = details.names) === null || _a === void 0 ? void 0 : _a[0];\n      d.observedDetails = details.details;\n\n      this._transactions.beginTransaction(StateTransaction, d);\n    };\n\n    this._outlineSetup = props => {\n      this._transactions.beginTransaction(StateTransaction, {\n        state: CrossOriginStates.Outline,\n        ownerUId: getWindowUId(this._win()),\n        outline: props\n      });\n    };\n\n    this._tabster = tabster;\n    this._win = tabster.getWindow;\n    this._ctx = {\n      ignoreKeyboardNavigationStateUpdate: false,\n      deloserByUId: {}\n    };\n    this._transactions = new CrossOriginTransactions(tabster, this._win, this._ctx);\n    this.focusedElement = new CrossOriginFocusedElementState(this._transactions);\n    this.observedElement = new CrossOriginObservedElementState(tabster, this._transactions);\n  }\n\n  setup(sendUp) {\n    if (this.isSetUp()) {\n      return this._transactions.setSendUp(sendUp);\n    } else {\n      this._tabster.queueInit(this._init);\n\n      return this._transactions.setup(sendUp);\n    }\n  }\n\n  isSetUp() {\n    return this._transactions.isSetUp;\n  }\n\n  dispose() {\n    var _a;\n\n    const tabster = this._tabster;\n    tabster.keyboardNavigation.unsubscribe(this._onKeyboardNavigationStateChanged);\n    tabster.focusedElement.unsubscribe(this._onFocus);\n    (_a = tabster.observedElement) === null || _a === void 0 ? void 0 : _a.unsubscribe(this._onObserved);\n\n    this._transactions.dispose();\n\n    this.focusedElement.dispose();\n    this.observedElement.dispose();\n    this._ctx.deloserByUId = {};\n  }\n\n}\n\nfunction getDeloserUID(getWindow, context, deloser) {\n  const deloserElement = deloser.getElement();\n\n  if (deloserElement) {\n    const uid = getElementUId(getWindow, deloserElement);\n\n    if (!context.deloserByUId[uid]) {\n      context.deloserByUId[uid] = deloser;\n    }\n\n    return uid;\n  }\n\n  return undefined;\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nconst _focusableSelector = /*#__PURE__*/[\"a[href]\", \"button:not([disabled])\", \"input:not([disabled])\", \"select:not([disabled])\", \"textarea:not([disabled])\", \"*[tabindex]\", \"*[contenteditable]\"].join(\", \");\n\nclass FocusableAPI {\n  constructor(tabster) {\n    this._tabster = tabster;\n  }\n\n  dispose() {\n    /**/\n  }\n\n  getProps(element) {\n    const tabsterOnElement = getTabsterOnElement(this._tabster, element);\n    return tabsterOnElement && tabsterOnElement.focusable || {};\n  }\n\n  isFocusable(el, includeProgrammaticallyFocusable, noVisibleCheck, noAccessibleCheck) {\n    if (matchesSelector(el, _focusableSelector) && (includeProgrammaticallyFocusable || el.tabIndex !== -1)) {\n      return (noVisibleCheck || this.isVisible(el)) && (noAccessibleCheck || this.isAccessible(el));\n    }\n\n    return false;\n  }\n\n  isVisible(el) {\n    if (!el.ownerDocument || el.nodeType !== Node.ELEMENT_NODE) {\n      return false;\n    }\n\n    if (el.offsetParent === null && el.ownerDocument.body !== el) {\n      return false;\n    }\n\n    const win = el.ownerDocument.defaultView;\n\n    if (!win) {\n      return false;\n    }\n\n    const rect = el.ownerDocument.body.getBoundingClientRect();\n\n    if (rect.width === 0 && rect.height === 0) {\n      // This might happen, for example, if our <body> is in hidden <iframe>.\n      return false;\n    }\n\n    const computedStyle = win.getComputedStyle(el);\n\n    if (computedStyle.visibility === \"hidden\") {\n      return false;\n    }\n\n    return true;\n  }\n\n  isAccessible(el) {\n    var _a;\n\n    for (let e = el; e; e = e.parentElement) {\n      const tabsterOnElement = getTabsterOnElement(this._tabster, e);\n\n      if (this._isHidden(e)) {\n        return false;\n      }\n\n      const ignoreDisabled = (_a = tabsterOnElement === null || tabsterOnElement === void 0 ? void 0 : tabsterOnElement.focusable) === null || _a === void 0 ? void 0 : _a.ignoreAriaDisabled;\n\n      if (!ignoreDisabled && this._isDisabled(e)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  _isDisabled(el) {\n    return el.hasAttribute(\"disabled\");\n  }\n\n  _isHidden(el) {\n    var _a;\n\n    const attrVal = el.getAttribute(\"aria-hidden\");\n\n    if (attrVal && attrVal.toLowerCase() === \"true\") {\n      if (!((_a = this._tabster.modalizer) === null || _a === void 0 ? void 0 : _a.isAugmented(el))) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  findFirst(options) {\n    return this.findElement({ ...options\n    });\n  }\n\n  findLast(options) {\n    return this.findElement({\n      isBackward: true,\n      ...options\n    });\n  }\n\n  findNext(options, out) {\n    return this.findElement({ ...options\n    }, out);\n  }\n\n  findPrev(options, out) {\n    return this.findElement({ ...options,\n      isBackward: true\n    }, out);\n  }\n\n  findDefault(options) {\n    return this.findElement({ ...options,\n      acceptCondition: el => this._tabster.focusable.isFocusable(el, options.includeProgrammaticallyFocusable) && !!this.getProps(el).isDefault\n    }) || null;\n  }\n\n  findAll(options) {\n    return this._findElements(true, options) || [];\n  }\n\n  findElement(options, out) {\n    const found = this._findElements(false, options, out);\n\n    return found ? found[0] : found;\n  }\n\n  _findElements(findAll, options, out) {\n    var _a, _b, _c;\n\n    const {\n      container,\n      currentElement = null,\n      includeProgrammaticallyFocusable,\n      useActiveModalizer,\n      ignoreUncontrolled,\n      ignoreAccessibility,\n      modalizerId,\n      isBackward,\n      onUncontrolled,\n      onElement\n    } = options;\n\n    if (!out) {\n      out = {};\n    }\n\n    const elements = [];\n    let {\n      acceptCondition\n    } = options;\n\n    if (!container) {\n      return null;\n    }\n\n    if (!acceptCondition) {\n      acceptCondition = el => this._tabster.focusable.isFocusable(el, includeProgrammaticallyFocusable, false, ignoreAccessibility);\n    }\n\n    const acceptElementState = {\n      container,\n      modalizerUserId: modalizerId === undefined && useActiveModalizer ? (_a = this._tabster.modalizer) === null || _a === void 0 ? void 0 : _a.activeId : modalizerId || ((_c = (_b = RootAPI.getTabsterContext(this._tabster, container)) === null || _b === void 0 ? void 0 : _b.modalizer) === null || _c === void 0 ? void 0 : _c.userId),\n      from: currentElement || container,\n      isBackward,\n      acceptCondition,\n      includeProgrammaticallyFocusable,\n      ignoreUncontrolled,\n      ignoreAccessibility,\n      cachedGrouppers: {}\n    };\n    const walker = createElementTreeWalker(container.ownerDocument, container, node => this._acceptElement(node, acceptElementState));\n\n    if (!walker) {\n      return null;\n    }\n\n    const prepareForNextElement = shouldContinueIfNotFound => {\n      const foundElement = acceptElementState.foundElement;\n\n      if (foundElement) {\n        elements.push(foundElement);\n      }\n\n      if (findAll) {\n        if (foundElement) {\n          acceptElementState.found = false;\n          delete acceptElementState.foundElement;\n          delete acceptElementState.fromCtx;\n          acceptElementState.from = foundElement;\n\n          if (onElement && !onElement(foundElement)) {\n            return false;\n          }\n        }\n\n        return !!(foundElement || shouldContinueIfNotFound);\n      } else {\n        return !!(shouldContinueIfNotFound && !foundElement);\n      }\n    };\n\n    if (!currentElement) {\n      out.outOfDOMOrder = true;\n    }\n\n    if (currentElement) {\n      walker.currentNode = currentElement;\n    } else if (isBackward) {\n      const lastChild = getLastChild(container);\n\n      if (!lastChild) {\n        return null;\n      }\n\n      if (this._acceptElement(lastChild, acceptElementState) === NodeFilter.FILTER_ACCEPT && !prepareForNextElement(true)) {\n        if (acceptElementState.skippedFocusable) {\n          out.outOfDOMOrder = true;\n        }\n\n        return elements;\n      }\n\n      walker.currentNode = lastChild;\n    }\n\n    let foundElement;\n\n    do {\n      foundElement = (isBackward ? walker.previousNode() : walker.nextNode()) || undefined;\n    } while (prepareForNextElement());\n\n    if (!findAll) {\n      const nextUncontrolled = acceptElementState.nextUncontrolled;\n\n      if (nextUncontrolled) {\n        if (onUncontrolled) {\n          onUncontrolled(nextUncontrolled);\n        }\n\n        if (foundElement) {\n          // We have an uncontrolled area and there is a controlled element after it.\n          // Return undefined for the default Tab action.\n          return undefined;\n        } else {\n          // Otherwise, return null to moveOutWithDefaultAction().\n          return null;\n        }\n      }\n    }\n\n    if (acceptElementState.skippedFocusable) {\n      out.outOfDOMOrder = true;\n    }\n\n    return elements.length ? elements : null;\n  }\n\n  _acceptElement(element, state) {\n    var _a, _b, _c, _d, _e;\n\n    if (state.found) {\n      return NodeFilter.FILTER_ACCEPT;\n    }\n\n    const container = state.container;\n\n    if (element === container) {\n      return NodeFilter.FILTER_SKIP;\n    }\n\n    if (!container.contains(element)) {\n      return NodeFilter.FILTER_REJECT;\n    }\n\n    if (element.__tabsterDummyContainer) {\n      return NodeFilter.FILTER_REJECT;\n    }\n\n    let lastToIgnore = state.lastToIgnore;\n\n    if (lastToIgnore) {\n      if (lastToIgnore.contains(element)) {\n        return NodeFilter.FILTER_REJECT;\n      } else {\n        lastToIgnore = state.lastToIgnore = undefined;\n      }\n    }\n\n    const ctx = state.currentCtx = RootAPI.getTabsterContext(this._tabster, element); // Tabster is opt in, if it is not managed, don't try and get do anything special\n\n    if (!ctx) {\n      return NodeFilter.FILTER_SKIP;\n    }\n\n    if (state.ignoreUncontrolled) {\n      if (shouldIgnoreFocus(element)) {\n        return NodeFilter.FILTER_SKIP;\n      }\n    } else if (ctx.uncontrolled && !state.nextUncontrolled && this._tabster.focusable.isFocusable(element, undefined, true, true)) {\n      if (!ctx.groupper && !ctx.mover) {\n        if (((_a = ctx.modalizer) === null || _a === void 0 ? void 0 : _a.userId) === ((_b = this._tabster.modalizer) === null || _b === void 0 ? void 0 : _b.activeId)) {\n          if (this.isVisible(ctx.uncontrolled)) {\n            state.nextUncontrolled = ctx.uncontrolled;\n          }\n\n          state.skippedFocusable = true;\n          return NodeFilter.FILTER_REJECT;\n        }\n      }\n    } // We assume iframes are focusable because native tab behaviour would tab inside\n\n\n    if (element.tagName === \"IFRAME\" || element.tagName === \"WEBVIEW\") {\n      if (((_c = ctx.modalizer) === null || _c === void 0 ? void 0 : _c.userId) === ((_d = this._tabster.modalizer) === null || _d === void 0 ? void 0 : _d.activeId)) {\n        state.found = true;\n        state.lastToIgnore = state.foundElement = element;\n        return NodeFilter.FILTER_ACCEPT;\n      } else {\n        return NodeFilter.FILTER_REJECT;\n      }\n    }\n\n    if (!state.ignoreAccessibility && !this.isAccessible(element)) {\n      if (this.isFocusable(element, false, true, true)) {\n        state.skippedFocusable = true;\n      }\n\n      return NodeFilter.FILTER_REJECT;\n    }\n\n    let result;\n    let fromCtx = state.fromCtx;\n\n    if (!fromCtx) {\n      fromCtx = state.fromCtx = RootAPI.getTabsterContext(this._tabster, state.from);\n    }\n\n    const fromMover = fromCtx === null || fromCtx === void 0 ? void 0 : fromCtx.mover;\n    let groupper = ctx.groupper;\n    let mover = ctx.mover;\n    result = (_e = this._tabster.modalizer) === null || _e === void 0 ? void 0 : _e.acceptElement(element, state);\n\n    if (result !== undefined) {\n      state.skippedFocusable = true;\n    }\n\n    if (result === undefined && (groupper || mover || fromMover)) {\n      const groupperElement = groupper === null || groupper === void 0 ? void 0 : groupper.getElement();\n      const fromMoverElement = fromMover === null || fromMover === void 0 ? void 0 : fromMover.getElement();\n      let moverElement = mover === null || mover === void 0 ? void 0 : mover.getElement();\n\n      if (moverElement && (fromMoverElement === null || fromMoverElement === void 0 ? void 0 : fromMoverElement.contains(moverElement)) && container.contains(fromMoverElement) && (!groupperElement || !mover || fromMoverElement.contains(groupperElement))) {\n        mover = fromMover;\n        moverElement = fromMoverElement;\n      }\n\n      if (groupperElement && (groupperElement === container || !container.contains(groupperElement))) {\n        groupper = undefined;\n      }\n\n      if (moverElement && !container.contains(moverElement)) {\n        mover = undefined;\n      }\n\n      if (groupper && mover) {\n        if (moverElement && groupperElement && !groupperElement.contains(moverElement)) {\n          mover = undefined;\n        } else {\n          groupper = undefined;\n        }\n      }\n\n      if (groupper) {\n        result = groupper.acceptElement(element, state);\n      }\n\n      if (mover) {\n        result = mover.acceptElement(element, state);\n      }\n    }\n\n    if (result === undefined) {\n      result = state.acceptCondition(element) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n\n      if (result === NodeFilter.FILTER_SKIP && this.isFocusable(element, false, true, true)) {\n        state.skippedFocusable = true;\n      }\n    }\n\n    if (result === NodeFilter.FILTER_ACCEPT && !state.found) {\n      state.found = true;\n      state.foundElement = element;\n    }\n\n    return result;\n  }\n\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst Keys = {\n  Tab: 9,\n  Enter: 13,\n  Esc: 27,\n  Space: 32,\n  PageUp: 33,\n  PageDown: 34,\n  End: 35,\n  Home: 36,\n  Left: 37,\n  Up: 38,\n  Right: 39,\n  Down: 40\n};\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nclass FocusedElementState extends Subscribable {\n  constructor(tabster, getWindow) {\n    super();\n\n    this._init = () => {\n      const win = this._win();\n\n      const doc = win.document; // Add these event listeners as capture - we want Tabster to run before user event handlers\n\n      doc.addEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);\n      doc.addEventListener(\"focusout\", this._onFocusOut, true);\n      win.addEventListener(\"keydown\", this._onKeyDown, true);\n      const activeElement = doc.activeElement;\n\n      if (activeElement && activeElement !== doc.body) {\n        this._setFocusedElement(activeElement);\n      }\n\n      this.subscribe(this._onChanged);\n    };\n\n    this._onFocusIn = e => {\n      this._setFocusedElement(e.target, e.details.relatedTarget, e.details.isFocusedProgrammatically);\n    };\n\n    this._onFocusOut = e => {\n      this._setFocusedElement(undefined, e.relatedTarget);\n    }; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n    this._validateFocusedElement = element => {// TODO: Make sure this is not needed anymore and write tests.\n    };\n\n    this._onKeyDown = e => {\n      var _a, _b;\n\n      if (e.keyCode !== Keys.Tab || e.ctrlKey) {\n        return;\n      }\n\n      const currentElement = this.getVal();\n\n      if (!currentElement || !currentElement.ownerDocument || currentElement.contentEditable === \"true\") {\n        return;\n      }\n\n      const tabster = this._tabster;\n      const controlTab = tabster.controlTab;\n      const ctx = RootAPI.getTabsterContext(tabster, currentElement);\n\n      if (!ctx || ctx.ignoreKeydown(e)) {\n        return;\n      }\n\n      const isBackward = e.shiftKey;\n      const next = FocusedElementState.findNextTabbable(tabster, ctx, undefined, currentElement, undefined, isBackward, undefined, true);\n      let nextElement;\n\n      if (next) {\n        let uncontrolled = next.uncontrolled;\n\n        if (uncontrolled) {\n          const isGroupperFirst = ctx.isGroupperFirst;\n          let moveOutside = false;\n\n          if (isGroupperFirst !== undefined) {\n            const groupper = (_a = ctx.groupper) === null || _a === void 0 ? void 0 : _a.getElement();\n            const mover = (_b = ctx.mover) === null || _b === void 0 ? void 0 : _b.getElement();\n            let moveFrom;\n\n            if (isGroupperFirst && groupper && uncontrolled.contains(groupper)) {\n              moveFrom = groupper;\n            } else if (!isGroupperFirst && mover && uncontrolled.contains(mover)) {\n              moveFrom = mover;\n            }\n\n            if (moveFrom) {\n              uncontrolled = moveFrom;\n              moveOutside = true;\n            }\n          }\n\n          if (uncontrolled && ctx.uncontrolled !== uncontrolled) {\n            // We have met an uncontrolled area, just allow default action.\n            DummyInputManager.moveWithPhantomDummy(this._tabster, uncontrolled, moveOutside, isBackward);\n          }\n\n          return;\n        }\n\n        nextElement = next.element;\n      }\n\n      if (nextElement) {\n        if (nextElement.tagName === \"IFRAME\") {\n          // For iframes we always want to use default action to move focus into\n          // an iframe, because there is no ability to move focus inside that iframe\n          // programmatically (assuming no cross origin access).\n          DummyInputManager.moveWithPhantomDummy(this._tabster, nextElement, false, isBackward);\n          return;\n        }\n\n        if (controlTab || (next === null || next === void 0 ? void 0 : next.outOfDOMOrder)) {\n          e.preventDefault();\n          e.stopImmediatePropagation();\n          nativeFocus(nextElement);\n        }\n      } else {\n        ctx.root.moveOutWithDefaultAction(isBackward);\n      }\n    };\n\n    this._onChanged = (element, details) => {\n      var _a, _b;\n\n      if (element) {\n        triggerEvent(element, FocusInEventName, details);\n      } else {\n        const last = (_a = this._lastVal) === null || _a === void 0 ? void 0 : _a.get();\n\n        if (last) {\n          const d = { ...details\n          };\n          const lastCtx = RootAPI.getTabsterContext(this._tabster, last);\n          const modalizerId = (_b = lastCtx === null || lastCtx === void 0 ? void 0 : lastCtx.modalizer) === null || _b === void 0 ? void 0 : _b.userId;\n\n          if (modalizerId) {\n            d.modalizerId = modalizerId;\n          }\n\n          triggerEvent(last, FocusOutEventName, d);\n        }\n      }\n    };\n\n    this._tabster = tabster;\n    this._win = getWindow;\n    tabster.queueInit(this._init);\n  }\n\n  dispose() {\n    super.dispose();\n\n    const win = this._win();\n\n    win.document.removeEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);\n    win.document.removeEventListener(\"focusout\", this._onFocusOut, true);\n    win.removeEventListener(\"keydown\", this._onKeyDown, true);\n    this.unsubscribe(this._onChanged);\n    delete FocusedElementState._lastResetElement;\n    delete this._nextVal;\n    delete this._lastVal;\n  }\n\n  static forgetMemorized(instance, parent) {\n    var _a, _b;\n\n    let wel = FocusedElementState._lastResetElement;\n    let el = wel && wel.get();\n\n    if (el && parent.contains(el)) {\n      delete FocusedElementState._lastResetElement;\n    }\n\n    el = (_b = (_a = instance._nextVal) === null || _a === void 0 ? void 0 : _a.element) === null || _b === void 0 ? void 0 : _b.get();\n\n    if (el && parent.contains(el)) {\n      delete instance._nextVal;\n    }\n\n    wel = instance._lastVal;\n    el = wel && wel.get();\n\n    if (el && parent.contains(el)) {\n      delete instance._lastVal;\n    }\n  }\n\n  getFocusedElement() {\n    return this.getVal();\n  }\n\n  getLastFocusedElement() {\n    var _a;\n\n    let el = (_a = this._lastVal) === null || _a === void 0 ? void 0 : _a.get();\n\n    if (!el || el && !documentContains(el.ownerDocument, el)) {\n      this._lastVal = el = undefined;\n    }\n\n    return el;\n  }\n\n  focus(element, noFocusedProgrammaticallyFlag, noAccessibleCheck) {\n    if (!this._tabster.focusable.isFocusable(element, noFocusedProgrammaticallyFlag, false, noAccessibleCheck)) {\n      return false;\n    }\n\n    element.focus();\n    return true;\n  }\n\n  focusDefault(container) {\n    const el = this._tabster.focusable.findDefault({\n      container\n    });\n\n    if (el) {\n      this._tabster.focusedElement.focus(el);\n\n      return true;\n    }\n\n    return false;\n  }\n\n  getFirstOrLastTabbable(isFirst, props) {\n    const tabsterFocusable = this._tabster.focusable;\n    const {\n      container,\n      ignoreAccessibility\n    } = props;\n    let uncontrolled;\n    let toFocus;\n\n    if (container) {\n      const ctx = RootAPI.getTabsterContext(this._tabster, container);\n\n      if (ctx) {\n        let next = FocusedElementState.findNextTabbable(this._tabster, ctx, container, undefined, undefined, !isFirst, undefined, ignoreAccessibility);\n\n        if (next) {\n          toFocus = next.element;\n          uncontrolled = next.uncontrolled;\n\n          while (!toFocus && uncontrolled) {\n            if (tabsterFocusable.isFocusable(uncontrolled, false, true, true)) {\n              toFocus = uncontrolled;\n            } else {\n              toFocus = tabsterFocusable[isFirst ? \"findFirst\" : \"findLast\"]({\n                container: uncontrolled,\n                ignoreUncontrolled: true,\n                ignoreAccessibility,\n                useActiveModalizer: true\n              });\n            }\n\n            if (!toFocus) {\n              next = FocusedElementState.findNextTabbable(this._tabster, ctx, uncontrolled, undefined, undefined, !isFirst, undefined, ignoreAccessibility);\n\n              if (next) {\n                toFocus = next.element;\n                uncontrolled = next.uncontrolled;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (toFocus && !(container === null || container === void 0 ? void 0 : container.contains(toFocus))) {\n      toFocus = undefined;\n    }\n\n    return toFocus || undefined;\n  }\n\n  _focusFirstOrLast(isFirst, props) {\n    const toFocus = this.getFirstOrLastTabbable(isFirst, props);\n\n    if (toFocus) {\n      this.focus(toFocus, false, true);\n      return true;\n    }\n\n    return false;\n  }\n\n  focusFirst(props) {\n    return this._focusFirstOrLast(true, props);\n  }\n\n  focusLast(props) {\n    return this._focusFirstOrLast(false, props);\n  }\n\n  resetFocus(container) {\n    if (!this._tabster.focusable.isVisible(container)) {\n      return false;\n    }\n\n    if (!this._tabster.focusable.isFocusable(container, true, true, true)) {\n      const prevTabIndex = container.getAttribute(\"tabindex\");\n      const prevAriaHidden = container.getAttribute(\"aria-hidden\");\n      container.tabIndex = -1;\n      container.setAttribute(\"aria-hidden\", \"true\");\n      FocusedElementState._lastResetElement = new WeakHTMLElement(this._win, container);\n      this.focus(container, true, true);\n\n      this._setOrRemoveAttribute(container, \"tabindex\", prevTabIndex);\n\n      this._setOrRemoveAttribute(container, \"aria-hidden\", prevAriaHidden);\n    } else {\n      this.focus(container);\n    }\n\n    return true;\n  }\n\n  _setOrRemoveAttribute(element, name, value) {\n    if (value === null) {\n      element.removeAttribute(name);\n    } else {\n      element.setAttribute(name, value);\n    }\n  }\n\n  _setFocusedElement(element, relatedTarget, isFocusedProgrammatically) {\n    var _a, _b;\n\n    if (this._tabster._noop) {\n      return;\n    }\n\n    const details = {\n      relatedTarget\n    };\n\n    if (element) {\n      const lastResetElement = (_a = FocusedElementState._lastResetElement) === null || _a === void 0 ? void 0 : _a.get();\n      FocusedElementState._lastResetElement = undefined;\n\n      if (lastResetElement === element || shouldIgnoreFocus(element)) {\n        return;\n      }\n\n      details.isFocusedProgrammatically = isFocusedProgrammatically;\n      const ctx = RootAPI.getTabsterContext(this._tabster, element);\n      const modalizerId = (_b = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer) === null || _b === void 0 ? void 0 : _b.userId;\n\n      if (modalizerId) {\n        details.modalizerId = modalizerId;\n      }\n    }\n\n    const nextVal = this._nextVal = {\n      element: element ? new WeakHTMLElement(this._win, element) : undefined,\n      details\n    };\n\n    if (element && element !== this._val) {\n      this._validateFocusedElement(element);\n    } // _validateFocusedElement() might cause the refocus which will trigger\n    // another call to this function. Making sure that the value is correct.\n\n\n    if (this._nextVal === nextVal) {\n      this.setVal(element, details);\n    }\n\n    this._nextVal = undefined;\n  }\n\n  setVal(val, details) {\n    super.setVal(val, details);\n\n    if (val) {\n      this._lastVal = new WeakHTMLElement(this._win, val);\n    }\n  }\n\n  static findNextTabbable(tabster, ctx, container, currentElement, referenceElement, isBackward, ignoreUncontrolled, ignoreAccessibility) {\n    const actualContainer = container || ctx.root.getElement();\n\n    if (!actualContainer) {\n      return null;\n    }\n\n    let next = null;\n    const isTabbingTimer = FocusedElementState._isTabbingTimer;\n    const win = tabster.getWindow();\n\n    if (isTabbingTimer) {\n      win.clearTimeout(isTabbingTimer);\n    }\n\n    FocusedElementState.isTabbing = true;\n    FocusedElementState._isTabbingTimer = win.setTimeout(() => {\n      delete FocusedElementState._isTabbingTimer;\n      FocusedElementState.isTabbing = false;\n    }, 0);\n    const modalizer = ctx.modalizer;\n    const groupper = ctx.groupper;\n    const mover = ctx.mover;\n\n    const callFindNext = what => {\n      var _a;\n\n      next = what.findNextTabbable(currentElement, referenceElement, isBackward, ignoreUncontrolled, ignoreAccessibility);\n\n      if (currentElement && !(next === null || next === void 0 ? void 0 : next.element) && !(next === null || next === void 0 ? void 0 : next.uncontrolled)) {\n        const parentElement = what !== modalizer && ((_a = what.getElement()) === null || _a === void 0 ? void 0 : _a.parentElement);\n\n        if (parentElement) {\n          const parentCtx = RootAPI.getTabsterContext(tabster, currentElement, {\n            referenceElement: parentElement\n          });\n\n          if (parentCtx) {\n            const currentScopeElement = what.getElement();\n            const newCurrent = isBackward ? currentScopeElement : currentScopeElement && getLastChild(currentScopeElement) || currentScopeElement;\n\n            if (newCurrent) {\n              next = FocusedElementState.findNextTabbable(tabster, parentCtx, container, newCurrent, parentElement, isBackward, ignoreUncontrolled, ignoreAccessibility);\n\n              if (next) {\n                next.outOfDOMOrder = true;\n              }\n            }\n          }\n        }\n      }\n    };\n\n    if (groupper && mover) {\n      callFindNext(ctx.isGroupperFirst ? groupper : mover);\n    } else if (groupper) {\n      callFindNext(groupper);\n    } else if (mover) {\n      callFindNext(mover);\n    } else if (modalizer) {\n      callFindNext(modalizer);\n    } else {\n      let uncontrolled;\n\n      const onUncontrolled = el => {\n        uncontrolled = el;\n      };\n\n      const findProps = {\n        container: actualContainer,\n        currentElement,\n        referenceElement,\n        onUncontrolled,\n        ignoreUncontrolled,\n        ignoreAccessibility,\n        useActiveModalizer: true\n      };\n      const findPropsOut = {};\n      const nextElement = tabster.focusable[isBackward ? \"findPrev\" : \"findNext\"](findProps, findPropsOut);\n      next = {\n        element: uncontrolled ? undefined : nextElement,\n        uncontrolled,\n        outOfDOMOrder: findPropsOut.outOfDOMOrder\n      };\n    }\n\n    return next;\n  }\n\n}\nFocusedElementState.isTabbing = false;\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nclass GroupperDummyManager extends DummyInputManager {\n  constructor(element, groupper, tabster, sys) {\n    super(tabster, element, DummyInputManagerPriorities.Groupper, sys, true);\n\n    this._setHandlers((dummyInput, isBackward, relatedTarget) => {\n      var _a, _b;\n\n      const container = element.get();\n      const input = dummyInput.input;\n\n      if (container && input) {\n        const ctx = RootAPI.getTabsterContext(tabster, input);\n\n        if (ctx) {\n          let next;\n          next = (_a = groupper.findNextTabbable(relatedTarget || undefined, undefined, isBackward, true, true)) === null || _a === void 0 ? void 0 : _a.element;\n\n          if (!next) {\n            next = (_b = FocusedElementState.findNextTabbable(tabster, ctx, undefined, dummyInput.isOutside ? input : getAdjacentElement(container, !isBackward), undefined, isBackward, true, true)) === null || _b === void 0 ? void 0 : _b.element;\n          }\n\n          if (next) {\n            nativeFocus(next);\n          }\n        }\n      }\n    });\n  }\n\n}\n\nclass Groupper extends TabsterPart {\n  constructor(tabster, element, onDispose, props, sys) {\n    super(tabster, element, props);\n    this._shouldTabInside = false;\n    this.makeTabbable(false);\n    this._onDispose = onDispose;\n\n    if (!tabster.controlTab) {\n      this.dummyManager = new GroupperDummyManager(this._element, this, tabster, sys);\n    }\n  }\n\n  dispose() {\n    var _a;\n\n    this._onDispose(this);\n\n    const element = this._element.get();\n\n    (_a = this.dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();\n\n    if (element) {\n      if (process.env.NODE_ENV === 'development') {\n        _setInformativeStyle$1(this._element, true);\n      }\n    }\n\n    delete this._first;\n  }\n\n  findNextTabbable(currentElement, referenceElement, isBackward, ignoreUncontrolled, ignoreAccessibility) {\n    var _a;\n\n    const groupperElement = this.getElement();\n\n    if (!groupperElement) {\n      return null;\n    }\n\n    const currentIsDummy = ((_a = currentElement === null || currentElement === void 0 ? void 0 : currentElement.__tabsterDummyContainer) === null || _a === void 0 ? void 0 : _a.get()) === groupperElement;\n\n    if (!this._shouldTabInside && currentElement && groupperElement.contains(currentElement) && !currentIsDummy) {\n      return {\n        element: undefined,\n        outOfDOMOrder: true\n      };\n    }\n\n    const groupperFirstFocusable = this.getFirst(true);\n\n    if (!currentElement || !groupperElement.contains(currentElement) || currentIsDummy) {\n      return {\n        element: groupperFirstFocusable,\n        outOfDOMOrder: true\n      };\n    }\n\n    const tabster = this._tabster;\n    let next = null;\n    let uncontrolled;\n    let outOfDOMOrder = false;\n\n    const onUncontrolled = el => {\n      uncontrolled = el;\n    };\n\n    if (this._shouldTabInside && groupperFirstFocusable) {\n      const findProps = {\n        container: groupperElement,\n        currentElement,\n        referenceElement,\n        onUncontrolled,\n        ignoreUncontrolled,\n        ignoreAccessibility,\n        useActiveModalizer: true\n      };\n      const findPropsOut = {};\n      next = tabster.focusable[isBackward ? \"findPrev\" : \"findNext\"](findProps, findPropsOut);\n      outOfDOMOrder = !!findPropsOut.outOfDOMOrder;\n\n      if (!uncontrolled && !next && this._props.tabbability === GroupperTabbabilities.LimitedTrapFocus) {\n        next = isBackward ? tabster.focusable.findLast({\n          container: groupperElement,\n          ignoreUncontrolled: true,\n          ignoreAccessibility,\n          useActiveModalizer: true\n        }) : tabster.focusable.findFirst({\n          container: groupperElement,\n          ignoreUncontrolled: true,\n          ignoreAccessibility,\n          useActiveModalizer: true\n        });\n        outOfDOMOrder = true;\n      }\n    }\n\n    return {\n      element: next,\n      uncontrolled,\n      outOfDOMOrder\n    };\n  }\n\n  makeTabbable(isTabbable) {\n    this._shouldTabInside = isTabbable || !this._props.tabbability;\n\n    if (process.env.NODE_ENV === 'development') {\n      _setInformativeStyle$1(this._element, !this._shouldTabInside);\n    }\n  }\n\n  isActive(noIfFirstIsFocused) {\n    var _a;\n\n    const element = this.getElement() || null;\n    let isParentActive = true;\n\n    for (let e = element === null || element === void 0 ? void 0 : element.parentElement; e; e = e.parentElement) {\n      const g = (_a = getTabsterOnElement(this._tabster, e)) === null || _a === void 0 ? void 0 : _a.groupper;\n\n      if (g) {\n        if (!g._shouldTabInside) {\n          isParentActive = false;\n        }\n      }\n    }\n\n    let ret = isParentActive ? this._props.tabbability ? this._shouldTabInside : false : undefined;\n\n    if (ret && noIfFirstIsFocused) {\n      const focused = this._tabster.focusedElement.getFocusedElement();\n\n      if (focused) {\n        ret = focused !== this.getFirst(true);\n      }\n    }\n\n    return ret;\n  }\n\n  getFirst(orContainer) {\n    var _a;\n\n    const groupperElement = this.getElement();\n    let first;\n\n    if (groupperElement) {\n      if (orContainer && this._tabster.focusable.isFocusable(groupperElement)) {\n        return groupperElement;\n      }\n\n      first = (_a = this._first) === null || _a === void 0 ? void 0 : _a.get();\n\n      if (!first) {\n        first = this._tabster.focusable.findFirst({\n          container: groupperElement,\n          ignoreUncontrolled: true,\n          useActiveModalizer: true\n        }) || undefined;\n\n        if (first) {\n          this.setFirst(first);\n        }\n      }\n    }\n\n    return first;\n  }\n\n  setFirst(element) {\n    if (element) {\n      this._first = new WeakHTMLElement(this._tabster.getWindow, element);\n    } else {\n      delete this._first;\n    }\n  }\n\n  acceptElement(element, state) {\n    var _a;\n\n    const cachedGrouppers = state.cachedGrouppers;\n    const parentElement = (_a = this.getElement()) === null || _a === void 0 ? void 0 : _a.parentElement;\n    const parentCtx = parentElement && RootAPI.getTabsterContext(this._tabster, parentElement);\n    const parentCtxGroupper = parentCtx === null || parentCtx === void 0 ? void 0 : parentCtx.groupper;\n    const parentGroupper = (parentCtx === null || parentCtx === void 0 ? void 0 : parentCtx.isGroupperFirst) ? parentCtxGroupper : undefined;\n    let parentGroupperElement;\n\n    const getIsActive = groupper => {\n      let cached = cachedGrouppers[groupper.id];\n      let isActive;\n\n      if (cached) {\n        isActive = cached.isActive;\n      } else {\n        isActive = this.isActive(true);\n        cached = cachedGrouppers[groupper.id] = {\n          isActive\n        };\n      }\n\n      return isActive;\n    };\n\n    if (parentGroupper) {\n      parentGroupperElement = parentGroupper.getElement();\n\n      if (!getIsActive(parentGroupper) && parentGroupperElement && state.container !== parentGroupperElement && state.container.contains(parentGroupperElement)) {\n        // Do not fall into a child groupper of inactive parent groupper if it's in the scope of the search.\n        state.skippedFocusable = true;\n        return NodeFilter.FILTER_REJECT;\n      }\n    }\n\n    const isActive = getIsActive(this);\n    const groupperElement = this.getElement();\n\n    if (groupperElement) {\n      if (isActive !== true) {\n        if (groupperElement === element && parentCtxGroupper) {\n          if (!parentGroupperElement) {\n            parentGroupperElement = parentCtxGroupper.getElement();\n          }\n\n          if (parentGroupperElement && !getIsActive(parentCtxGroupper) && state.container.contains(parentGroupperElement) && parentGroupperElement !== state.container) {\n            state.skippedFocusable = true;\n            return NodeFilter.FILTER_REJECT;\n          }\n        }\n\n        if (groupperElement !== element && groupperElement.contains(element)) {\n          state.skippedFocusable = true;\n          return NodeFilter.FILTER_REJECT;\n        }\n\n        const cached = cachedGrouppers[this.id];\n        let first;\n\n        if (\"first\" in cached) {\n          first = cached.first;\n        } else {\n          first = cached.first = this.getFirst(true);\n        }\n\n        if (first && state.acceptCondition(first)) {\n          state.lastToIgnore = groupperElement;\n          state.skippedFocusable = true;\n\n          if (first !== state.from) {\n            state.found = true;\n            state.foundElement = first;\n            return NodeFilter.FILTER_ACCEPT;\n          } else {\n            return NodeFilter.FILTER_REJECT;\n          }\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\nclass GroupperAPI {\n  constructor(tabster, getWindow) {\n    this._current = {};\n    this._grouppers = {};\n\n    this._init = () => {\n      const win = this._win(); // Making sure groupper's onFocus is called before modalizer's onFocus.\n\n\n      this._tabster.focusedElement.subscribeFirst(this._onFocus);\n\n      win.document.addEventListener(\"mousedown\", this._onMouseDown, true);\n      win.addEventListener(\"keydown\", this._onKeyDown, true);\n    };\n\n    this._onGroupperDispose = groupper => {\n      delete this._grouppers[groupper.id];\n    };\n\n    this._onFocus = element => {\n      if (element) {\n        this._updateCurrent(element, true, true);\n      }\n    };\n\n    this._onMouseDown = e => {\n      if (e.target) {\n        this._updateCurrent(e.target, true);\n      }\n    };\n\n    this._onKeyDown = event => {\n      if (event.keyCode !== Keys.Enter && event.keyCode !== Keys.Esc) {\n        return;\n      } // Give a chance to other listeners to handle the event.\n\n\n      if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {\n        return;\n      }\n\n      const element = this._tabster.focusedElement.getFocusedElement();\n\n      if (element) {\n        this.handleKeyPress(element, event);\n      }\n    };\n\n    this._tabster = tabster;\n    this._win = getWindow;\n    tabster.queueInit(this._init);\n  }\n\n  dispose() {\n    const win = this._win();\n\n    this._current = {};\n\n    if (this._updateTimer) {\n      win.clearTimeout(this._updateTimer);\n      delete this._updateTimer;\n    }\n\n    this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n    win.document.removeEventListener(\"mousedown\", this._onMouseDown, true);\n    win.removeEventListener(\"keydown\", this._onKeyDown, true);\n    Object.keys(this._grouppers).forEach(groupperId => {\n      if (this._grouppers[groupperId]) {\n        this._grouppers[groupperId].dispose();\n\n        delete this._grouppers[groupperId];\n      }\n    });\n  }\n\n  createGroupper(element, props, sys) {\n    if (process.env.NODE_ENV === 'development') ;\n\n    const newGroupper = new Groupper(this._tabster, element, this._onGroupperDispose, props, sys);\n    this._grouppers[newGroupper.id] = newGroupper;\n\n    const focusedElement = this._tabster.focusedElement.getFocusedElement(); // Newly created groupper contains currently focused element, update the state on the next tick (to\n    // make sure all grouppers are processed).\n\n\n    if (focusedElement && element.contains(focusedElement) && !this._updateTimer) {\n      this._updateTimer = this._win().setTimeout(() => {\n        delete this._updateTimer; // Making sure the focused element hasn't changed.\n\n        if (focusedElement === this._tabster.focusedElement.getFocusedElement()) {\n          this._updateCurrent(focusedElement, true, true);\n        }\n      }, 0);\n    }\n\n    return newGroupper;\n  }\n\n  forgetCurrentGrouppers() {\n    this._current = {};\n  }\n\n  _updateCurrent(element, includeTarget, checkTarget) {\n    var _a;\n\n    if (this._updateTimer) {\n      this._win().clearTimeout(this._updateTimer);\n\n      delete this._updateTimer;\n    }\n\n    const newIds = {};\n    let isTarget = true;\n\n    for (let el = element; el; el = el.parentElement) {\n      const groupper = (_a = getTabsterOnElement(this._tabster, el)) === null || _a === void 0 ? void 0 : _a.groupper;\n\n      if (groupper) {\n        newIds[groupper.id] = true;\n\n        if (isTarget && checkTarget && el !== element) {\n          isTarget = false;\n        }\n\n        if (includeTarget || !isTarget) {\n          this._current[groupper.id] = groupper;\n          const isTabbable = groupper.isActive() || element !== el && (!groupper.getProps().delegated || groupper.getFirst(false) !== element);\n          groupper.makeTabbable(isTabbable);\n        }\n\n        isTarget = false;\n      }\n    }\n\n    for (const id of Object.keys(this._current)) {\n      const groupper = this._current[id];\n\n      if (!(groupper.id in newIds)) {\n        groupper.makeTabbable(false);\n        groupper.setFirst(undefined);\n        delete this._current[id];\n      }\n    }\n  }\n\n  handleKeyPress(element, event, noGoUp) {\n    var _a;\n\n    const tabster = this._tabster;\n    const ctx = RootAPI.getTabsterContext(tabster, element);\n    const modalizerInGroupper = ctx === null || ctx === void 0 ? void 0 : ctx.modalizerInGroupper;\n    let groupper = (ctx === null || ctx === void 0 ? void 0 : ctx.groupper) || modalizerInGroupper;\n\n    if (ctx && groupper) {\n      if (ctx.ignoreKeydown(event)) {\n        return;\n      }\n\n      let next;\n      const groupperElement = groupper.getElement();\n\n      if (event.keyCode === Keys.Enter) {\n        if (groupperElement && (element === groupperElement || groupper.getProps().delegated && element === groupper.getFirst(false))) {\n          next = tabster.focusable.findNext({\n            container: groupperElement,\n            currentElement: element,\n            useActiveModalizer: true\n          });\n        }\n      } else if (event.keyCode === Keys.Esc) {\n        if (groupperElement && groupperElement.contains(element)) {\n          if (element !== groupperElement || noGoUp) {\n            next = groupper.getFirst(true);\n          } else {\n            const parentElement = groupperElement.parentElement;\n            const parentCtx = parentElement ? RootAPI.getTabsterContext(tabster, parentElement) : undefined;\n            groupper = parentCtx === null || parentCtx === void 0 ? void 0 : parentCtx.groupper;\n            next = groupper === null || groupper === void 0 ? void 0 : groupper.getFirst(true);\n          }\n        }\n\n        if (groupper) {\n          groupper.makeTabbable(false);\n\n          if (modalizerInGroupper) {\n            (_a = tabster.modalizer) === null || _a === void 0 ? void 0 : _a.setActive(undefined);\n          }\n        }\n      }\n\n      if (next) {\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        next.focus();\n      }\n    }\n  }\n\n}\n\nfunction _setInformativeStyle$1(weakElement, remove) {\n  if (process.env.NODE_ENV === 'development') {\n    const element = weakElement.get();\n\n    if (element) {\n      if (remove) {\n        element.style.removeProperty(\"--tabster-groupper\");\n      } else {\n        element.style.setProperty(\"--tabster-groupper\", \"unlimited\");\n      }\n    }\n  }\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nclass KeyboardNavigationState extends Subscribable {\n  constructor(getWindow) {\n    super();\n\n    this._onChange = isNavigatingWithKeyboard => {\n      this.setVal(isNavigatingWithKeyboard, undefined);\n    };\n\n    this._keyborg = createKeyborg(getWindow());\n\n    this._keyborg.subscribe(this._onChange);\n  }\n\n  dispose() {\n    super.dispose();\n\n    if (this._keyborg) {\n      this._keyborg.unsubscribe(this._onChange);\n\n      disposeKeyborg(this._keyborg);\n      delete this._keyborg;\n    }\n  }\n\n  setNavigatingWithKeyboard(isNavigatingWithKeyboard) {\n    var _a;\n\n    (_a = this._keyborg) === null || _a === void 0 ? void 0 : _a.setVal(isNavigatingWithKeyboard);\n  }\n\n  isNavigatingWithKeyboard() {\n    var _a;\n\n    return !!((_a = this._keyborg) === null || _a === void 0 ? void 0 : _a.isNavigatingWithKeyboard());\n  }\n\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nlet _wasFocusedCounter = 0;\nconst _ariaHidden = \"aria-hidden\";\n\nfunction _setInformativeStyle(weakElement, remove, internalId, userId, isActive, wasFocused) {\n  if (process.env.NODE_ENV === 'development') {\n    const element = weakElement.get();\n\n    if (element) {\n      if (remove) {\n        element.style.removeProperty(\"--tabster-modalizer\");\n      } else {\n        element.style.setProperty(\"--tabster-modalizer\", internalId + \",\" + userId + \",\" + (isActive ? \"active\" : \"inactive\") + \",\" + \",\" + (wasFocused ? `focused(${wasFocused})` : \"not-focused\"));\n      }\n    }\n  }\n}\n/**\r\n * Manages the dummy inputs for the Modalizer.\r\n */\n\n\nclass ModalizerDummyManager extends DummyInputManager {\n  constructor(element, tabster, sys) {\n    super(tabster, element, DummyInputManagerPriorities.Modalizer, sys);\n\n    this._setHandlers((dummyInput, isBackward) => {\n      var _a, _b, _c;\n\n      const el = element.get();\n      const container = el && ((_a = RootAPI.getRoot(tabster, el)) === null || _a === void 0 ? void 0 : _a.getElement());\n      const input = dummyInput.input;\n      let toFocus;\n\n      if (container && input) {\n        const dummyContainer = (_b = input.__tabsterDummyContainer) === null || _b === void 0 ? void 0 : _b.get();\n        const ctx = RootAPI.getTabsterContext(tabster, dummyContainer || input);\n\n        if (ctx) {\n          toFocus = (_c = FocusedElementState.findNextTabbable(tabster, ctx, container, input, undefined, isBackward, true, true)) === null || _c === void 0 ? void 0 : _c.element;\n        }\n\n        if (toFocus) {\n          nativeFocus(toFocus);\n        }\n      }\n    });\n  }\n\n}\n\nclass Modalizer extends TabsterPart {\n  constructor(tabster, element, onDispose, props, sys, activeElements) {\n    super(tabster, element, props);\n    this._wasFocused = 0;\n    this.userId = props.id;\n    this._onDispose = onDispose;\n    this._activeElements = activeElements;\n\n    if (!tabster.controlTab) {\n      this.dummyManager = new ModalizerDummyManager(this._element, tabster, sys);\n    }\n\n    if (process.env.NODE_ENV === 'development') {\n      _setInformativeStyle(this._element, false, this.id, this.userId, this._isActive, this._wasFocused);\n    }\n  }\n\n  makeActive(isActive) {\n    if (this._isActive !== isActive) {\n      this._isActive = isActive;\n      const element = this.getElement();\n\n      if (element) {\n        const activeElements = this._activeElements;\n        const index = activeElements.map(e => e.deref()).indexOf(element);\n\n        if (isActive) {\n          if (index < 0) {\n            activeElements.push(new WeakRef(element));\n          }\n        } else {\n          if (index >= 0) {\n            activeElements.splice(index, 1);\n          }\n        }\n      }\n\n      if (process.env.NODE_ENV === 'development') {\n        _setInformativeStyle(this._element, false, this.id, this.userId, this._isActive, this._wasFocused);\n      }\n\n      this.triggerFocusEvent(isActive ? ModalizerActiveEventName : ModalizerInactiveEventName);\n    }\n  }\n\n  focused(noIncrement) {\n    if (!noIncrement) {\n      this._wasFocused = ++_wasFocusedCounter;\n    }\n\n    return this._wasFocused;\n  }\n\n  setProps(props) {\n    if (props.id) {\n      this.userId = props.id;\n    }\n\n    this._props = { ...props\n    };\n  }\n\n  dispose() {\n    var _a;\n\n    this.makeActive(false);\n\n    this._onDispose(this);\n\n    (_a = this.dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();\n    this._activeElements = [];\n\n    this._remove();\n  }\n\n  isActive() {\n    return !!this._isActive;\n  }\n\n  contains(element) {\n    var _a;\n\n    return !!((_a = this.getElement()) === null || _a === void 0 ? void 0 : _a.contains(element));\n  }\n\n  findNextTabbable(currentElement, referenceElement, isBackward, ignoreUncontrolled, ignoreAccessibility) {\n    var _a, _b;\n\n    const modalizerElement = this.getElement();\n\n    if (!modalizerElement) {\n      return null;\n    }\n\n    const tabster = this._tabster;\n    let next = null;\n    let uncontrolled;\n    let outOfDOMOrder = false;\n\n    const onUncontrolled = el => {\n      uncontrolled = el;\n    };\n\n    const container = currentElement && ((_a = RootAPI.getRoot(tabster, currentElement)) === null || _a === void 0 ? void 0 : _a.getElement());\n\n    if (container) {\n      const findProps = {\n        container,\n        currentElement,\n        referenceElement,\n        onUncontrolled,\n        ignoreUncontrolled,\n        ignoreAccessibility,\n        useActiveModalizer: true\n      };\n      const findPropsOut = {};\n      next = tabster.focusable[isBackward ? \"findPrev\" : \"findNext\"](findProps, findPropsOut);\n\n      if (!uncontrolled && !next && this._props.isTrapped && ((_b = tabster.modalizer) === null || _b === void 0 ? void 0 : _b.activeId)) {\n        next = tabster.focusable[isBackward ? \"findLast\" : \"findFirst\"]({\n          container,\n          ignoreUncontrolled: true,\n          ignoreAccessibility,\n          useActiveModalizer: true\n        });\n        outOfDOMOrder = true;\n      } else {\n        outOfDOMOrder = !!findPropsOut.outOfDOMOrder;\n      }\n    }\n\n    return {\n      element: next,\n      uncontrolled,\n      outOfDOMOrder\n    };\n  }\n\n  triggerFocusEvent(eventName, allElements) {\n    const element = this.getElement();\n    let defaultPrevented = false;\n\n    if (element) {\n      const elements = allElements ? this._activeElements.map(e => e.deref()) : [element];\n\n      for (const el of elements) {\n        if (el && !triggerEvent(el, eventName, {\n          id: this.userId,\n          element,\n          eventName\n        })) {\n          defaultPrevented = true;\n        }\n      }\n    }\n\n    return defaultPrevented;\n  }\n\n  _remove() {\n    if (process.env.NODE_ENV === 'development') {\n      _setInformativeStyle(this._element, true);\n    }\n  }\n\n} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\nclass ModalizerAPI {\n  constructor(tabster, // @deprecated use accessibleCheck.\n  alwaysAccessibleSelector, accessibleCheck) {\n    this._onModalizerDispose = modalizer => {\n      const id = modalizer.id;\n      const userId = modalizer.userId;\n      const part = this._parts[userId];\n      delete this._modalizers[id];\n\n      if (part) {\n        delete part[id];\n\n        if (Object.keys(part).length === 0) {\n          delete this._parts[userId];\n\n          if (this.activeId === userId) {\n            this.setActive(undefined);\n          }\n        }\n      }\n    };\n\n    this._onKeyDown = event => {\n      var _a;\n\n      if (event.keyCode !== Keys.Esc) {\n        return;\n      }\n\n      const tabster = this._tabster;\n      const element = tabster.focusedElement.getFocusedElement();\n\n      if (element) {\n        const ctx = RootAPI.getTabsterContext(tabster, element);\n        const modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;\n\n        if (ctx && !ctx.groupper && (modalizer === null || modalizer === void 0 ? void 0 : modalizer.isActive()) && !ctx.ignoreKeydown(event)) {\n          const activeId = modalizer.userId;\n\n          if (activeId) {\n            const part = this._parts[activeId];\n\n            if (part) {\n              const focusedSince = Object.keys(part).map(id => {\n                var _a;\n\n                const m = part[id];\n                const el = m.getElement();\n                let groupper;\n\n                if (el) {\n                  groupper = (_a = getTabsterOnElement(this._tabster, el)) === null || _a === void 0 ? void 0 : _a.groupper;\n                }\n\n                return m && el && groupper ? {\n                  el,\n                  focusedSince: m.focused(true)\n                } : {\n                  focusedSince: 0\n                };\n              }).filter(f => f.focusedSince > 0).sort((a, b) => a.focusedSince > b.focusedSince ? -1 : a.focusedSince < b.focusedSince ? 1 : 0);\n\n              if (focusedSince.length) {\n                const groupperElement = focusedSince[0].el;\n\n                if (groupperElement) {\n                  (_a = tabster.groupper) === null || _a === void 0 ? void 0 : _a.handleKeyPress(groupperElement, event, true);\n                }\n              }\n            }\n          }\n        }\n      }\n    };\n    /**\r\n     * Subscribes to the focus state and handles modalizer related focus events\r\n     * @param e - Element that is focused\r\n     * @param details - Additional data about the focus event\r\n     */\n\n\n    this._onFocus = (focusedElement, details) => {\n      var _a, _b;\n\n      const ctx = focusedElement && RootAPI.getTabsterContext(this._tabster, focusedElement); // Modalizer behaviour is opt in, only apply to elements that have a tabster context\n\n      if (!ctx || !focusedElement) {\n        return;\n      }\n\n      const augmentedMap = this._augMap;\n\n      for (let e = focusedElement; e; e = e.parentElement) {\n        // If the newly focused element is inside some of the hidden containers,\n        // remove aria-hidden from those synchronously for the screen readers\n        // to be able to read the element. The rest of aria-hiddens, will be removed\n        // acynchronously for the sake of performance.\n        if (augmentedMap.has(e)) {\n          augmentedMap.delete(e);\n          augmentAttribute(this._tabster, e, _ariaHidden);\n        }\n      }\n\n      const modalizer = ctx.modalizer; // An inactive groupper with the modalizer on the same node will not give the modalizer\n      // in the context, yet we still want to track that the modalizer's container was focused.\n\n      (_b = modalizer || ((_a = getTabsterOnElement(this._tabster, focusedElement)) === null || _a === void 0 ? void 0 : _a.modalizer)) === null || _b === void 0 ? void 0 : _b.focused();\n\n      if ((modalizer === null || modalizer === void 0 ? void 0 : modalizer.userId) === this.activeId) {\n        this.currentIsOthersAccessible = modalizer === null || modalizer === void 0 ? void 0 : modalizer.getProps().isOthersAccessible;\n        return;\n      } // Developers calling `element.focus()` should change/deactivate active modalizer\n\n\n      if (details.isFocusedProgrammatically || this.currentIsOthersAccessible || (modalizer === null || modalizer === void 0 ? void 0 : modalizer.getProps().isAlwaysAccessible)) {\n        this.setActive(modalizer);\n      } else {\n        // Focused outside of the active modalizer, try pull focus back to current modalizer\n        const win = this._win();\n\n        win.clearTimeout(this._restoreModalizerFocusTimer); // TODO some rendering frameworks (i.e. React) might async rerender the DOM so we need to wait for a duration\n        // Figure out a better way of doing this rather than a 100ms timeout\n\n        this._restoreModalizerFocusTimer = win.setTimeout(() => this._restoreModalizerFocus(focusedElement), 100);\n      }\n    };\n\n    this._tabster = tabster;\n    this._win = tabster.getWindow;\n    this._modalizers = {};\n    this._parts = {};\n    this._augMap = new WeakMap();\n    this._aug = [];\n    this._alwaysAccessibleSelector = alwaysAccessibleSelector;\n    this._accessibleCheck = accessibleCheck;\n    this.activeElements = [];\n\n    if (!tabster.controlTab) {\n      tabster.root.addDummyInputs();\n    }\n\n    const win = this._win();\n\n    win.addEventListener(\"keydown\", this._onKeyDown, true);\n    tabster.queueInit(() => {\n      this._tabster.focusedElement.subscribe(this._onFocus);\n    });\n  }\n\n  dispose() {\n    const win = this._win();\n\n    win.removeEventListener(\"keydown\", this._onKeyDown, true); // Dispose all modalizers managed by the API\n\n    Object.keys(this._modalizers).forEach(modalizerId => {\n      if (this._modalizers[modalizerId]) {\n        this._modalizers[modalizerId].dispose();\n\n        delete this._modalizers[modalizerId];\n      }\n    });\n    win.clearTimeout(this._restoreModalizerFocusTimer);\n    win.clearTimeout(this._hiddenUpdateTimer);\n    this._parts = {};\n    delete this.activeId;\n    this.activeElements = [];\n    this._augMap = new WeakMap();\n    this._aug = [];\n\n    this._tabster.focusedElement.unsubscribe(this._onFocus);\n  }\n\n  createModalizer(element, props, sys) {\n    var _a;\n\n    if (process.env.NODE_ENV === 'development') ;\n\n    const modalizer = new Modalizer(this._tabster, element, this._onModalizerDispose, props, sys, this.activeElements);\n    const id = modalizer.id;\n    const userId = props.id;\n    this._modalizers[id] = modalizer;\n    let part = this._parts[userId];\n\n    if (!part) {\n      part = this._parts[userId] = {};\n    }\n\n    part[id] = modalizer; // Adding a modalizer which is already focused, activate it\n\n    if (element.contains((_a = this._tabster.focusedElement.getFocusedElement()) !== null && _a !== void 0 ? _a : null)) {\n      if (userId !== this.activeId) {\n        this.setActive(modalizer);\n      } else {\n        modalizer.makeActive(true);\n      }\n    }\n\n    return modalizer;\n  }\n\n  isAugmented(element) {\n    return this._augMap.has(element);\n  }\n\n  hiddenUpdate() {\n    if (this._hiddenUpdateTimer) {\n      return;\n    }\n\n    this._hiddenUpdateTimer = this._win().setTimeout(() => {\n      delete this._hiddenUpdateTimer;\n\n      this._hiddenUpdate();\n    }, 250);\n  }\n\n  setActive(modalizer) {\n    const userId = modalizer === null || modalizer === void 0 ? void 0 : modalizer.userId;\n    const activeId = this.activeId;\n\n    if (activeId === userId) {\n      return;\n    }\n\n    this.activeId = userId;\n\n    if (activeId) {\n      const part = this._parts[activeId];\n\n      if (part) {\n        for (const id of Object.keys(part)) {\n          part[id].makeActive(false);\n        }\n      }\n    }\n\n    if (userId) {\n      const part = this._parts[userId];\n\n      if (part) {\n        for (const id of Object.keys(part)) {\n          part[id].makeActive(true);\n        }\n      }\n    }\n\n    this.currentIsOthersAccessible = modalizer === null || modalizer === void 0 ? void 0 : modalizer.getProps().isOthersAccessible;\n    this.hiddenUpdate();\n  }\n\n  focus(elementFromModalizer, noFocusFirst, noFocusDefault) {\n    const ctx = RootAPI.getTabsterContext(this._tabster, elementFromModalizer);\n    const modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;\n\n    if (modalizer) {\n      this.setActive(modalizer);\n      const props = modalizer.getProps();\n      const modalizerRoot = modalizer.getElement();\n\n      if (modalizerRoot) {\n        if (noFocusFirst === undefined) {\n          noFocusFirst = props.isNoFocusFirst;\n        }\n\n        if (!noFocusFirst && this._tabster.keyboardNavigation.isNavigatingWithKeyboard() && this._tabster.focusedElement.focusFirst({\n          container: modalizerRoot\n        })) {\n          return true;\n        }\n\n        if (noFocusDefault === undefined) {\n          noFocusDefault = props.isNoFocusDefault;\n        }\n\n        if (!noFocusDefault && this._tabster.focusedElement.focusDefault(modalizerRoot)) {\n          return true;\n        }\n\n        this._tabster.focusedElement.resetFocus(modalizerRoot);\n      }\n    } else if (process.env.NODE_ENV === 'development') {\n      console.error(\"Element is not in Modalizer.\", elementFromModalizer);\n    }\n\n    return false;\n  }\n\n  acceptElement(element, state) {\n    var _a;\n\n    const modalizerUserId = state.modalizerUserId;\n    const currentModalizer = (_a = state.currentCtx) === null || _a === void 0 ? void 0 : _a.modalizer;\n\n    if (modalizerUserId) {\n      for (const e of this.activeElements) {\n        const el = e.deref();\n\n        if (el && (element.contains(el) || el === element)) {\n          // We have a part of currently active modalizer somewhere deeper in the DOM,\n          // skipping all other checks.\n          return NodeFilter.FILTER_SKIP;\n        }\n      }\n    }\n\n    const ret = modalizerUserId === (currentModalizer === null || currentModalizer === void 0 ? void 0 : currentModalizer.userId) || !modalizerUserId && (currentModalizer === null || currentModalizer === void 0 ? void 0 : currentModalizer.getProps().isAlwaysAccessible) ? undefined : NodeFilter.FILTER_SKIP;\n\n    if (ret !== undefined) {\n      state.skippedFocusable = true;\n    }\n\n    return ret;\n  }\n\n  _hiddenUpdate() {\n    var _a;\n\n    const tabster = this._tabster;\n    const body = tabster.getWindow().document.body;\n    const activeId = this.activeId;\n    const parts = this._parts;\n    const visibleElements = [];\n    const hiddenElements = [];\n    const alwaysAccessibleSelector = this._alwaysAccessibleSelector;\n    const alwaysAccessibleElements = alwaysAccessibleSelector ? Array.from(body.querySelectorAll(alwaysAccessibleSelector)) : [];\n    const activeModalizerElements = [];\n\n    for (const userId of Object.keys(parts)) {\n      const modalizerParts = parts[userId];\n\n      for (const id of Object.keys(modalizerParts)) {\n        const modalizer = modalizerParts[id];\n        const el = modalizer.getElement();\n        const props = modalizer.getProps();\n        const isAlwaysAccessible = props.isAlwaysAccessible;\n\n        if (el) {\n          if (userId === activeId) {\n            activeModalizerElements.push(el);\n\n            if (!this.currentIsOthersAccessible) {\n              visibleElements.push(el);\n            }\n          } else if (isAlwaysAccessible) {\n            alwaysAccessibleElements.push(el);\n          } else {\n            hiddenElements.push(el);\n          }\n        }\n      }\n    }\n\n    const augmentedMap = this._augMap;\n    const allVisibleElements = visibleElements.length > 0 ? [...visibleElements, ...alwaysAccessibleElements] : undefined;\n    const newAugmented = [];\n    const newAugmentedMap = new WeakMap();\n\n    const toggle = (element, hide) => {\n      var _a;\n\n      const tagName = element.tagName;\n\n      if (tagName === \"SCRIPT\" || tagName === \"STYLE\") {\n        return;\n      }\n\n      let isAugmented = false;\n\n      if (augmentedMap.has(element)) {\n        if (hide) {\n          isAugmented = true;\n        } else {\n          augmentedMap.delete(element);\n          augmentAttribute(tabster, element, _ariaHidden);\n        }\n      } else if (hide && !((_a = this._accessibleCheck) === null || _a === void 0 ? void 0 : _a.call(this, element, activeModalizerElements)) && augmentAttribute(tabster, element, _ariaHidden, \"true\")) {\n        augmentedMap.set(element, true);\n        isAugmented = true;\n      }\n\n      if (isAugmented) {\n        newAugmented.push(new WeakRef(element));\n        newAugmentedMap.set(element, true);\n      }\n    };\n\n    const walk = element => {\n      for (let el = element.firstElementChild; el; el = el.nextElementSibling) {\n        let skip = false;\n        let containsModalizer = false;\n\n        if (allVisibleElements) {\n          for (const c of allVisibleElements) {\n            if (el === c) {\n              skip = true;\n              break;\n            }\n\n            if (el.contains(c)) {\n              containsModalizer = true;\n              break;\n            }\n          }\n\n          if (containsModalizer) {\n            walk(el);\n          } else if (!skip) {\n            toggle(el, true);\n          }\n        } else {\n          toggle(el, false);\n        }\n      }\n    };\n\n    if (!allVisibleElements) {\n      alwaysAccessibleElements.forEach(e => toggle(e, false));\n    }\n\n    hiddenElements.forEach(e => toggle(e, true));\n\n    if (body) {\n      walk(body);\n    }\n\n    (_a = this._aug) === null || _a === void 0 ? void 0 : _a.map(e => e.deref()).forEach(e => {\n      if (e && !newAugmentedMap.get(e)) {\n        toggle(e, false);\n      }\n    });\n    this._aug = newAugmented;\n    this._augMap = newAugmentedMap;\n  }\n  /**\r\n   * Called when an element is focused outside of an active modalizer.\r\n   * Attempts to pull focus back into the active modalizer\r\n   * @param outsideElement - An element being focused outside of the modalizer\r\n   */\n\n\n  _restoreModalizerFocus(outsideElement) {\n    const ownerDocument = outsideElement === null || outsideElement === void 0 ? void 0 : outsideElement.ownerDocument;\n\n    if (!outsideElement || !ownerDocument) {\n      return;\n    }\n\n    const ctx = RootAPI.getTabsterContext(this._tabster, outsideElement);\n    const modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;\n    const activeId = this.activeId;\n\n    if (!modalizer && !activeId || modalizer && activeId === modalizer.userId) {\n      return;\n    }\n\n    const container = ctx === null || ctx === void 0 ? void 0 : ctx.root.getElement();\n\n    if (container) {\n      let toFocus = this._tabster.focusable.findFirst({\n        container,\n        ignoreUncontrolled: true,\n        useActiveModalizer: true\n      });\n\n      if (toFocus) {\n        if (outsideElement.compareDocumentPosition(toFocus) & document.DOCUMENT_POSITION_PRECEDING) {\n          toFocus = this._tabster.focusable.findLast({\n            container,\n            ignoreUncontrolled: true,\n            useActiveModalizer: true\n          });\n\n          if (!toFocus) {\n            // This only might mean that findFirst/findLast are buggy and inconsistent.\n            throw new Error(\"Something went wrong.\");\n          }\n        }\n\n        this._tabster.focusedElement.focus(toFocus);\n\n        return;\n      }\n    } // Current Modalizer doesn't seem to have focusable elements.\n    // Blurring the currently focused element which is outside of the current Modalizer.\n\n\n    outsideElement.blur();\n  }\n\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nconst _inputSelector = /*#__PURE__*/[\"input\", \"textarea\", \"*[contenteditable]\"].join(\", \");\n\nclass MoverDummyManager extends DummyInputManager {\n  constructor(element, tabster, getMemorized, sys) {\n    super(tabster, element, DummyInputManagerPriorities.Mover, sys);\n\n    this._onFocusDummyInput = dummyInput => {\n      var _a, _b;\n\n      const container = this._element.get();\n\n      const input = dummyInput.input;\n\n      if (container && input) {\n        const ctx = RootAPI.getTabsterContext(this._tabster, container);\n        let toFocus;\n\n        if (ctx) {\n          toFocus = (_a = FocusedElementState.findNextTabbable(this._tabster, ctx, undefined, input, undefined, !dummyInput.isFirst, true)) === null || _a === void 0 ? void 0 : _a.element;\n        }\n\n        const memorized = (_b = this._getMemorized()) === null || _b === void 0 ? void 0 : _b.get();\n\n        if (memorized) {\n          toFocus = memorized;\n        }\n\n        if (toFocus) {\n          nativeFocus(toFocus);\n        }\n      }\n    };\n\n    this._tabster = tabster;\n    this._getMemorized = getMemorized;\n\n    this._setHandlers(this._onFocusDummyInput);\n  }\n\n} // TypeScript enums produce depressing JavaScript code, so, we're just using\n// a few old style constants here.\n\n\nconst _moverUpdateAdd = 1;\nconst _moverUpdateAttr = 2;\nconst _moverUpdateRemove = 3;\nclass Mover extends TabsterPart {\n  constructor(tabster, element, onDispose, props, sys) {\n    var _a;\n\n    super(tabster, element, props);\n    this._visible = {};\n\n    this._onIntersection = entries => {\n      for (const entry of entries) {\n        const el = entry.target;\n        const id = getElementUId(this._win, el);\n        let newVisibility;\n        let fullyVisible = this._fullyVisible;\n\n        if (entry.intersectionRatio >= 0.25) {\n          newVisibility = entry.intersectionRatio >= 0.75 ? Visibilities.Visible : Visibilities.PartiallyVisible;\n\n          if (newVisibility === Visibilities.Visible) {\n            fullyVisible = id;\n          }\n        } else {\n          newVisibility = Visibilities.Invisible;\n        }\n\n        if (this._visible[id] !== newVisibility) {\n          if (newVisibility === undefined) {\n            delete this._visible[id];\n\n            if (fullyVisible === id) {\n              delete this._fullyVisible;\n            }\n          } else {\n            this._visible[id] = newVisibility;\n            this._fullyVisible = fullyVisible;\n          }\n\n          const state = this.getState(el);\n\n          if (state) {\n            triggerEvent(el, MoverEventName, state);\n          }\n        }\n      }\n    };\n\n    this._win = tabster.getWindow;\n    this.visibilityTolerance = (_a = props.visibilityTolerance) !== null && _a !== void 0 ? _a : 0.8;\n\n    if (this._props.trackState || this._props.visibilityAware) {\n      this._intersectionObserver = new IntersectionObserver(this._onIntersection, {\n        threshold: [0, 0.25, 0.5, 0.75, 1]\n      });\n\n      this._observeState();\n    }\n\n    this._onDispose = onDispose;\n\n    const getMemorized = () => props.memorizeCurrent ? this._current : undefined;\n\n    if (!tabster.controlTab) {\n      this.dummyManager = new MoverDummyManager(this._element, tabster, getMemorized, sys);\n    }\n  }\n\n  dispose() {\n    var _a;\n\n    this._onDispose(this);\n\n    if (this._intersectionObserver) {\n      this._intersectionObserver.disconnect();\n\n      delete this._intersectionObserver;\n    }\n\n    delete this._current;\n    delete this._fullyVisible;\n    delete this._allElements;\n    delete this._updateQueue;\n\n    if (this._unobserve) {\n      this._unobserve();\n\n      delete this._unobserve;\n    }\n\n    const win = this._win();\n\n    if (this._setCurrentTimer) {\n      win.clearTimeout(this._setCurrentTimer);\n      delete this._setCurrentTimer;\n    }\n\n    if (this._updateTimer) {\n      win.clearTimeout(this._updateTimer);\n      delete this._updateTimer;\n    }\n\n    (_a = this.dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();\n  }\n\n  setCurrent(element) {\n    if (element) {\n      this._current = new WeakHTMLElement(this._win, element);\n    } else {\n      this._current = undefined;\n    }\n\n    if ((this._props.trackState || this._props.visibilityAware) && !this._setCurrentTimer) {\n      this._setCurrentTimer = this._win().setTimeout(() => {\n        var _a;\n\n        delete this._setCurrentTimer;\n        const changed = [];\n\n        if (this._current !== this._prevCurrent) {\n          changed.push(this._current);\n          changed.push(this._prevCurrent);\n          this._prevCurrent = this._current;\n        }\n\n        for (const weak of changed) {\n          const el = weak === null || weak === void 0 ? void 0 : weak.get();\n\n          if (el && ((_a = this._allElements) === null || _a === void 0 ? void 0 : _a.get(el)) === this) {\n            const props = this._props;\n\n            if (el && (props.visibilityAware !== undefined || props.trackState)) {\n              const state = this.getState(el);\n\n              if (state) {\n                triggerEvent(el, MoverEventName, state);\n              }\n            }\n          }\n        }\n      });\n    }\n  }\n\n  getCurrent() {\n    var _a;\n\n    return ((_a = this._current) === null || _a === void 0 ? void 0 : _a.get()) || null;\n  }\n\n  findNextTabbable(currentElement, referenceElement, isBackward, ignoreUncontrolled, ignoreAccessibility) {\n    var _a;\n\n    const container = this.getElement();\n    const currentIsDummy = container && ((_a = currentElement === null || currentElement === void 0 ? void 0 : currentElement.__tabsterDummyContainer) === null || _a === void 0 ? void 0 : _a.get()) === container;\n\n    if (!container) {\n      return null;\n    }\n\n    const tabster = this._tabster;\n    let next = null;\n    let uncontrolled;\n    let outOfDOMOrder = false;\n\n    const onUncontrolled = el => {\n      uncontrolled = el;\n    };\n\n    if (this._props.tabbable || currentIsDummy || currentElement && !container.contains(currentElement)) {\n      const findProps = {\n        currentElement,\n        referenceElement,\n        container,\n        onUncontrolled,\n        ignoreUncontrolled,\n        ignoreAccessibility,\n        useActiveModalizer: true\n      };\n      const findPropsOut = {};\n      next = tabster.focusable[isBackward ? \"findPrev\" : \"findNext\"](findProps, findPropsOut);\n      outOfDOMOrder = !!findPropsOut.outOfDOMOrder;\n    }\n\n    return {\n      element: next,\n      uncontrolled,\n      outOfDOMOrder\n    };\n  }\n\n  acceptElement(element, state) {\n    var _a, _b, _c;\n\n    if (!FocusedElementState.isTabbing) {\n      return ((_a = state.currentCtx) === null || _a === void 0 ? void 0 : _a.isExcludedFromMover) ? NodeFilter.FILTER_REJECT : undefined;\n    }\n\n    const {\n      memorizeCurrent,\n      visibilityAware,\n      hasDefault = true\n    } = this._props;\n    const moverElement = this.getElement();\n\n    if (moverElement && (memorizeCurrent || visibilityAware || hasDefault) && (!moverElement.contains(state.from) || ((_b = state.from.__tabsterDummyContainer) === null || _b === void 0 ? void 0 : _b.get()) === moverElement)) {\n      let found;\n\n      if (memorizeCurrent) {\n        const current = (_c = this._current) === null || _c === void 0 ? void 0 : _c.get();\n\n        if (current && state.acceptCondition(current)) {\n          found = current;\n        }\n      }\n\n      if (!found && hasDefault) {\n        found = this._tabster.focusable.findDefault({\n          container: moverElement,\n          ignoreUncontrolled: true,\n          useActiveModalizer: true\n        });\n      }\n\n      if (!found && visibilityAware) {\n        found = this._tabster.focusable.findElement({\n          container: moverElement,\n          ignoreUncontrolled: true,\n          useActiveModalizer: true,\n          isBackward: state.isBackward,\n          acceptCondition: el => {\n            var _a;\n\n            const id = getElementUId(this._win, el);\n            const visibility = this._visible[id];\n            return moverElement !== el && !!((_a = this._allElements) === null || _a === void 0 ? void 0 : _a.get(el)) && state.acceptCondition(el) && (visibility === Visibilities.Visible || visibility === Visibilities.PartiallyVisible && (visibilityAware === Visibilities.PartiallyVisible || !this._fullyVisible));\n          }\n        });\n      }\n\n      if (found) {\n        state.found = true;\n        state.foundElement = found;\n        state.lastToIgnore = moverElement;\n        state.skippedFocusable = true;\n        return NodeFilter.FILTER_ACCEPT;\n      }\n    }\n\n    return undefined;\n  }\n\n  _observeState() {\n    const element = this.getElement();\n\n    if (this._unobserve || !element || typeof MutationObserver === \"undefined\") {\n      return;\n    }\n\n    const win = this._win();\n\n    const allElements = this._allElements = new WeakMap();\n    const tabsterFocusable = this._tabster.focusable;\n    let updateQueue = this._updateQueue = [];\n    const observer = new MutationObserver(mutations => {\n      for (const mutation of mutations) {\n        const target = mutation.target;\n        const removed = mutation.removedNodes;\n        const added = mutation.addedNodes;\n\n        if (mutation.type === \"attributes\") {\n          if (mutation.attributeName === \"tabindex\") {\n            updateQueue.push({\n              element: target,\n              type: _moverUpdateAttr\n            });\n          }\n        } else {\n          for (let i = 0; i < removed.length; i++) {\n            updateQueue.push({\n              element: removed[i],\n              type: _moverUpdateRemove\n            });\n          }\n\n          for (let i = 0; i < added.length; i++) {\n            updateQueue.push({\n              element: added[i],\n              type: _moverUpdateAdd\n            });\n          }\n        }\n      }\n\n      requestUpdate();\n    });\n\n    const setElement = (element, remove) => {\n      var _a, _b;\n\n      const current = allElements.get(element);\n\n      if (current && remove) {\n        (_a = this._intersectionObserver) === null || _a === void 0 ? void 0 : _a.unobserve(element);\n        allElements.delete(element);\n      }\n\n      if (!current && !remove) {\n        allElements.set(element, this);\n        (_b = this._intersectionObserver) === null || _b === void 0 ? void 0 : _b.observe(element);\n      }\n    };\n\n    const updateElement = element => {\n      const isFocusable = tabsterFocusable.isFocusable(element);\n      const current = allElements.get(element);\n\n      if (current) {\n        if (!isFocusable) {\n          setElement(element, true);\n        }\n      } else {\n        if (isFocusable) {\n          setElement(element);\n        }\n      }\n    };\n\n    const addNewElements = element => {\n      const {\n        mover\n      } = getMoverGroupper(element);\n\n      if (mover && mover !== this) {\n        if (mover.getElement() === element && tabsterFocusable.isFocusable(element)) {\n          setElement(element);\n        } else {\n          return;\n        }\n      }\n\n      const walker = createElementTreeWalker(win.document, element, node => {\n        const {\n          mover,\n          groupper\n        } = getMoverGroupper(node);\n\n        if (mover && mover !== this) {\n          return NodeFilter.FILTER_REJECT;\n        }\n\n        const groupperFirstFocusable = groupper === null || groupper === void 0 ? void 0 : groupper.getFirst(true);\n\n        if (groupper && groupper.getElement() !== node && groupperFirstFocusable && groupperFirstFocusable !== node) {\n          return NodeFilter.FILTER_REJECT;\n        }\n\n        if (tabsterFocusable.isFocusable(node)) {\n          setElement(node);\n        }\n\n        return NodeFilter.FILTER_SKIP;\n      });\n\n      if (walker) {\n        walker.currentNode = element;\n\n        while (walker.nextNode()) {\n          /* Iterating for the sake of calling processNode() callback. */\n        }\n      }\n    };\n\n    const removeWalk = element => {\n      const current = allElements.get(element);\n\n      if (current) {\n        setElement(element, true);\n      }\n\n      for (let el = element.firstElementChild; el; el = el.nextElementSibling) {\n        removeWalk(el);\n      }\n    };\n\n    const requestUpdate = () => {\n      if (!this._updateTimer && updateQueue.length) {\n        this._updateTimer = win.setTimeout(() => {\n          delete this._updateTimer;\n\n          for (const {\n            element,\n            type\n          } of updateQueue) {\n            switch (type) {\n              case _moverUpdateAttr:\n                updateElement(element);\n                break;\n\n              case _moverUpdateAdd:\n                addNewElements(element);\n                break;\n\n              case _moverUpdateRemove:\n                removeWalk(element);\n                break;\n            }\n          }\n\n          updateQueue = this._updateQueue = [];\n        }, 0);\n      }\n    };\n\n    const getMoverGroupper = element => {\n      const ret = {};\n\n      for (let el = element; el; el = el.parentElement) {\n        const toe = getTabsterOnElement(this._tabster, el);\n\n        if (toe) {\n          if (toe.groupper && !ret.groupper) {\n            ret.groupper = toe.groupper;\n          }\n\n          if (toe.mover) {\n            ret.mover = toe.mover;\n            break;\n          }\n        }\n      }\n\n      return ret;\n    };\n\n    updateQueue.push({\n      element,\n      type: _moverUpdateAdd\n    });\n    requestUpdate();\n    observer.observe(element, {\n      childList: true,\n      subtree: true,\n      attributes: true,\n      attributeFilter: [\"tabindex\"]\n    });\n\n    this._unobserve = () => {\n      observer.disconnect();\n    };\n  }\n\n  getState(element) {\n    const id = getElementUId(this._win, element);\n\n    if (id in this._visible) {\n      const visibility = this._visible[id] || Visibilities.Invisible;\n      const isCurrent = this._current ? this._current.get() === element : undefined;\n      return {\n        isCurrent,\n        visibility\n      };\n    }\n\n    return undefined;\n  }\n\n} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n/**\r\n * Calculates distance between two rectangles.\r\n *\r\n * @param ax1 first rectangle left\r\n * @param ay1 first rectangle top\r\n * @param ax2 first rectangle right\r\n * @param ay2 first rectangle bottom\r\n * @param bx1 second rectangle left\r\n * @param by1 second rectangle top\r\n * @param bx2 second rectangle right\r\n * @param by2 second rectangle bottom\r\n * @returns number, shortest distance between the rectangles.\r\n */\n\n\nfunction getDistance(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {\n  const xDistance = ax2 < bx1 ? bx1 - ax2 : bx2 < ax1 ? ax1 - bx2 : 0;\n  const yDistance = ay2 < by1 ? by1 - ay2 : by2 < ay1 ? ay1 - by2 : 0;\n  return xDistance === 0 ? yDistance : yDistance === 0 ? xDistance : Math.sqrt(xDistance * xDistance + yDistance * yDistance);\n}\n\nclass MoverAPI {\n  constructor(tabster, getWindow) {\n    this._init = () => {\n      const win = this._win();\n\n      win.addEventListener(\"keydown\", this._onKeyDown, true);\n\n      this._tabster.focusedElement.subscribe(this._onFocus);\n    };\n\n    this._onMoverDispose = mover => {\n      delete this._movers[mover.id];\n    };\n\n    this._onFocus = e => {\n      var _a;\n\n      for (let el = e; el; el = el.parentElement) {\n        const mover = (_a = getTabsterOnElement(this._tabster, el)) === null || _a === void 0 ? void 0 : _a.mover;\n\n        if (mover) {\n          mover.setCurrent(e);\n          break;\n        }\n      }\n    };\n\n    this._onKeyDown = async event => {\n      var _a, _b, _c, _d;\n\n      if (this._ignoredInputTimer) {\n        this._win().clearTimeout(this._ignoredInputTimer);\n\n        delete this._ignoredInputTimer;\n      }\n\n      (_a = this._ignoredInputResolve) === null || _a === void 0 ? void 0 : _a.call(this, false);\n      let keyCode = event.keyCode; // Give a chance to other listeners to handle the event (for example,\n      // to scroll instead of moving focus).\n\n      if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {\n        return;\n      }\n\n      switch (keyCode) {\n        case Keys.Down:\n        case Keys.Right:\n        case Keys.Up:\n        case Keys.Left:\n        case Keys.PageDown:\n        case Keys.PageUp:\n        case Keys.Home:\n        case Keys.End:\n          break;\n\n        default:\n          return;\n      }\n\n      const tabster = this._tabster;\n      const focused = tabster.focusedElement.getFocusedElement();\n\n      if (!focused || (await this._isIgnoredInput(focused, keyCode))) {\n        return;\n      }\n\n      const ctx = RootAPI.getTabsterContext(tabster, focused, {\n        checkRtl: true\n      });\n\n      if (!ctx || !ctx.mover || ctx.isExcludedFromMover || ctx.ignoreKeydown(event)) {\n        return;\n      }\n\n      const mover = ctx.mover;\n      const container = mover.getElement();\n\n      if (ctx.isGroupperFirst) {\n        const groupper = ctx.groupper;\n\n        if (groupper && !groupper.isActive(true)) {\n          // For the cases when we have Mover/Active Groupper/Inactive Groupper, we need to check\n          // the grouppers between the current element and the current mover.\n          for (let el = (_b = groupper.getElement()) === null || _b === void 0 ? void 0 : _b.parentElement; el && el !== container; el = el.parentElement) {\n            if ((_d = (_c = getTabsterOnElement(tabster, el)) === null || _c === void 0 ? void 0 : _c.groupper) === null || _d === void 0 ? void 0 : _d.isActive(true)) {\n              return;\n            }\n          }\n        } else {\n          return;\n        }\n      }\n\n      if (!container) {\n        return;\n      }\n\n      const focusable = tabster.focusable;\n      const moverProps = mover.getProps();\n      const direction = moverProps.direction || MoverDirections.Both;\n      const isBoth = direction === MoverDirections.Both;\n      const isVertical = isBoth || direction === MoverDirections.Vertical;\n      const isHorizontal = isBoth || direction === MoverDirections.Horizontal;\n      const isGridLinear = direction === MoverDirections.GridLinear;\n      const isGrid = isGridLinear || direction === MoverDirections.Grid;\n      const isCyclic = moverProps.cyclic;\n      let next;\n      let focusedElementRect;\n      let focusedElementX1 = 0;\n      let focusedElementX2 = 0;\n\n      if (isGrid) {\n        focusedElementRect = focused.getBoundingClientRect();\n        focusedElementX1 = Math.ceil(focusedElementRect.left);\n        focusedElementX2 = Math.floor(focusedElementRect.right);\n      }\n\n      if (ctx.isRtl) {\n        if (keyCode === Keys.Right) {\n          keyCode = Keys.Left;\n        } else if (keyCode === Keys.Left) {\n          keyCode = Keys.Right;\n        }\n      }\n\n      if (keyCode === Keys.Down && isVertical || keyCode === Keys.Right && (isHorizontal || isGrid)) {\n        next = focusable.findNext({\n          currentElement: focused,\n          container,\n          useActiveModalizer: true\n        });\n\n        if (next && isGrid) {\n          const nextElementX1 = Math.ceil(next.getBoundingClientRect().left);\n\n          if (!isGridLinear && focusedElementX2 > nextElementX1) {\n            next = undefined;\n          }\n        } else if (!next && isCyclic) {\n          next = focusable.findFirst({\n            container,\n            ignoreUncontrolled: true,\n            useActiveModalizer: true\n          });\n        }\n      } else if (keyCode === Keys.Up && isVertical || keyCode === Keys.Left && (isHorizontal || isGrid)) {\n        next = focusable.findPrev({\n          currentElement: focused,\n          container,\n          useActiveModalizer: true\n        });\n\n        if (next && isGrid) {\n          const nextElementX2 = Math.floor(next.getBoundingClientRect().right);\n\n          if (!isGridLinear && nextElementX2 > focusedElementX1) {\n            next = undefined;\n          }\n        } else if (!next && isCyclic) {\n          next = focusable.findLast({\n            container,\n            ignoreUncontrolled: true,\n            useActiveModalizer: true\n          });\n        }\n      } else if (keyCode === Keys.Home) {\n        if (isGrid) {\n          focusable.findElement({\n            container,\n            currentElement: focused,\n            ignoreUncontrolled: true,\n            useActiveModalizer: true,\n            isBackward: true,\n            acceptCondition: el => {\n              var _a;\n\n              if (!focusable.isFocusable(el)) {\n                return false;\n              }\n\n              const nextElementX1 = Math.ceil((_a = el.getBoundingClientRect().left) !== null && _a !== void 0 ? _a : 0);\n\n              if (el !== focused && focusedElementX1 <= nextElementX1) {\n                return true;\n              }\n\n              next = el;\n              return false;\n            }\n          });\n        } else {\n          next = focusable.findFirst({\n            container,\n            ignoreUncontrolled: true,\n            useActiveModalizer: true\n          });\n        }\n      } else if (keyCode === Keys.End) {\n        if (isGrid) {\n          focusable.findElement({\n            container,\n            currentElement: focused,\n            ignoreUncontrolled: true,\n            useActiveModalizer: true,\n            acceptCondition: el => {\n              var _a;\n\n              if (!focusable.isFocusable(el)) {\n                return false;\n              }\n\n              const nextElementX1 = Math.ceil((_a = el.getBoundingClientRect().left) !== null && _a !== void 0 ? _a : 0);\n\n              if (el !== focused && focusedElementX1 >= nextElementX1) {\n                return true;\n              }\n\n              next = el;\n              return false;\n            }\n          });\n        } else {\n          next = focusable.findLast({\n            container,\n            ignoreUncontrolled: true,\n            useActiveModalizer: true\n          });\n        }\n      } else if (keyCode === Keys.PageUp) {\n        focusable.findElement({\n          currentElement: focused,\n          container,\n          useActiveModalizer: true,\n          isBackward: true,\n          acceptCondition: el => {\n            if (!focusable.isFocusable(el)) {\n              return false;\n            }\n\n            if (isElementVerticallyVisibleInContainer(this._win, el, mover.visibilityTolerance)) {\n              next = el;\n              return false;\n            }\n\n            return true;\n          }\n        }); // will be on the first column move forward and preserve previous column\n\n        if (isGrid && next) {\n          const firstColumnX1 = Math.ceil(next.getBoundingClientRect().left);\n          focusable.findElement({\n            currentElement: next,\n            container,\n            useActiveModalizer: true,\n            acceptCondition: el => {\n              if (!focusable.isFocusable(el)) {\n                return false;\n              }\n\n              const nextElementX1 = Math.ceil(el.getBoundingClientRect().left);\n\n              if (focusedElementX1 < nextElementX1 || firstColumnX1 >= nextElementX1) {\n                return true;\n              }\n\n              next = el;\n              return false;\n            }\n          });\n        }\n\n        if (next) {\n          scrollIntoView(this._win, next, false);\n        }\n      } else if (keyCode === Keys.PageDown) {\n        focusable.findElement({\n          currentElement: focused,\n          container,\n          useActiveModalizer: true,\n          acceptCondition: el => {\n            if (!focusable.isFocusable(el)) {\n              return false;\n            }\n\n            if (isElementVerticallyVisibleInContainer(this._win, el, mover.visibilityTolerance)) {\n              next = el;\n              return false;\n            }\n\n            return true;\n          }\n        }); // will be on the last column move backwards and preserve previous column\n\n        if (isGrid && next) {\n          const lastColumnX1 = Math.ceil(next.getBoundingClientRect().left);\n          focusable.findElement({\n            currentElement: next,\n            container,\n            useActiveModalizer: true,\n            isBackward: true,\n            acceptCondition: el => {\n              if (!focusable.isFocusable(el)) {\n                return false;\n              }\n\n              const nextElementX1 = Math.ceil(el.getBoundingClientRect().left);\n\n              if (focusedElementX1 > nextElementX1 || lastColumnX1 <= nextElementX1) {\n                return true;\n              }\n\n              next = el;\n              return false;\n            }\n          });\n        }\n\n        if (next) {\n          scrollIntoView(this._win, next, true);\n        }\n      } else if (isGrid) {\n        const isBackward = keyCode === Keys.Up;\n        const ax1 = focusedElementX1; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n        const ay1 = Math.ceil(focusedElementRect.top);\n        const ax2 = focusedElementX2; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n        const ay2 = Math.floor(focusedElementRect.bottom);\n        let targetElement;\n        let lastDistance;\n        let lastIntersection = 0;\n        focusable.findAll({\n          container,\n          currentElement: focused,\n          isBackward,\n          onElement: el => {\n            // Find element which has maximal intersection with the focused element horizontally,\n            // or the closest one.\n            const rect = el.getBoundingClientRect();\n            const bx1 = Math.ceil(rect.left);\n            const by1 = Math.ceil(rect.top);\n            const bx2 = Math.floor(rect.right);\n            const by2 = Math.floor(rect.bottom);\n\n            if (isBackward && ay1 < by2 || !isBackward && ay2 > by1) {\n              // Only consider elements which are below/above curretly focused.\n              return true;\n            }\n\n            const xIntersectionWidth = Math.ceil(Math.min(ax2, bx2)) - Math.floor(Math.max(ax1, bx1));\n            const minWidth = Math.ceil(Math.min(ax2 - ax1, bx2 - bx1));\n\n            if (xIntersectionWidth > 0 && minWidth >= xIntersectionWidth) {\n              // Element intersects with the focused element on X axis.\n              const intersection = xIntersectionWidth / minWidth;\n\n              if (intersection > lastIntersection) {\n                targetElement = el;\n                lastIntersection = intersection;\n              }\n            } else if (lastIntersection === 0) {\n              // If we didn't have intersection, try just the closest one.\n              const distance = getDistance(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2);\n\n              if (lastDistance === undefined || distance < lastDistance) {\n                lastDistance = distance;\n                targetElement = el;\n              }\n            } else if (lastIntersection > 0) {\n              // Element doesn't intersect, but we had intersection already, stop search.\n              return false;\n            }\n\n            return true;\n          }\n        });\n        next = targetElement;\n      }\n\n      if (next) {\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        nativeFocus(next);\n      }\n    };\n\n    this._tabster = tabster;\n    this._win = getWindow;\n    this._movers = {};\n    tabster.queueInit(this._init);\n  }\n\n  dispose() {\n    var _a;\n\n    const win = this._win();\n\n    this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n    (_a = this._ignoredInputResolve) === null || _a === void 0 ? void 0 : _a.call(this, false);\n\n    if (this._ignoredInputTimer) {\n      win.clearTimeout(this._ignoredInputTimer);\n      delete this._ignoredInputTimer;\n    }\n\n    win.removeEventListener(\"keydown\", this._onKeyDown, true);\n    Object.keys(this._movers).forEach(moverId => {\n      if (this._movers[moverId]) {\n        this._movers[moverId].dispose();\n\n        delete this._movers[moverId];\n      }\n    });\n  }\n\n  createMover(element, props, sys) {\n    if (process.env.NODE_ENV === 'development') ;\n\n    const newMover = new Mover(this._tabster, element, this._onMoverDispose, props, sys);\n    this._movers[newMover.id] = newMover;\n    return newMover;\n  }\n\n  async _isIgnoredInput(element, keyCode) {\n    var _a;\n\n    if (element.getAttribute(\"aria-expanded\") === \"true\") {\n      return true;\n    }\n\n    if (matchesSelector(element, _inputSelector)) {\n      let selectionStart = 0;\n      let selectionEnd = 0;\n      let textLength = 0;\n      let asyncRet;\n\n      if (element.tagName === \"INPUT\" || element.tagName === \"TEXTAREA\") {\n        const type = element.type;\n        const value = element.value;\n        textLength = (value || \"\").length;\n\n        if (type === \"email\" || type === \"number\") {\n          // For these types Chromium doesn't provide selectionStart and selectionEnd.\n          // Hence the ugly workaround to find if the caret position is changed with\n          // the keypress.\n          // TODO: Have a look at range, week, time, time, date, datetime-local.\n          if (textLength) {\n            const selection = (_a = element.ownerDocument.defaultView) === null || _a === void 0 ? void 0 : _a.getSelection();\n\n            if (selection) {\n              const initialLength = selection.toString().length;\n              const isBackward = keyCode === Keys.Left || keyCode === Keys.Up;\n              selection.modify(\"extend\", isBackward ? \"backward\" : \"forward\", \"character\");\n\n              if (initialLength !== selection.toString().length) {\n                // The caret is moved, so, we're not on the edge of the value.\n                // Restore original selection.\n                selection.modify(\"extend\", isBackward ? \"forward\" : \"backward\", \"character\");\n                return true;\n              } else {\n                textLength = 0;\n              }\n            }\n          }\n        } else {\n          const selStart = element.selectionStart;\n\n          if (selStart === null) {\n            // Do not ignore not text editable inputs like checkboxes and radios (but ignore hidden).\n            return type === \"hidden\";\n          }\n\n          selectionStart = selStart || 0;\n          selectionEnd = element.selectionEnd || 0;\n        }\n      } else if (element.contentEditable === \"true\") {\n        asyncRet = new (getPromise(this._win))(resolve => {\n          this._ignoredInputResolve = value => {\n            delete this._ignoredInputResolve;\n            resolve(value);\n          };\n\n          const win = this._win();\n\n          if (this._ignoredInputTimer) {\n            win.clearTimeout(this._ignoredInputTimer);\n          }\n\n          const {\n            anchorNode: prevAnchorNode,\n            focusNode: prevFocusNode,\n            anchorOffset: prevAnchorOffset,\n            focusOffset: prevFocusOffset\n          } = win.getSelection() || {}; // Get selection gives incorrect value if we call it syncronously onKeyDown.\n\n          this._ignoredInputTimer = win.setTimeout(() => {\n            var _a, _b, _c;\n\n            delete this._ignoredInputTimer;\n            const {\n              anchorNode,\n              focusNode,\n              anchorOffset,\n              focusOffset\n            } = win.getSelection() || {};\n\n            if (anchorNode !== prevAnchorNode || focusNode !== prevFocusNode || anchorOffset !== prevAnchorOffset || focusOffset !== prevFocusOffset) {\n              (_a = this._ignoredInputResolve) === null || _a === void 0 ? void 0 : _a.call(this, false);\n              return;\n            }\n\n            selectionStart = anchorOffset || 0;\n            selectionEnd = focusOffset || 0;\n            textLength = ((_b = element.textContent) === null || _b === void 0 ? void 0 : _b.length) || 0;\n\n            if (anchorNode && focusNode) {\n              if (element.contains(anchorNode) && element.contains(focusNode)) {\n                if (anchorNode !== element) {\n                  let anchorFound = false;\n\n                  const addOffsets = node => {\n                    if (node === anchorNode) {\n                      anchorFound = true;\n                    } else if (node === focusNode) {\n                      return true;\n                    }\n\n                    const nodeText = node.textContent;\n\n                    if (nodeText && !node.firstChild) {\n                      const len = nodeText.length;\n\n                      if (anchorFound) {\n                        if (focusNode !== anchorNode) {\n                          selectionEnd += len;\n                        }\n                      } else {\n                        selectionStart += len;\n                        selectionEnd += len;\n                      }\n                    }\n\n                    let stop = false;\n\n                    for (let e = node.firstChild; e && !stop; e = e.nextSibling) {\n                      stop = addOffsets(e);\n                    }\n\n                    return stop;\n                  };\n\n                  addOffsets(element);\n                }\n              }\n            }\n\n            (_c = this._ignoredInputResolve) === null || _c === void 0 ? void 0 : _c.call(this, true);\n          }, 0);\n        });\n      }\n\n      if (asyncRet && !(await asyncRet)) {\n        return true;\n      }\n\n      if (selectionStart !== selectionEnd) {\n        return true;\n      }\n\n      if (selectionStart > 0 && (keyCode === Keys.Left || keyCode === Keys.Up || keyCode === Keys.Home)) {\n        return true;\n      }\n\n      if (selectionStart < textLength && (keyCode === Keys.Right || keyCode === Keys.Down || keyCode === Keys.End)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nfunction observeMutations(doc, tabster, updateTabsterByAttribute, syncState) {\n  if (typeof MutationObserver === \"undefined\") {\n    return () => {\n      /* Noop */\n    };\n  }\n\n  const getWindow = tabster.getWindow;\n  let elementByUId;\n\n  const onMutation = mutations => {\n    var _a, _b, _c, _d, _e;\n\n    for (const mutation of mutations) {\n      const target = mutation.target;\n      const removed = mutation.removedNodes;\n      const added = mutation.addedNodes;\n\n      if (mutation.type === \"attributes\") {\n        if (mutation.attributeName === TabsterAttributeName) {\n          updateTabsterByAttribute(tabster, target);\n        }\n      } else {\n        for (let i = 0; i < removed.length; i++) {\n          updateTabsterElements(removed[i], true);\n          (_b = (_a = tabster._dummyObserver).domChanged) === null || _b === void 0 ? void 0 : _b.call(_a, target);\n        }\n\n        for (let i = 0; i < added.length; i++) {\n          updateTabsterElements(added[i]);\n          (_d = (_c = tabster._dummyObserver).domChanged) === null || _d === void 0 ? void 0 : _d.call(_c, target);\n        }\n      }\n    }\n\n    (_e = tabster.modalizer) === null || _e === void 0 ? void 0 : _e.hiddenUpdate();\n  };\n\n  function updateTabsterElements(node, removed) {\n    if (!elementByUId) {\n      elementByUId = getInstanceContext(getWindow).elementByUId;\n    }\n\n    processNode(node, removed);\n    const walker = createElementTreeWalker(doc, node, element => {\n      return processNode(element, removed);\n    });\n\n    if (walker) {\n      while (walker.nextNode()) {\n        /* Iterating for the sake of calling processNode() callback. */\n      }\n    }\n  }\n\n  function processNode(element, removed) {\n    var _a;\n\n    if (!element.getAttribute) {\n      // It might actually be a text node.\n      return NodeFilter.FILTER_SKIP;\n    }\n\n    const uid = element.__tabsterElementUID;\n\n    if (uid && elementByUId) {\n      if (removed) {\n        delete elementByUId[uid];\n      } else {\n        (_a = elementByUId[uid]) !== null && _a !== void 0 ? _a : elementByUId[uid] = new WeakHTMLElement(getWindow, element);\n      }\n    }\n\n    if (getTabsterOnElement(tabster, element) || element.hasAttribute(TabsterAttributeName)) {\n      updateTabsterByAttribute(tabster, element, removed);\n    }\n\n    return NodeFilter.FILTER_SKIP;\n  }\n\n  const observer = new MutationObserver(onMutation);\n\n  if (syncState) {\n    updateTabsterElements(getWindow().document.body);\n  }\n\n  observer.observe(doc, {\n    childList: true,\n    subtree: true,\n    attributes: true,\n    attributeFilter: [TabsterAttributeName]\n  });\n  return () => {\n    observer.disconnect();\n  };\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst _conditionCheckTimeout = 100;\nclass ObservedElementAPI extends Subscribable {\n  constructor(tabster) {\n    super();\n    this._waiting = {};\n    this._lastRequestFocusId = 0;\n    this._observedById = {};\n    this._observedByName = {};\n    this._currentRequestTimestamp = 0;\n\n    this._onFocus = e => {\n      if (e) {\n        const current = this._currentRequest;\n\n        if (current) {\n          const delta = Date.now() - this._currentRequestTimestamp;\n\n          const settleTime = 300;\n\n          if (delta >= settleTime) {\n            // Giving some time for the focus to settle before\n            // automatically cancelling the current request on focus change.\n            delete this._currentRequest;\n            current.cancel();\n          }\n        }\n      }\n    };\n\n    this.onObservedElementUpdate = element => {\n      var _a;\n\n      const observed = (_a = getTabsterOnElement(this._tabster, element)) === null || _a === void 0 ? void 0 : _a.observed;\n      const uid = getElementUId(this._win, element);\n      let info = this._observedById[uid];\n\n      if (observed && documentContains(element.ownerDocument, element)) {\n        if (!info) {\n          info = this._observedById[uid] = {\n            element: new WeakHTMLElement(this._win, element)\n          };\n        }\n\n        observed.names.sort();\n        const observedNames = observed.names;\n        const prevNames = info.prevNames; // prevNames are already sorted\n\n        if (this._isObservedNamesUpdated(observedNames, prevNames)) {\n          if (prevNames) {\n            prevNames.forEach(prevName => {\n              const obn = this._observedByName[prevName];\n\n              if (obn && obn[uid]) {\n                if (Object.keys(obn).length > 1) {\n                  delete obn[uid];\n                } else {\n                  delete this._observedByName[prevName];\n                }\n              }\n            });\n          }\n\n          info.prevNames = observedNames;\n        }\n\n        observedNames.forEach(observedName => {\n          let obn = this._observedByName[observedName];\n\n          if (!obn) {\n            obn = this._observedByName[observedName] = {};\n          } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n\n          obn[uid] = info;\n\n          this._waitConditional(observedName);\n        });\n      } else if (info) {\n        const prevNames = info.prevNames;\n\n        if (prevNames) {\n          prevNames.forEach(prevName => {\n            const obn = this._observedByName[prevName];\n\n            if (obn && obn[uid]) {\n              if (Object.keys(obn).length > 1) {\n                delete obn[uid];\n              } else {\n                delete this._observedByName[prevName];\n              }\n            }\n          });\n        }\n\n        delete this._observedById[uid];\n      }\n    };\n\n    this._tabster = tabster;\n    this._win = tabster.getWindow;\n    tabster.queueInit(() => {\n      this._tabster.focusedElement.subscribe(this._onFocus);\n    });\n  }\n\n  dispose() {\n    this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n    for (const key of Object.keys(this._waiting)) {\n      this._rejectWaiting(key);\n    }\n\n    this._observedById = {};\n    this._observedByName = {};\n  }\n\n  _rejectWaiting(key, shouldResolve) {\n    const w = this._waiting[key];\n\n    if (w) {\n      const win = this._win();\n\n      if (w.timer) {\n        win.clearTimeout(w.timer);\n      }\n\n      if (w.conditionTimer) {\n        win.clearTimeout(w.conditionTimer);\n      }\n\n      if (!shouldResolve && w.reject) {\n        w.reject();\n      } else if (shouldResolve && w.resolve) {\n        w.resolve(null);\n      }\n\n      delete this._waiting[key];\n    }\n  }\n\n  _isObservedNamesUpdated(cur, prev) {\n    if (!prev || cur.length !== prev.length) {\n      return true;\n    }\n\n    for (let i = 0; i < cur.length; ++i) {\n      if (cur[i] !== prev[i]) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\r\n   * Returns existing element by observed name\r\n   *\r\n   * @param observedName An observed name\r\n   * @param accessibility Optionally, return only if the element is accessible or focusable\r\n   * @returns HTMLElement | null\r\n   */\n\n\n  getElement(observedName, accessibility) {\n    const o = this._observedByName[observedName];\n\n    if (o) {\n      for (const uid of Object.keys(o)) {\n        let el = o[uid].element.get() || null;\n\n        if (el) {\n          if (accessibility === ObservedElementAccesibilities.Accessible && !this._tabster.focusable.isAccessible(el) || accessibility === ObservedElementAccesibilities.Focusable && !this._tabster.focusable.isFocusable(el, true)) {\n            el = null;\n          }\n        } else {\n          delete o[uid];\n          delete this._observedById[uid];\n        }\n\n        return el;\n      }\n    }\n\n    return null;\n  }\n  /**\r\n   * Waits for the element to appear in the DOM and returns it.\r\n   *\r\n   * @param observedName An observed name\r\n   * @param timeout Wait no longer than this timeout\r\n   * @param accessibility Optionally, wait for the element to also become accessible or focusable before returning it\r\n   * @returns Promise<HTMLElement | null>\r\n   */\n\n\n  waitElement(observedName, timeout, accessibility) {\n    const el = this.getElement(observedName, accessibility);\n\n    if (el) {\n      return {\n        result: getPromise(this._win).resolve(el),\n        cancel: () => {\n          /**/\n        }\n      };\n    }\n\n    let prefix;\n\n    if (accessibility === ObservedElementAccesibilities.Accessible) {\n      prefix = \"a\";\n    } else if (accessibility === ObservedElementAccesibilities.Focusable) {\n      prefix = \"f\";\n    } else {\n      prefix = \"_\";\n    }\n\n    const key = prefix + observedName;\n    let w = this._waiting[key];\n\n    if (w && w.request) {\n      return w.request;\n    }\n\n    w = this._waiting[key] = {\n      timer: this._win().setTimeout(() => {\n        if (w.conditionTimer) {\n          this._win().clearTimeout(w.conditionTimer);\n        }\n\n        delete this._waiting[key];\n\n        if (w.resolve) {\n          w.resolve(null);\n        }\n      }, timeout)\n    };\n    const promise = new (getPromise(this._win))((resolve, reject) => {\n      w.resolve = resolve;\n      w.reject = reject;\n    });\n    w.request = {\n      result: promise,\n      cancel: () => {\n        this._rejectWaiting(key, true);\n      }\n    };\n\n    if (accessibility && this.getElement(observedName)) {\n      // If the observed element is alread in DOM, but not accessible yet,\n      // we need to run the wait logic.\n      this._waitConditional(observedName);\n    }\n\n    return w.request;\n  }\n\n  requestFocus(observedName, timeout) {\n    const requestId = ++this._lastRequestFocusId;\n    const currentRequestFocus = this._currentRequest;\n\n    if (currentRequestFocus) {\n      currentRequestFocus.cancel();\n    }\n\n    const request = this.waitElement(observedName, timeout, ObservedElementAccesibilities.Focusable);\n    this._currentRequest = request;\n    this._currentRequestTimestamp = Date.now();\n    request.result.finally(() => {\n      if (this._currentRequest === request) {\n        delete this._currentRequest;\n      }\n    });\n    return {\n      result: request.result.then(element => this._lastRequestFocusId === requestId && element ? this._tabster.focusedElement.focus(element, true) : false),\n      cancel: () => {\n        request.cancel();\n      }\n    };\n  }\n\n  _waitConditional(observedName) {\n    const waitingElementKey = \"_\" + observedName;\n    const waitingAccessibleElementKey = \"a\" + observedName;\n    const waitingFocusableElementKey = \"f\" + observedName;\n    const waitingElement = this._waiting[waitingElementKey];\n    const waitingAccessibleElement = this._waiting[waitingAccessibleElementKey];\n    const waitingFocusableElement = this._waiting[waitingFocusableElementKey];\n\n    const win = this._win();\n\n    const resolve = (element, key, waiting, accessibility) => {\n      var _a;\n\n      const observed = (_a = getTabsterOnElement(this._tabster, element)) === null || _a === void 0 ? void 0 : _a.observed;\n\n      if (!observed || !observed.names.includes(observedName)) {\n        return;\n      }\n\n      if (waiting.timer) {\n        win.clearTimeout(waiting.timer);\n      }\n\n      delete this._waiting[key];\n\n      if (waiting.resolve) {\n        waiting.resolve(element);\n      }\n\n      this.trigger(element, {\n        names: [observedName],\n        details: observed.details,\n        accessibility\n      });\n    };\n\n    if (waitingElement) {\n      const element = this.getElement(observedName);\n\n      if (element && documentContains(element.ownerDocument, element)) {\n        resolve(element, waitingElementKey, waitingElement, ObservedElementAccesibilities.Any);\n      }\n    }\n\n    if (waitingAccessibleElement && !waitingAccessibleElement.conditionTimer) {\n      const resolveAccessible = () => {\n        const element = this.getElement(observedName);\n\n        if (element && documentContains(element.ownerDocument, element) && this._tabster.focusable.isAccessible(element)) {\n          resolve(element, waitingAccessibleElementKey, waitingAccessibleElement, ObservedElementAccesibilities.Accessible);\n        } else {\n          waitingAccessibleElement.conditionTimer = win.setTimeout(resolveAccessible, _conditionCheckTimeout);\n        }\n      };\n\n      resolveAccessible();\n    }\n\n    if (waitingFocusableElement && !waitingFocusableElement.conditionTimer) {\n      const resolveFocusable = () => {\n        const element = this.getElement(observedName);\n\n        if (element && documentContains(element.ownerDocument, element) && this._tabster.focusable.isFocusable(element, true)) {\n          resolve(element, waitingFocusableElementKey, waitingFocusableElement, ObservedElementAccesibilities.Focusable);\n        } else {\n          waitingFocusableElement.conditionTimer = win.setTimeout(resolveFocusable, _conditionCheckTimeout);\n        }\n      };\n\n      resolveFocusable();\n    }\n  }\n\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst defaultProps = {\n  areaClass: \"tabster-focus-outline-area\",\n  outlineClass: \"tabster-focus-outline\",\n  outlineColor: \"#ff4500\",\n  outlineWidth: 2,\n  zIndex: 2147483647\n};\nlet _props = defaultProps;\n\nclass OutlinePosition {\n  constructor(left, top, right, bottom) {\n    this.left = left;\n    this.top = top;\n    this.right = right;\n    this.bottom = bottom;\n  }\n\n  equalsTo(other) {\n    return this.left === other.left && this.top === other.top && this.right === other.right && this.bottom === other.bottom;\n  }\n\n  clone() {\n    return new OutlinePosition(this.left, this.top, this.right, this.bottom);\n  }\n\n}\n\nclass OutlineAPI {\n  constructor(tabster) {\n    this._isVisible = false;\n    this._allOutlineElements = [];\n\n    this._init = () => {\n      this._tabster.keyboardNavigation.subscribe(this._onKeyboardNavigationStateChanged);\n\n      this._tabster.focusedElement.subscribe(this._onFocus);\n\n      const win = this._win();\n\n      win.addEventListener(\"scroll\", this._onScroll, true); // Capture!\n\n      if (this._fullScreenEventName) {\n        win.document.addEventListener(this._fullScreenEventName, this._onFullScreenChanged);\n      }\n    };\n\n    this._onFullScreenChanged = e => {\n      if (!this._fullScreenElementName || !e.target) {\n        return;\n      }\n\n      const target = e.target.body || e.target;\n\n      const outlineElements = this._getDOM(target);\n\n      if (target.ownerDocument && outlineElements) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const fsElement = target.ownerDocument[this._fullScreenElementName];\n\n        if (fsElement) {\n          fsElement.appendChild(outlineElements.container);\n          this._fullScreenElement = fsElement;\n        } else {\n          target.ownerDocument.body.appendChild(outlineElements.container);\n          this._fullScreenElement = undefined;\n        }\n      }\n    };\n\n    this._onKeyboardNavigationStateChanged = () => {\n      this._onFocus(this._tabster.focusedElement.getFocusedElement());\n    };\n\n    this._onFocus = e => {\n      if (!this._updateElement(e) && this._isVisible) {\n        this._setVisibility(false);\n      }\n    };\n\n    this._onScroll = e => {\n      if (!this._outlinedElement || !OutlineAPI._isParentChild(e.target, this._outlinedElement)) {\n        return;\n      }\n\n      this._curPos = undefined;\n\n      this._setOutlinePosition();\n    };\n\n    this._tabster = tabster;\n    this._win = tabster.getWindow;\n    tabster.queueInit(this._init);\n\n    if (typeof document !== \"undefined\") {\n      if (\"onfullscreenchange\" in document) {\n        this._fullScreenEventName = \"fullscreenchange\";\n        this._fullScreenElementName = \"fullscreenElement\";\n      } else if (\"onwebkitfullscreenchange\" in document) {\n        this._fullScreenEventName = \"webkitfullscreenchange\";\n        this._fullScreenElementName = \"webkitFullscreenElement\";\n      } else if (\"onmozfullscreenchange\" in document) {\n        this._fullScreenEventName = \"mozfullscreenchange\";\n        this._fullScreenElementName = \"mozFullScreenElement\";\n      } else if (\"onmsfullscreenchange\" in document) {\n        this._fullScreenEventName = \"msfullscreenchange\";\n        this._fullScreenElementName = \"msFullscreenElement\";\n      }\n    }\n  }\n\n  setup(props) {\n    _props = { ..._props,\n      ...props\n    };\n\n    const win = this._win();\n\n    if (!win.__tabsterOutline) {\n      win.__tabsterOutline = {};\n    }\n\n    if (!win.__tabsterOutline.style) {\n      win.__tabsterOutline.style = appendStyles(win.document, _props);\n    }\n\n    if (!props || !props.areaClass) {\n      win.document.body.classList.add(defaultProps.areaClass);\n    } else {\n      win.document.body.classList.remove(defaultProps.areaClass);\n    }\n  }\n\n  dispose() {\n    const win = this._win();\n\n    if (this._updateTimer) {\n      win.clearTimeout(this._updateTimer);\n      this._updateTimer = undefined;\n    }\n\n    this._tabster.keyboardNavigation.unsubscribe(this._onKeyboardNavigationStateChanged);\n\n    this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n    win.removeEventListener(\"scroll\", this._onScroll, true);\n\n    if (this._fullScreenEventName) {\n      win.document.removeEventListener(this._fullScreenEventName, this._onFullScreenChanged);\n    }\n\n    this._allOutlineElements.forEach(outlineElements => this._removeDOM(outlineElements.container));\n\n    this._allOutlineElements = [];\n    delete this._outlinedElement;\n    delete this._curPos;\n    delete this._curOutlineElements;\n    delete this._fullScreenElement;\n  }\n\n  _shouldShowCustomOutline(element) {\n    const tabsterOnElement = getTabsterOnElement(this._tabster, element);\n\n    if (tabsterOnElement && tabsterOnElement.outline && tabsterOnElement.outline.isIgnored) {\n      return false;\n    }\n\n    for (let i = element; i; i = i.parentElement) {\n      if (i.classList && i.classList.contains(_props.areaClass)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _updateElement(e) {\n    this._outlinedElement = undefined;\n\n    if (this._updateTimer) {\n      this._win().clearTimeout(this._updateTimer);\n\n      this._updateTimer = undefined;\n    }\n\n    this._curPos = undefined;\n\n    if (!this._tabster.keyboardNavigation.isNavigatingWithKeyboard()) {\n      return false;\n    }\n\n    if (e) {\n      // TODO: It's hard (and not necessary) to come up with every possible\n      // condition when there should be no outline, it's better to add an\n      // API to customize the ignores.\n      if (e.tagName === \"INPUT\") {\n        const inputType = e.type;\n        const outlinedInputTypes = {\n          button: true,\n          checkbox: true,\n          file: true,\n          image: true,\n          radio: true,\n          range: true,\n          reset: true,\n          submit: true\n        };\n\n        if (!(inputType in outlinedInputTypes)) {\n          return false;\n        }\n      } else if (e.tagName === \"TEXTAREA\" || e.contentEditable === \"true\" || e.tagName === \"IFRAME\") {\n        return false;\n      }\n\n      if (!this._shouldShowCustomOutline(e)) {\n        return false;\n      }\n\n      if (this._tabster.keyboardNavigation.isNavigatingWithKeyboard()) {\n        this._outlinedElement = e;\n\n        this._updateOutline();\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  _updateOutline() {\n    this._setOutlinePosition();\n\n    if (this._updateTimer) {\n      this._win().clearTimeout(this._updateTimer);\n\n      this._updateTimer = undefined;\n    }\n\n    if (!this._outlinedElement) {\n      return;\n    }\n\n    this._updateTimer = this._win().setTimeout(() => {\n      this._updateTimer = undefined;\n\n      this._updateOutline();\n    }, 30);\n  }\n\n  _setVisibility(visible) {\n    this._isVisible = visible;\n\n    if (this._curOutlineElements) {\n      if (visible) {\n        this._curOutlineElements.container.classList.add(`${_props.outlineClass}_visible`);\n      } else {\n        this._curOutlineElements.container.classList.remove(`${_props.outlineClass}_visible`);\n\n        this._curPos = undefined;\n      }\n    }\n  }\n\n  _setOutlinePosition() {\n    if (!this._outlinedElement) {\n      return;\n    }\n\n    let boundingRect = getBoundingRect(this._win, this._outlinedElement);\n    const position = new OutlinePosition(boundingRect.left, boundingRect.top, boundingRect.right, boundingRect.bottom);\n\n    if (this._curPos && position.equalsTo(this._curPos)) {\n      return;\n    }\n\n    const outlineElements = this._getDOM(this._outlinedElement);\n\n    const win = this._outlinedElement.ownerDocument && this._outlinedElement.ownerDocument.defaultView;\n\n    if (!outlineElements || !win) {\n      return;\n    }\n\n    if (this._curOutlineElements !== outlineElements) {\n      this._setVisibility(false);\n\n      this._curOutlineElements = outlineElements;\n    }\n\n    this._curPos = position;\n    const p = position.clone();\n    let hasAbsolutePositionedParent = false;\n    let hasFixedPositionedParent = false;\n    const container = outlineElements.container;\n    const scrollingElement = container && container.ownerDocument && container.ownerDocument.scrollingElement;\n\n    if (!scrollingElement) {\n      return;\n    }\n\n    for (let parent = this._outlinedElement.parentElement; parent && parent.nodeType === Node.ELEMENT_NODE; parent = parent.parentElement) {\n      // The element might be partially visible within its scrollable parent,\n      // reduce the bounding rect if this is the case.\n      if (parent === this._fullScreenElement) {\n        break;\n      }\n\n      boundingRect = getBoundingRect(this._win, parent);\n      const win = parent.ownerDocument && parent.ownerDocument.defaultView;\n\n      if (!win) {\n        return;\n      }\n\n      const computedStyle = win.getComputedStyle(parent);\n      const position = computedStyle.position;\n\n      if (position === \"absolute\") {\n        hasAbsolutePositionedParent = true;\n      } else if (position === \"fixed\" || position === \"sticky\") {\n        hasFixedPositionedParent = true;\n      }\n\n      if (computedStyle.overflow === \"visible\") {\n        continue;\n      }\n\n      if (!hasAbsolutePositionedParent && !hasFixedPositionedParent || computedStyle.overflow === \"hidden\") {\n        if (boundingRect.left > p.left) {\n          p.left = boundingRect.left;\n        }\n\n        if (boundingRect.top > p.top) {\n          p.top = boundingRect.top;\n        }\n\n        if (boundingRect.right < p.right) {\n          p.right = boundingRect.right;\n        }\n\n        if (boundingRect.bottom < p.bottom) {\n          p.bottom = boundingRect.bottom;\n        }\n      }\n    }\n\n    const allRect = getBoundingRect(this._win, scrollingElement);\n    const allWidth = allRect.left + allRect.right;\n    const allHeight = allRect.top + allRect.bottom;\n    const ow = _props.outlineWidth;\n    p.left = p.left > ow ? p.left - ow : 0;\n    p.top = p.top > ow ? p.top - ow : 0;\n    p.right = p.right < allWidth - ow ? p.right + ow : allWidth;\n    p.bottom = p.bottom < allHeight - ow ? p.bottom + ow : allHeight;\n    const width = p.right - p.left;\n    const height = p.bottom - p.top;\n\n    if (width > ow * 2 && height > ow * 2) {\n      const leftBorderNode = outlineElements.left;\n      const topBorderNode = outlineElements.top;\n      const rightBorderNode = outlineElements.right;\n      const bottomBorderNode = outlineElements.bottom;\n      const sx = this._fullScreenElement || hasFixedPositionedParent ? 0 : win.pageXOffset;\n      const sy = this._fullScreenElement || hasFixedPositionedParent ? 0 : win.pageYOffset;\n      container.style.position = hasFixedPositionedParent ? \"fixed\" : \"absolute\";\n      container.style.background = _props.outlineColor;\n      leftBorderNode.style.width = rightBorderNode.style.width = topBorderNode.style.height = bottomBorderNode.style.height = _props.outlineWidth + \"px\";\n      leftBorderNode.style.left = topBorderNode.style.left = bottomBorderNode.style.left = p.left + sx + \"px\";\n      rightBorderNode.style.left = p.left + sx + width - ow + \"px\";\n      leftBorderNode.style.top = rightBorderNode.style.top = topBorderNode.style.top = p.top + sy + \"px\";\n      bottomBorderNode.style.top = p.top + sy + height - ow + \"px\";\n      leftBorderNode.style.height = rightBorderNode.style.height = height + \"px\";\n      topBorderNode.style.width = bottomBorderNode.style.width = width + \"px\";\n\n      this._setVisibility(true);\n    } else {\n      this._setVisibility(false);\n    }\n  }\n\n  _getDOM(contextElement) {\n    const doc = contextElement.ownerDocument;\n    const win = doc && doc.defaultView;\n\n    if (!doc || !win || !win.__tabsterOutline) {\n      return undefined;\n    }\n\n    if (!win.__tabsterOutline.style) {\n      win.__tabsterOutline.style = appendStyles(doc, _props);\n    }\n\n    if (!win.__tabsterOutline.elements) {\n      const outlineElements = {\n        container: doc.createElement(\"div\"),\n        left: doc.createElement(\"div\"),\n        top: doc.createElement(\"div\"),\n        right: doc.createElement(\"div\"),\n        bottom: doc.createElement(\"div\")\n      };\n      outlineElements.container.className = _props.outlineClass;\n      outlineElements.left.className = `${_props.outlineClass}__left`;\n      outlineElements.top.className = `${_props.outlineClass}__top`;\n      outlineElements.right.className = `${_props.outlineClass}__right`;\n      outlineElements.bottom.className = `${_props.outlineClass}__bottom`;\n      outlineElements.container.appendChild(outlineElements.left);\n      outlineElements.container.appendChild(outlineElements.top);\n      outlineElements.container.appendChild(outlineElements.right);\n      outlineElements.container.appendChild(outlineElements.bottom);\n      doc.body.appendChild(outlineElements.container);\n      win.__tabsterOutline.elements = outlineElements; // TODO: Make a garbage collector to remove the references\n      // to the outlines which are nowhere in the DOM anymore.\n\n      this._allOutlineElements.push(outlineElements);\n    }\n\n    return win.__tabsterOutline.elements;\n  }\n\n  _removeDOM(contextElement) {\n    const win = contextElement.ownerDocument && contextElement.ownerDocument.defaultView;\n    const outline = win && win.__tabsterOutline;\n\n    if (!outline) {\n      return;\n    }\n\n    if (outline.style && outline.style.parentNode) {\n      outline.style.parentNode.removeChild(outline.style);\n      delete outline.style;\n    }\n\n    const outlineElements = outline && outline.elements;\n\n    if (outlineElements) {\n      if (outlineElements.container.parentNode) {\n        outlineElements.container.parentNode.removeChild(outlineElements.container);\n      }\n\n      delete outline.elements;\n    }\n  }\n\n  static _isParentChild(parent, child) {\n    return child === parent || // tslint:disable-next-line:no-bitwise\n    !!(parent.compareDocumentPosition(child) & document.DOCUMENT_POSITION_CONTAINED_BY);\n  }\n\n}\n\nfunction appendStyles(document, props) {\n  const style = document.createElement(\"style\");\n  style.type = \"text/css\";\n  style.appendChild(document.createTextNode(getOutlineStyles(props)));\n  document.head.appendChild(style);\n  return style;\n}\n\nfunction getOutlineStyles(props) {\n  return `\n.${props.areaClass} *, .${props.areaClass} *:focus {\noutline: none !important;\n}\n\n.${props.outlineClass} {\ndisplay: none;\nposition: absolute;\nwidth: 0;\nheight: 0;\nleft: 0;\ntop: 0;\nz-index: ${props.zIndex};\n}\n\n.${props.outlineClass}.${props.outlineClass}_visible {\ndisplay: block;\n}\n\n.${props.outlineClass}__left,\n.${props.outlineClass}__top,\n.${props.outlineClass}__right,\n.${props.outlineClass}__bottom {\nposition: absolute;\nbackground: inherit;\n}`;\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * Allows default or user focus behaviour on the DOM subtree\r\n * i.e. Tabster will not control focus events within an uncontrolled area\r\n */\nclass UncontrolledAPI {\n  constructor() {\n    /**/\n  }\n\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst EVENT_NAME = \"restorer:restorefocus\";\nconst HISOTRY_DEPTH = 10;\n\nclass Restorer extends TabsterPart {\n  constructor(tabster, element, props) {\n    var _a;\n\n    super(tabster, element, props);\n    this._hasFocus = false;\n\n    this._onFocusOut = e => {\n      var _a;\n\n      const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();\n\n      if (element && e.relatedTarget === null) {\n        element.dispatchEvent(new Event(EVENT_NAME, {\n          bubbles: true\n        }));\n      }\n\n      if (element && !element.contains(e.relatedTarget)) {\n        this._hasFocus = false;\n      }\n    };\n\n    this._onFocusIn = () => {\n      this._hasFocus = true;\n    };\n\n    if (this._props.type === RestorerTypes.Source) {\n      const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();\n      element === null || element === void 0 ? void 0 : element.addEventListener(\"focusout\", this._onFocusOut);\n      element === null || element === void 0 ? void 0 : element.addEventListener(\"focusin\", this._onFocusIn);\n    }\n  }\n\n  dispose() {\n    var _a, _b;\n\n    if (this._props.type === RestorerTypes.Source) {\n      const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();\n      element === null || element === void 0 ? void 0 : element.removeEventListener(\"focusout\", this._onFocusOut);\n      element === null || element === void 0 ? void 0 : element.removeEventListener(\"focusin\", this._onFocusIn);\n\n      if (this._hasFocus) {\n        const doc = this._tabster.getWindow().document;\n\n        (_b = doc.body) === null || _b === void 0 ? void 0 : _b.dispatchEvent(new Event(EVENT_NAME, {\n          bubbles: true\n        }));\n      }\n    }\n  }\n\n}\n\nclass RestorerAPI {\n  constructor(tabster) {\n    this._history = [];\n    this._restoreFocusTimeout = 0;\n\n    this._onRestoreFocus = e => {\n      const win = this._getWindow();\n\n      if (this._restoreFocusTimeout) {\n        win.clearTimeout(this._restoreFocusTimeout);\n      }\n\n      this._restoreFocusTimeout = win.setTimeout(() => this._restoreFocus(e.target));\n    };\n\n    this._onFocusIn = element => {\n      var _a;\n\n      if (!element) {\n        return;\n      }\n\n      const tabsterAttribute = getTabsterOnElement(this._tabster, element);\n\n      if (((_a = tabsterAttribute === null || tabsterAttribute === void 0 ? void 0 : tabsterAttribute.restorer) === null || _a === void 0 ? void 0 : _a.getProps().type) !== RestorerTypes.Target) {\n        return;\n      }\n\n      this._addToHistory(element);\n    };\n\n    this._restoreFocus = source => {\n      var _a, _b, _c; // don't restore focus if focus isn't lost to body\n\n\n      const doc = this._getWindow().document;\n\n      if (doc.activeElement !== doc.body) {\n        return;\n      }\n\n      if ( // clicking on any empty space focuses body - this is can be a false positive\n      !this._keyboardNavState.isNavigatingWithKeyboard() && // Source no longer exists on DOM - always restore focus\n      doc.body.contains(source)) {\n        return;\n      }\n\n      let weakRef = this._history.pop();\n\n      while (weakRef && !doc.body.contains((_b = (_a = weakRef.deref()) === null || _a === void 0 ? void 0 : _a.parentElement) !== null && _b !== void 0 ? _b : null)) {\n        weakRef = this._history.pop();\n      }\n\n      (_c = weakRef === null || weakRef === void 0 ? void 0 : weakRef.deref()) === null || _c === void 0 ? void 0 : _c.focus();\n    };\n\n    this._tabster = tabster;\n    this._getWindow = tabster.getWindow;\n\n    this._getWindow().addEventListener(EVENT_NAME, this._onRestoreFocus);\n\n    this._keyboardNavState = tabster.keyboardNavigation;\n    this._focusedElementState = tabster.focusedElement;\n\n    this._focusedElementState.subscribe(this._onFocusIn);\n  }\n\n  dispose() {\n    const win = this._getWindow();\n\n    this._focusedElementState.unsubscribe(this._onFocusIn);\n\n    win.removeEventListener(EVENT_NAME, this._onRestoreFocus);\n\n    if (this._restoreFocusTimeout) {\n      win.clearTimeout(this._restoreFocusTimeout);\n    }\n  }\n\n  _addToHistory(element) {\n    var _a; // Don't duplicate the top of history\n\n\n    if (((_a = this._history[this._history.length - 1]) === null || _a === void 0 ? void 0 : _a.deref()) === element) {\n      return;\n    }\n\n    if (this._history.length > HISOTRY_DEPTH) {\n      this._history.shift();\n    }\n\n    this._history.push(new WeakRef(element));\n  }\n\n  createRestorer(element, props) {\n    const restorer = new Restorer(this._tabster, element, props); // Focus might already be on a restorer target when it gets created so the focusin will not do anything\n\n    if (props.type === RestorerTypes.Target && element.ownerDocument.activeElement === element) {\n      this._addToHistory(element);\n    }\n\n    return restorer;\n  }\n\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nclass Tabster {\n  constructor(tabster) {\n    this.keyboardNavigation = tabster.keyboardNavigation;\n    this.focusedElement = tabster.focusedElement;\n    this.focusable = tabster.focusable;\n    this.root = tabster.root;\n    this.uncontrolled = tabster.uncontrolled;\n    this.core = tabster;\n  }\n\n}\n/**\r\n * Extends Window to include an internal Tabster instance.\r\n */\n\n\nclass TabsterCore {\n  constructor(win, props) {\n    var _a, _b;\n\n    this._forgetMemorizedElements = [];\n    this._wrappers = new Set();\n    this._initQueue = [];\n    this._version = \"4.8.0\";\n    this._noop = false;\n\n    this.getWindow = () => {\n      if (!this._win) {\n        throw new Error(\"Using disposed Tabster.\");\n      }\n\n      return this._win;\n    };\n\n    this._storage = createWeakMap(win);\n    this._win = win;\n    const getWindow = this.getWindow;\n    this.keyboardNavigation = new KeyboardNavigationState(getWindow);\n    this.focusedElement = new FocusedElementState(this, getWindow);\n    this.focusable = new FocusableAPI(this);\n    this.root = new RootAPI(this, props === null || props === void 0 ? void 0 : props.autoRoot);\n    this.uncontrolled = new UncontrolledAPI();\n    this.controlTab = (_a = props === null || props === void 0 ? void 0 : props.controlTab) !== null && _a !== void 0 ? _a : true;\n    this.rootDummyInputs = !!(props === null || props === void 0 ? void 0 : props.rootDummyInputs);\n    this._dummyObserver = new DummyInputObserver(getWindow);\n    this.getParent = (_b = props === null || props === void 0 ? void 0 : props.getParent) !== null && _b !== void 0 ? _b : el => el.parentElement;\n    this.internal = {\n      stopObserver: () => {\n        if (this._unobserve) {\n          this._unobserve();\n\n          delete this._unobserve;\n        }\n      },\n      resumeObserver: syncState => {\n        if (!this._unobserve) {\n          const doc = getWindow().document;\n          this._unobserve = observeMutations(doc, this, updateTabsterByAttribute, syncState);\n        }\n      }\n    };\n    startFakeWeakRefsCleanup(getWindow); // Gives a tick to the host app to initialize other tabster\n    // APIs before tabster starts observing attributes.\n\n    this.queueInit(() => {\n      this.internal.resumeObserver(true);\n    });\n  }\n  /**\r\n   * Merges external props with the current props. Not all\r\n   * props can/should be mergeable, so let's add more as we move on.\r\n   * @param props Tabster props\r\n   */\n\n\n  _mergeProps(props) {\n    var _a;\n\n    if (!props) {\n      return;\n    }\n\n    this.getParent = (_a = props.getParent) !== null && _a !== void 0 ? _a : this.getParent;\n  }\n\n  createTabster(noRefCount, props) {\n    const wrapper = new Tabster(this);\n\n    if (!noRefCount) {\n      this._wrappers.add(wrapper);\n    }\n\n    this._mergeProps(props);\n\n    return wrapper;\n  }\n\n  disposeTabster(wrapper, allInstances) {\n    if (allInstances) {\n      this._wrappers.clear();\n    } else {\n      this._wrappers.delete(wrapper);\n    }\n\n    if (this._wrappers.size === 0) {\n      this.dispose();\n    }\n  }\n\n  dispose() {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n\n    this.internal.stopObserver();\n    const win = this._win;\n    win === null || win === void 0 ? void 0 : win.clearTimeout(this._initTimer);\n    delete this._initTimer;\n    this._initQueue = [];\n    this._forgetMemorizedElements = [];\n\n    if (win && this._forgetMemorizedTimer) {\n      win.clearTimeout(this._forgetMemorizedTimer);\n      delete this._forgetMemorizedTimer;\n    }\n\n    (_a = this.outline) === null || _a === void 0 ? void 0 : _a.dispose();\n    (_b = this.crossOrigin) === null || _b === void 0 ? void 0 : _b.dispose();\n    (_c = this.deloser) === null || _c === void 0 ? void 0 : _c.dispose();\n    (_d = this.groupper) === null || _d === void 0 ? void 0 : _d.dispose();\n    (_e = this.mover) === null || _e === void 0 ? void 0 : _e.dispose();\n    (_f = this.modalizer) === null || _f === void 0 ? void 0 : _f.dispose();\n    (_g = this.observedElement) === null || _g === void 0 ? void 0 : _g.dispose();\n    (_h = this.restorer) === null || _h === void 0 ? void 0 : _h.dispose();\n    this.keyboardNavigation.dispose();\n    this.focusable.dispose();\n    this.focusedElement.dispose();\n    this.root.dispose();\n\n    this._dummyObserver.dispose();\n\n    stopFakeWeakRefsCleanupAndClearStorage(this.getWindow);\n    clearElementCache(this.getWindow);\n    this._storage = new WeakMap();\n\n    this._wrappers.clear();\n\n    if (win) {\n      disposeInstanceContext(win);\n      delete win.__tabsterInstance;\n      delete this._win;\n    }\n  }\n\n  storageEntry(element, addremove) {\n    const storage = this._storage;\n    let entry = storage.get(element);\n\n    if (entry) {\n      if (addremove === false && Object.keys(entry).length === 0) {\n        storage.delete(element);\n      }\n    } else if (addremove === true) {\n      entry = {};\n      storage.set(element, entry);\n    }\n\n    return entry;\n  }\n\n  forceCleanup() {\n    if (!this._win) {\n      return;\n    }\n\n    this._forgetMemorizedElements.push(this._win.document.body);\n\n    if (this._forgetMemorizedTimer) {\n      return;\n    }\n\n    this._forgetMemorizedTimer = this._win.setTimeout(() => {\n      delete this._forgetMemorizedTimer;\n\n      for (let el = this._forgetMemorizedElements.shift(); el; el = this._forgetMemorizedElements.shift()) {\n        clearElementCache(this.getWindow, el);\n        FocusedElementState.forgetMemorized(this.focusedElement, el);\n      }\n    }, 0);\n    cleanupFakeWeakRefs(this.getWindow, true);\n  }\n\n  queueInit(callback) {\n    var _a;\n\n    if (!this._win) {\n      return;\n    }\n\n    this._initQueue.push(callback);\n\n    if (!this._initTimer) {\n      this._initTimer = (_a = this._win) === null || _a === void 0 ? void 0 : _a.setTimeout(() => {\n        delete this._initTimer;\n        this.drainInitQueue();\n      }, 0);\n    }\n  }\n\n  drainInitQueue() {\n    if (!this._win) {\n      return;\n    }\n\n    const queue = this._initQueue; // Resetting the queue before calling the callbacks to avoid recursion.\n\n    this._initQueue = [];\n    queue.forEach(callback => callback());\n  }\n\n}\n\nfunction forceCleanup(tabster) {\n  // The only legit case for calling this method is when you've completely removed\n  // the application DOM and not going to add the new one for a while.\n  const tabsterCore = tabster.core;\n  tabsterCore.forceCleanup();\n}\n/**\r\n * Creates an instance of Tabster, returns the current window instance if it already exists.\r\n */\n\nfunction createTabster(win, props) {\n  let tabster = getCurrentTabster(win);\n\n  if (tabster) {\n    return tabster.createTabster(false, props);\n  }\n\n  tabster = new TabsterCore(win, props);\n  win.__tabsterInstance = tabster;\n  return tabster.createTabster();\n}\n/**\r\n * Returns an instance of Tabster if it was created before or null.\r\n */\n\nfunction getTabster(win) {\n  const tabster = getCurrentTabster(win);\n  return tabster ? tabster.createTabster(true) : null;\n}\n/**\r\n * Creates a new groupper instance or returns an existing one\r\n * @param tabster Tabster instance\r\n */\n\nfunction getGroupper(tabster) {\n  const tabsterCore = tabster.core;\n\n  if (!tabsterCore.groupper) {\n    tabsterCore.groupper = new GroupperAPI(tabsterCore, tabsterCore.getWindow);\n  }\n\n  return tabsterCore.groupper;\n}\n/**\r\n * Creates a new mover instance or returns an existing one\r\n * @param tabster Tabster instance\r\n */\n\nfunction getMover(tabster) {\n  const tabsterCore = tabster.core;\n\n  if (!tabsterCore.mover) {\n    tabsterCore.mover = new MoverAPI(tabsterCore, tabsterCore.getWindow);\n  }\n\n  return tabsterCore.mover;\n}\nfunction getOutline(tabster) {\n  const tabsterCore = tabster.core;\n\n  if (!tabsterCore.outline) {\n    tabsterCore.outline = new OutlineAPI(tabsterCore);\n  }\n\n  return tabsterCore.outline;\n}\n/**\r\n * Creates a new new deloser instance or returns an existing one\r\n * @param tabster Tabster instance\r\n * @param props Deloser props\r\n */\n\nfunction getDeloser(tabster, props) {\n  const tabsterCore = tabster.core;\n\n  if (!tabsterCore.deloser) {\n    tabsterCore.deloser = new DeloserAPI(tabsterCore, props);\n  }\n\n  return tabsterCore.deloser;\n}\n/**\r\n * Creates a new modalizer instance or returns an existing one\r\n * @param tabster Tabster instance\r\n * @param alwaysAccessibleSelector When Modalizer is active, we put\r\n * aria-hidden to everything else to hide it from screen readers. This CSS\r\n * selector allows to exclude some elements from this behaviour. For example,\r\n * this could be used to exclude aria-live region with the application-wide\r\n * status announcements.\r\n * @param accessibleCheck An optional callback that will be called when\r\n * active Modalizer wants to hide an element that doesn't belong to it from\r\n * the screen readers by setting aria-hidden. Similar to alwaysAccessibleSelector\r\n * but allows to address the elements programmatically rather than with a selector.\r\n * If the callback returns true, the element will not receive aria-hidden.\r\n */\n\nfunction getModalizer(tabster, // @deprecated use accessibleCheck.\nalwaysAccessibleSelector, accessibleCheck) {\n  const tabsterCore = tabster.core;\n\n  if (!tabsterCore.modalizer) {\n    tabsterCore.modalizer = new ModalizerAPI(tabsterCore, alwaysAccessibleSelector, accessibleCheck);\n  }\n\n  return tabsterCore.modalizer;\n}\nfunction getObservedElement(tabster) {\n  const tabsterCore = tabster.core;\n\n  if (!tabsterCore.observedElement) {\n    tabsterCore.observedElement = new ObservedElementAPI(tabsterCore);\n  }\n\n  return tabsterCore.observedElement;\n}\nfunction getCrossOrigin(tabster) {\n  const tabsterCore = tabster.core;\n\n  if (!tabsterCore.crossOrigin) {\n    getDeloser(tabster);\n    getModalizer(tabster);\n    getMover(tabster);\n    getGroupper(tabster);\n    getOutline(tabster);\n    getObservedElement(tabster);\n    tabsterCore.crossOrigin = new CrossOriginAPI(tabsterCore);\n  }\n\n  return tabsterCore.crossOrigin;\n}\nfunction getInternal(tabster) {\n  const tabsterCore = tabster.core;\n  return tabsterCore.internal;\n}\nfunction getRestorer(tabster) {\n  const tabsterCore = tabster.core;\n\n  if (!tabsterCore.restorer) {\n    tabsterCore.restorer = new RestorerAPI(tabsterCore);\n  }\n\n  return tabsterCore.restorer;\n}\nfunction disposeTabster(tabster, allInstances) {\n  tabster.core.disposeTabster(tabster, allInstances);\n}\n/**\r\n * Returns an instance of Tabster if it already exists on the window .\r\n * @param win window instance that could contain an Tabster instance.\r\n */\n\nfunction getCurrentTabster(win) {\n  return win.__tabsterInstance;\n}\n/**\r\n * Allows to make Tabster non operational. Intended for performance debugging (and other\r\n * kinds of debugging), you can switch Tabster off without changing the application code\r\n * that consumes it.\r\n * @param tabster a reference created by createTabster().\r\n * @param noop true if you want to make Tabster noop, false if you want to turn it back.\r\n */\n\nfunction makeNoOp(tabster, noop) {\n  const core = tabster.core;\n\n  if (core._noop !== noop) {\n    core._noop = noop;\n\n    const processNode = element => {\n      if (!element.getAttribute) {\n        return NodeFilter.FILTER_SKIP;\n      }\n\n      if (getTabsterOnElement(core, element) || element.hasAttribute(TabsterAttributeName)) {\n        updateTabsterByAttribute(core, element);\n      }\n\n      return NodeFilter.FILTER_SKIP;\n    };\n\n    const doc = core.getWindow().document;\n    const body = doc.body;\n    processNode(body);\n    const walker = createElementTreeWalker(doc, body, processNode);\n\n    if (walker) {\n      while (walker.nextNode()) {\n        /* Iterating for the sake of calling processNode() callback. */\n      }\n    }\n  }\n}\nfunction isNoOp(tabster) {\n  return tabster._noop;\n}\n\nexport { Types, createTabster, disposeTabster, forceCleanup, getCrossOrigin, getDeloser, getGroupper, getInternal, getModalizer, getMover, getObservedElement, getOutline, getRestorer, getTabster, getTabsterAttribute, isNoOp, makeNoOp, mergeTabsterProps, setTabsterAttribute };\n//# sourceMappingURL=tabster.esm.js.map\n"],"names":["TabsterAttributeName","TabsterDummyInputAttributeName","DeloserEventName","ModalizerActiveEventName","ModalizerInactiveEventName","MoverEventName","FocusInEventName","FocusOutEventName","ObservedElementAccesibilities","Any","Accessible","Focusable","RestoreFocusOrders","History","DeloserDefault","RootDefault","DeloserFirst","RootFirst","Visibilities","Invisible","PartiallyVisible","Visible","RestorerTypes","Source","Target","MoverDirections","Both","Vertical","Horizontal","Grid","GridLinear","GroupperTabbabilities","Unlimited","Limited","LimitedTrapFocus","SysDummyInputsPositions","Auto","Inside","Outside","Types","Object","freeze","__proto__","ModalizerFocusInEventName","ModalizerFocusOutEventName","ModalizerBeforeFocusOutEventName","getTabsterOnElement","tabster","element","_a","storageEntry","updateTabsterByAttribute","dispose","_b","newAttrValue","_noop","undefined","getAttribute","newAttr","entry","attr","string","newValue","JSON","parse","Error","object","e","tabsterOnElement","oldTabsterProps","newTabsterProps","key","keys","root","onRoot","part","observedElement","onObservedElementUpdate","sys","deloser","setProps","createDeloser","createRoot","modalizer","createModalizer","restorer","createRestorer","focusable","groupper","createGroupper","mover","createMover","observed","uncontrolled","outline","console","error","length","_isBrokenIE11","_DOMRect","DOMRect","constructor","x","y","width","height","this","left","top","right","bottom","_uidCounter","document","createTreeWalker","NodeFilter","SHOW_ELEMENT","getInstanceContext","getWindow","win","ctx","__tabsterInstanceContext","elementByUId","basics","Promise","WeakRef","containerBoundingRectCache","lastContainerBoundingRectCacheId","fakeWeakRefs","fakeWeakRefsStarted","FakeWeakRef","target","_target","deref","cleanup","fwr","forceRemove","documentContains","ownerDocument","WeakHTMLElement","data","context","ref","push","_ref","_data","get","getData","cleanupFakeWeakRefs","filter","startFakeWeakRefsCleanup","getWeakRef","fakeWeakRefsTimer","setTimeout","createElementTreeWalker","doc","acceptNode","nodeType","Node","ELEMENT_NODE","getBoundingRect","cacheId","__tabsterCacheId","cached","rect","scrollingElement","documentElement","clientWidth","clientHeight","r","getBoundingClientRect","Math","max","min","containerBoundingRectCacheTimer","window","cId","isElementVerticallyVisibleInContainer","tolerance","container","getScrollableContainer","containerRect","elementRect","intersectionTolerance","totalIntersection","scrollIntoView","alignToTop","scrollTop","el","parentElement","scrollWidth","scrollHeight","shouldIgnoreFocus","__shouldIgnoreFocus","getUId","wnd","rnd","Uint32Array","crypto","getRandomValues","msCrypto","i","random","srnd","toString","Date","now","join","getElementUId","uid","__tabsterElementUID","clearElementCache","parent","wel","contains","body","matchesSelector","selector","matches","msMatchesSelector","webkitMatchesSelector","call","getPromise","_lastTabsterPartId","TabsterPart","props","_tabster","_element","_props","id","getElement","getProps","DummyInput","isOutside","_focusIn","input","onFocusIn","relatedTarget","DummyInputManager","getLastPhantomFrom","_isBackward","_focusOut","useDefaultAction","onFocusOut","createElement","tabIndex","setAttribute","style","position","opacity","zIndex","setProperty","makeFocusIgnored","isFirst","_isPhantom","isPhantom","addEventListener","__tabsterDummyContainer","_disposeTimer","_clearDisposeTimeout","clearTimeout","removeEventListener","removeChild","setTopLeft","isIn","current","previous","compareDocumentPosition","DOCUMENT_POSITION_FOLLOWING","DummyInputManagerPriorities","priority","outsideByDefault","callForDefaultAction","_instance","DummyInputManagerCore","moveOut","backwards","moveOutWithDefaultAction","_setHandlers","_onFocusIn","_onFocusOut","getHandler","setTabbable","tabbable","ret","_lastPhantomFrom","moveWithPhantomDummy","moveOutside","isBackward","insertBefore","nextElementSibling","beforeBefore","previousElementSibling","DummyInputObserver","_updateQueue","Set","_lastUpdateQueueTime","_changedParents","WeakSet","_dummies","Map","_domChanged","has","add","_updateDummyInputsTimer","_win","dummy","callback","dummyParent","set","domChanged","remove","dummyInputElements","delete","size","_updateTimer","clear","updatePositions","compute","_scheduledUpdatePositions","scrollTopLeftCache","setTopLeftCallbacks","manager","_wrappers","_isOutside","_transformElements","dummyInput","_onFocus","first","_firstDummy","last","_lastDummy","_ensurePosition","firstInput","lastInput","toFocus","isFocusable","w","wrapper","_getCurrent","_addDummyInputs","_addTimer","_getWindow","_addTransformOffsets","_dummyObserver","_computeTransformOffsets","from","transformElements","newTransformElements","scrollLeft","scrollTopLeft","transform","getComputedStyle","_callForDefaultAction","instance","__tabsterDummy","forcedDummyPosition","dummyInputsPosition","tagName","dummyElement","force","_c","_d","sort","a","b","firstDummyInput","lastDummyInput","elementParent","nextSibling","lastElementChild","appendChild","firstElementChild","getLastChild","lastChild","triggerEvent","name","details","event","createEvent","initEvent","dispatchEvent","defaultPrevented","getTabsterAttribute","plain","stringify","setTabsterAttribute","newProps","update","value","mergeTabsterProps","removeAttribute","RootDummyManager","setFocused","super","_onDummyInputFocus","_setFocused","keyboardNavigation","setNavigatingWithKeyboard","focusedElement","getFirstOrLastTabbable","ignoreAccessibility","blur","Root","onDispose","_isFocused","hasFocused","fromAdjacent","_setFocusedTimer","eventTarget","_setTabbableTimer","RootAPI","getTabsterContext","rootDummyInputs","_dummyManager","_onDispose","_sys","controlTab","addDummyInputs","subscribe","_add","_remove","dummyManager","autoRoot","_autoRootWaiting","_roots","_forceDummy","rootById","_autoRootCreate","_autoRootUnwait","_autoRoot","_onRootDispose","global","EventTarget","TypeError","createEventTarget","queueInit","forEach","rootId","newRoot","roots","getRootByUId","__tabsterInstance","options","checkRtl","referenceElement","getParent","drainInitQueue","isGroupperFirst","modalizerInGroupper","isRtl","isExcludedFromMover","curElement","ignoreKeydown","dir","toLowerCase","excludeFromMover","curModalizer","curGroupper","curMover","isActive","tabbability","userId","activeId","assign","rootAPI","getRoot","removed","Subscribable","_callbacks","_val","callbacks","indexOf","subscribeFirst","index","splice","unshift","unsubscribe","setVal","val","_callCallbacks","getVal","trigger","_focusableSelector","FocusableAPI","includeProgrammaticallyFocusable","noVisibleCheck","noAccessibleCheck","isVisible","isAccessible","offsetParent","defaultView","visibility","_isHidden","ignoreAriaDisabled","_isDisabled","hasAttribute","attrVal","isAugmented","findFirst","findElement","findLast","findNext","out","findPrev","findDefault","acceptCondition","isDefault","findAll","_findElements","found","currentElement","useActiveModalizer","ignoreUncontrolled","modalizerId","onUncontrolled","onElement","elements","acceptElementState","modalizerUserId","cachedGrouppers","walker","node","_acceptElement","prepareForNextElement","shouldContinueIfNotFound","foundElement","fromCtx","outOfDOMOrder","currentNode","FILTER_ACCEPT","skippedFocusable","previousNode","nextNode","nextUncontrolled","state","_e","FILTER_SKIP","FILTER_REJECT","lastToIgnore","currentCtx","result","fromMover","acceptElement","groupperElement","fromMoverElement","moverElement","Keys","FocusedElementState","_init","_onKeyDown","activeElement","_setFocusedElement","_onChanged","isFocusedProgrammatically","_validateFocusedElement","keyCode","ctrlKey","contentEditable","shiftKey","next","findNextTabbable","nextElement","moveFrom","preventDefault","stopImmediatePropagation","_lastVal","d","lastCtx","_lastResetElement","_nextVal","forgetMemorized","getFocusedElement","getLastFocusedElement","focus","noFocusedProgrammaticallyFlag","focusDefault","tabsterFocusable","_focusFirstOrLast","focusFirst","focusLast","resetFocus","prevTabIndex","prevAriaHidden","_setOrRemoveAttribute","lastResetElement","nextVal","actualContainer","isTabbingTimer","_isTabbingTimer","isTabbing","callFindNext","what","parentCtx","currentScopeElement","newCurrent","findProps","findPropsOut","KeyboardNavigationState","_onChange","isNavigatingWithKeyboard","_keyborg","_inputSelector","MoverDummyManager","getMemorized","_onFocusDummyInput","memorized","_getMemorized","Mover","_visible","_onIntersection","entries","newVisibility","fullyVisible","_fullyVisible","intersectionRatio","getState","visibilityTolerance","trackState","visibilityAware","_intersectionObserver","IntersectionObserver","threshold","_observeState","memorizeCurrent","_current","disconnect","_allElements","_unobserve","_setCurrentTimer","setCurrent","changed","_prevCurrent","weak","getCurrent","currentIsDummy","hasDefault","MutationObserver","allElements","WeakMap","updateQueue","observer","mutations","mutation","removedNodes","added","addedNodes","type","attributeName","requestUpdate","setElement","unobserve","observe","updateElement","addNewElements","getMoverGroupper","groupperFirstFocusable","getFirst","removeWalk","toe","childList","subtree","attributes","attributeFilter","isCurrent","MoverAPI","_onMoverDispose","_movers","async","_ignoredInputTimer","_ignoredInputResolve","altKey","metaKey","focused","_isIgnoredInput","moverProps","direction","isBoth","isVertical","isHorizontal","isGridLinear","isGrid","isCyclic","cyclic","focusedElementRect","focusedElementX1","focusedElementX2","ceil","floor","nextElementX1","nextElementX2","firstColumnX1","lastColumnX1","ax1","ay1","ax2","ay2","targetElement","lastDistance","lastIntersection","bx1","by1","bx2","by2","xIntersectionWidth","minWidth","intersection","distance","xDistance","yDistance","sqrt","getDistance","moverId","newMover","asyncRet","selectionStart","selectionEnd","textLength","selection","getSelection","initialLength","modify","selStart","resolve","anchorNode","prevAnchorNode","focusNode","prevFocusNode","anchorOffset","prevAnchorOffset","focusOffset","prevFocusOffset","textContent","anchorFound","addOffsets","nodeText","firstChild","len","stop","UncontrolledAPI","Tabster","core","TabsterCore","_forgetMemorizedElements","_initQueue","_version","_storage","createWeakMap","internal","stopObserver","resumeObserver","syncState","updateTabsterElements","processNode","hiddenUpdate","observeMutations","_mergeProps","createTabster","noRefCount","disposeTabster","allInstances","_f","_g","_h","_initTimer","_forgetMemorizedTimer","crossOrigin","stopFakeWeakRefsCleanupAndClearStorage","disposeInstanceContext","addremove","storage","forceCleanup","shift","queue","getCurrentTabster","getMover","tabsterCore"],"sourceRoot":""}