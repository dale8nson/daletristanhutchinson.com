{"version":3,"file":"31b45c90-2c8b93ffabcad3da8a0f.js","mappings":"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","sources":["webpack://dale-tristan-hutchinson/./node_modules/tabster/dist/tabster.esm.js"],"sourcesContent":["import { nativeFocus, KEYBORG_FOCUSIN, createKeyborg, disposeKeyborg } from 'keyborg';\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst TabsterAttributeName = \"data-tabster\";\nconst TabsterDummyInputAttributeName = \"data-tabster-dummy\";\nconst DeloserEventName = \"tabster:deloser\";\nconst ModalizerActiveEventName = \"tabster:modalizer:active\";\nconst ModalizerInactiveEventName = \"tabster:modalizer:inactive\";\nconst ModalizerFocusInEventName = \"tabster:modalizer:focusin\";\nconst ModalizerFocusOutEventName = \"tabster:modalizer:focusout\";\nconst ModalizerBeforeFocusOutEventName = \"tabster:modalizer:beforefocusout\";\nconst MoverEventName = \"tabster:mover\";\nconst FocusInEventName = \"tabster:focusin\";\nconst FocusOutEventName = \"tabster:focusout\";\nconst ObservedElementAccesibilities = {\n  Any: 0,\n  Accessible: 1,\n  Focusable: 2\n};\nconst RestoreFocusOrders = {\n  History: 0,\n  DeloserDefault: 1,\n  RootDefault: 2,\n  DeloserFirst: 3,\n  RootFirst: 4\n};\nconst Visibilities = {\n  Invisible: 0,\n  PartiallyVisible: 1,\n  Visible: 2\n};\nconst MoverDirections = {\n  Both: 0,\n  Vertical: 1,\n  Horizontal: 2,\n  Grid: 3,\n  GridLinear: 4\n};\nconst GroupperTabbabilities = {\n  Unlimited: 0,\n  Limited: 1,\n  LimitedTrapFocus: 2\n};\nconst SysDummyInputsPositions = {\n  Auto: 0,\n  Inside: 1,\n  Outside: 2\n};\n\nvar Types = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    TabsterAttributeName: TabsterAttributeName,\n    TabsterDummyInputAttributeName: TabsterDummyInputAttributeName,\n    DeloserEventName: DeloserEventName,\n    ModalizerActiveEventName: ModalizerActiveEventName,\n    ModalizerInactiveEventName: ModalizerInactiveEventName,\n    ModalizerFocusInEventName: ModalizerFocusInEventName,\n    ModalizerFocusOutEventName: ModalizerFocusOutEventName,\n    ModalizerBeforeFocusOutEventName: ModalizerBeforeFocusOutEventName,\n    MoverEventName: MoverEventName,\n    FocusInEventName: FocusInEventName,\n    FocusOutEventName: FocusOutEventName,\n    ObservedElementAccesibilities: ObservedElementAccesibilities,\n    RestoreFocusOrders: RestoreFocusOrders,\n    Visibilities: Visibilities,\n    MoverDirections: MoverDirections,\n    GroupperTabbabilities: GroupperTabbabilities,\n    SysDummyInputsPositions: SysDummyInputsPositions\n});\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nfunction getTabsterOnElement(tabster, element) {\n  var _a;\n\n  return (_a = tabster.storageEntry(element)) === null || _a === void 0 ? void 0 : _a.tabster;\n}\nfunction updateTabsterByAttribute(tabster, element, dispose) {\n  var _a, _b;\n\n  const newAttrValue = dispose || tabster._noop ? undefined : element.getAttribute(TabsterAttributeName);\n  let entry = tabster.storageEntry(element);\n  let newAttr;\n\n  if (newAttrValue) {\n    if (newAttrValue !== ((_a = entry === null || entry === void 0 ? void 0 : entry.attr) === null || _a === void 0 ? void 0 : _a.string)) {\n      try {\n        const newValue = JSON.parse(newAttrValue);\n\n        if (typeof newValue !== \"object\") {\n          throw new Error(`Value is not a JSON object, got '${newAttrValue}'.`);\n        }\n\n        newAttr = {\n          string: newAttrValue,\n          object: newValue\n        };\n      } catch (e) {\n        if (process.env.NODE_ENV === 'development') {\n          console.error(`data-tabster attribute error: ${e}`, element);\n        }\n      }\n    } else {\n      return;\n    }\n  } else if (!entry) {\n    return;\n  }\n\n  if (!entry) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    entry = tabster.storageEntry(element, true);\n  }\n\n  if (!entry.tabster) {\n    entry.tabster = {};\n  }\n\n  const tabsterOnElement = entry.tabster || {};\n  const oldTabsterProps = ((_b = entry.attr) === null || _b === void 0 ? void 0 : _b.object) || {};\n  const newTabsterProps = (newAttr === null || newAttr === void 0 ? void 0 : newAttr.object) || {};\n\n  for (const key of Object.keys(oldTabsterProps)) {\n    if (!newTabsterProps[key]) {\n      if (key === \"root\") {\n        const root = tabsterOnElement[key];\n\n        if (root) {\n          tabster.root.onRoot(root, true);\n        }\n      }\n\n      switch (key) {\n        case \"deloser\":\n        case \"root\":\n        case \"groupper\":\n        case \"modalizer\":\n        case \"mover\":\n          // eslint-disable-next-line no-case-declarations\n          const part = tabsterOnElement[key];\n\n          if (part) {\n            part.dispose();\n            delete tabsterOnElement[key];\n          }\n\n          break;\n\n        case \"observed\":\n          delete tabsterOnElement[key];\n\n          if (tabster.observedElement) {\n            tabster.observedElement.onObservedElementUpdate(element);\n          }\n\n          break;\n\n        case \"focusable\":\n        case \"outline\":\n        case \"uncontrolled\":\n        case \"sys\":\n          delete tabsterOnElement[key];\n          break;\n      }\n    }\n  }\n\n  for (const key of Object.keys(newTabsterProps)) {\n    const sys = newTabsterProps.sys;\n\n    switch (key) {\n      case \"deloser\":\n        if (tabsterOnElement.deloser) {\n          tabsterOnElement.deloser.setProps(newTabsterProps.deloser);\n        } else {\n          if (tabster.deloser) {\n            tabsterOnElement.deloser = tabster.deloser.createDeloser(element, newTabsterProps.deloser);\n          } else if (process.env.NODE_ENV === 'development') {\n            console.error(\"Deloser API used before initialization, please call `getDeloser()`\");\n          }\n        }\n\n        break;\n\n      case \"root\":\n        if (tabsterOnElement.root) {\n          tabsterOnElement.root.setProps(newTabsterProps.root);\n        } else {\n          tabsterOnElement.root = tabster.root.createRoot(element, newTabsterProps.root, sys);\n        }\n\n        tabster.root.onRoot(tabsterOnElement.root);\n        break;\n\n      case \"modalizer\":\n        if (tabsterOnElement.modalizer) {\n          tabsterOnElement.modalizer.setProps(newTabsterProps.modalizer);\n        } else {\n          if (tabster.modalizer) {\n            tabsterOnElement.modalizer = tabster.modalizer.createModalizer(element, newTabsterProps.modalizer, sys);\n          } else if (process.env.NODE_ENV === 'development') {\n            console.error(\"Modalizer API used before initialization, please call `getModalizer()`\");\n          }\n        }\n\n        break;\n\n      case \"focusable\":\n        tabsterOnElement.focusable = newTabsterProps.focusable;\n        break;\n\n      case \"groupper\":\n        if (tabsterOnElement.groupper) {\n          tabsterOnElement.groupper.setProps(newTabsterProps.groupper);\n        } else {\n          if (tabster.groupper) {\n            tabsterOnElement.groupper = tabster.groupper.createGroupper(element, newTabsterProps.groupper, sys);\n          } else if (process.env.NODE_ENV === 'development') {\n            console.error(\"Groupper API used before initialization, please call `getGroupper()`\");\n          }\n        }\n\n        break;\n\n      case \"mover\":\n        if (tabsterOnElement.mover) {\n          tabsterOnElement.mover.setProps(newTabsterProps.mover);\n        } else {\n          if (tabster.mover) {\n            tabsterOnElement.mover = tabster.mover.createMover(element, newTabsterProps.mover, sys);\n          } else if (process.env.NODE_ENV === 'development') {\n            console.error(\"Mover API used before initialization, please call `getMover()`\");\n          }\n        }\n\n        break;\n\n      case \"observed\":\n        if (tabster.observedElement) {\n          tabsterOnElement.observed = newTabsterProps.observed;\n          tabster.observedElement.onObservedElementUpdate(element);\n        } else if (process.env.NODE_ENV === 'development') {\n          console.error(\"ObservedElement API used before initialization, please call `getObservedElement()`\");\n        }\n\n        break;\n\n      case \"uncontrolled\":\n        tabsterOnElement.uncontrolled = newTabsterProps.uncontrolled;\n        break;\n\n      case \"outline\":\n        if (tabster.outline) {\n          tabsterOnElement.outline = newTabsterProps.outline;\n        } else if (process.env.NODE_ENV === 'development') {\n          console.error(\"Outline API used before initialization, please call `getOutline()`\");\n        }\n\n        break;\n\n      case \"sys\":\n        tabsterOnElement.sys = newTabsterProps.sys;\n        break;\n\n      default:\n        console.error(`Unknown key '${key}' in data-tabster attribute value.`);\n    }\n  }\n\n  if (newAttr) {\n    entry.attr = newAttr;\n  } else {\n    if (Object.keys(tabsterOnElement).length === 0) {\n      delete entry.tabster;\n      delete entry.attr;\n    }\n\n    tabster.storageEntry(element, false);\n  }\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nfunction createEventTarget(getWindow) {\n  const global = getWindow();\n\n  try {\n    if (global.EventTarget) {\n      return new global.EventTarget();\n    }\n  } catch (error) {\n    // thrown if EventTarget is not constructable or doesn't exit\n    if (!(error instanceof TypeError)) {\n      throw error;\n    }\n  }\n\n  return global.document.createElement(\"div\");\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nlet _isBrokenIE11;\n\nconst _DOMRect = typeof DOMRect !== \"undefined\" ? DOMRect : class {\n  constructor(x, y, width, height) {\n    this.left = x || 0;\n    this.top = y || 0;\n    this.right = (x || 0) + (width || 0);\n    this.bottom = (y || 0) + (height || 0);\n  }\n\n};\n\nlet _uidCounter = 0;\n\ntry {\n  // IE11 only accepts `filter` argument as a function (not object with the `acceptNode`\n  // property as the docs define). Also `entityReferenceExpansion` argument is not\n  // optional. And it throws exception when the above arguments aren't there.\n  document.createTreeWalker(document, NodeFilter.SHOW_ELEMENT);\n  _isBrokenIE11 = false;\n} catch (e) {\n  _isBrokenIE11 = true;\n}\n\nconst _updateDummyInputsTimeout = 100;\nfunction getInstanceContext(getWindow) {\n  const win = getWindow();\n  let ctx = win.__tabsterInstanceContext;\n\n  if (!ctx) {\n    ctx = {\n      elementByUId: {},\n      basics: {\n        Promise: win.Promise || undefined,\n        WeakRef: win.WeakRef || undefined\n      },\n      containerBoundingRectCache: {},\n      lastContainerBoundingRectCacheId: 0,\n      fakeWeakRefs: [],\n      fakeWeakRefsStarted: false\n    };\n    win.__tabsterInstanceContext = ctx;\n  }\n\n  return ctx;\n}\nfunction disposeInstanceContext(win) {\n  const ctx = win.__tabsterInstanceContext;\n\n  if (ctx) {\n    ctx.elementByUId = {};\n    delete ctx.WeakRef;\n    ctx.containerBoundingRectCache = {};\n\n    if (ctx.containerBoundingRectCacheTimer) {\n      win.clearTimeout(ctx.containerBoundingRectCacheTimer);\n    }\n\n    if (ctx.fakeWeakRefsTimer) {\n      win.clearTimeout(ctx.fakeWeakRefsTimer);\n    }\n\n    ctx.fakeWeakRefs = [];\n    delete win.__tabsterInstanceContext;\n  }\n}\nfunction createWeakMap(win) {\n  const ctx = win.__tabsterInstanceContext;\n  return new ((ctx === null || ctx === void 0 ? void 0 : ctx.basics.WeakMap) || WeakMap)();\n}\n\nclass FakeWeakRef {\n  constructor(target) {\n    this._target = target;\n  }\n\n  deref() {\n    return this._target;\n  }\n\n  static cleanup(fwr, forceRemove) {\n    if (!fwr._target) {\n      return true;\n    }\n\n    if (forceRemove || !documentContains(fwr._target.ownerDocument, fwr._target)) {\n      delete fwr._target;\n      return true;\n    }\n\n    return false;\n  }\n\n}\n\nclass WeakHTMLElement {\n  constructor(getWindow, element, data) {\n    const context = getInstanceContext(getWindow);\n    let ref;\n\n    if (context.WeakRef) {\n      ref = new context.WeakRef(element);\n    } else {\n      ref = new FakeWeakRef(element);\n      context.fakeWeakRefs.push(ref);\n    }\n\n    this._ref = ref;\n    this._data = data;\n  }\n\n  get() {\n    const ref = this._ref;\n    let element;\n\n    if (ref) {\n      element = ref.deref();\n\n      if (!element) {\n        delete this._ref;\n      }\n    }\n\n    return element;\n  }\n\n  getData() {\n    return this._data;\n  }\n\n}\nfunction cleanupFakeWeakRefs(getWindow, forceRemove) {\n  const context = getInstanceContext(getWindow);\n  context.fakeWeakRefs = context.fakeWeakRefs.filter(e => !FakeWeakRef.cleanup(e, forceRemove));\n}\nfunction startFakeWeakRefsCleanup(getWindow) {\n  const context = getInstanceContext(getWindow);\n\n  if (!context.fakeWeakRefsStarted) {\n    context.fakeWeakRefsStarted = true;\n    context.WeakRef = getWeakRef(context);\n  }\n\n  if (!context.fakeWeakRefsTimer) {\n    context.fakeWeakRefsTimer = getWindow().setTimeout(() => {\n      context.fakeWeakRefsTimer = undefined;\n      cleanupFakeWeakRefs(getWindow);\n      startFakeWeakRefsCleanup(getWindow);\n    }, 2 * 60 * 1000); // 2 minutes.\n  }\n}\nfunction stopFakeWeakRefsCleanupAndClearStorage(getWindow) {\n  const context = getInstanceContext(getWindow);\n  context.fakeWeakRefsStarted = false;\n\n  if (context.fakeWeakRefsTimer) {\n    getWindow().clearTimeout(context.fakeWeakRefsTimer);\n    context.fakeWeakRefsTimer = undefined;\n    context.fakeWeakRefs = [];\n  }\n}\nfunction createElementTreeWalker(doc, root, acceptNode) {\n  // IE11 will throw an exception when the TreeWalker root is not an Element.\n  if (root.nodeType !== Node.ELEMENT_NODE) {\n    return undefined;\n  } // TypeScript isn't aware of IE11 behaving badly.\n\n\n  const filter = _isBrokenIE11 ? acceptNode : {\n    acceptNode\n  };\n  return doc.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, filter, // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore: We still don't want to completely break IE11, so, entityReferenceExpansion argument is not optional.\n  false\n  /* Last argument is not optional for IE11! */\n  );\n}\nfunction getBoundingRect(getWindow, element) {\n  let cacheId = element.__tabsterCacheId;\n  const context = getInstanceContext(getWindow);\n  const cached = cacheId ? context.containerBoundingRectCache[cacheId] : undefined;\n\n  if (cached) {\n    return cached.rect;\n  }\n\n  const scrollingElement = element.ownerDocument && element.ownerDocument.documentElement;\n\n  if (!scrollingElement) {\n    return new _DOMRect();\n  } // A bounding rect of the top-level element contains the whole page regardless of the\n  // scrollbar. So, we improvise a little and limiting the final result...\n\n\n  let left = 0;\n  let top = 0;\n  let right = scrollingElement.clientWidth;\n  let bottom = scrollingElement.clientHeight;\n\n  if (element !== scrollingElement) {\n    const r = element.getBoundingClientRect();\n    left = Math.max(left, r.left);\n    top = Math.max(top, r.top);\n    right = Math.min(right, r.right);\n    bottom = Math.min(bottom, r.bottom);\n  }\n\n  const rect = new _DOMRect(left < right ? left : -1, top < bottom ? top : -1, left < right ? right - left : 0, top < bottom ? bottom - top : 0);\n\n  if (!cacheId) {\n    cacheId = \"r-\" + ++context.lastContainerBoundingRectCacheId;\n    element.__tabsterCacheId = cacheId;\n  }\n\n  context.containerBoundingRectCache[cacheId] = {\n    rect,\n    element\n  };\n\n  if (!context.containerBoundingRectCacheTimer) {\n    context.containerBoundingRectCacheTimer = window.setTimeout(() => {\n      context.containerBoundingRectCacheTimer = undefined;\n\n      for (const cId of Object.keys(context.containerBoundingRectCache)) {\n        delete context.containerBoundingRectCache[cId].element.__tabsterCacheId;\n      }\n\n      context.containerBoundingRectCache = {};\n    }, 50);\n  }\n\n  return rect;\n}\nfunction isElementVerticallyVisibleInContainer(getWindow, element, tolerance) {\n  const container = getScrollableContainer(element);\n\n  if (!container) {\n    return false;\n  }\n\n  const containerRect = getBoundingRect(getWindow, container);\n  const elementRect = element.getBoundingClientRect();\n  const intersectionTolerance = elementRect.height * (1 - tolerance);\n  const topIntersection = Math.max(0, containerRect.top - elementRect.top);\n  const bottomIntersection = Math.max(0, elementRect.bottom - containerRect.bottom);\n  const totalIntersection = topIntersection + bottomIntersection;\n  return totalIntersection === 0 || totalIntersection <= intersectionTolerance;\n}\nfunction scrollIntoView(getWindow, element, alignToTop) {\n  // Built-in DOM's scrollIntoView() is cool, but when we have nested containers,\n  // it scrolls all of them, not just the deepest one. So, trying to work it around.\n  const container = getScrollableContainer(element);\n\n  if (container) {\n    const containerRect = getBoundingRect(getWindow, container);\n    const elementRect = element.getBoundingClientRect();\n\n    if (alignToTop) {\n      container.scrollTop += elementRect.top - containerRect.top;\n    } else {\n      container.scrollTop += elementRect.bottom - containerRect.bottom;\n    }\n  }\n}\nfunction getScrollableContainer(element) {\n  const doc = element.ownerDocument;\n\n  if (doc) {\n    for (let el = element.parentElement; el; el = el.parentElement) {\n      if (el.scrollWidth > el.clientWidth || el.scrollHeight > el.clientHeight) {\n        return el;\n      }\n    }\n\n    return doc.documentElement;\n  }\n\n  return null;\n}\nfunction makeFocusIgnored(element) {\n  element.__shouldIgnoreFocus = true;\n}\nfunction shouldIgnoreFocus(element) {\n  return !!element.__shouldIgnoreFocus;\n}\nfunction getUId(wnd) {\n  const rnd = new Uint32Array(4);\n\n  if (wnd.crypto && wnd.crypto.getRandomValues) {\n    wnd.crypto.getRandomValues(rnd);\n  } else if (wnd.msCrypto && wnd.msCrypto.getRandomValues) {\n    wnd.msCrypto.getRandomValues(rnd);\n  } else {\n    for (let i = 0; i < rnd.length; i++) {\n      rnd[i] = 0xffffffff * Math.random();\n    }\n  }\n\n  const srnd = [];\n\n  for (let i = 0; i < rnd.length; i++) {\n    srnd.push(rnd[i].toString(36));\n  }\n\n  srnd.push(\"|\");\n  srnd.push((++_uidCounter).toString(36));\n  srnd.push(\"|\");\n  srnd.push(Date.now().toString(36));\n  return srnd.join(\"\");\n}\nfunction getElementUId(getWindow, element) {\n  const context = getInstanceContext(getWindow);\n  let uid = element.__tabsterElementUID;\n\n  if (!uid) {\n    uid = element.__tabsterElementUID = getUId(getWindow());\n  }\n\n  if (!context.elementByUId[uid] && documentContains(element.ownerDocument, element)) {\n    context.elementByUId[uid] = new WeakHTMLElement(getWindow, element);\n  }\n\n  return uid;\n}\nfunction getWindowUId(win) {\n  let uid = win.__tabsterCrossOriginWindowUID;\n\n  if (!uid) {\n    uid = win.__tabsterCrossOriginWindowUID = getUId(win);\n  }\n\n  return uid;\n}\nfunction clearElementCache(getWindow, parent) {\n  const context = getInstanceContext(getWindow);\n\n  for (const key of Object.keys(context.elementByUId)) {\n    const wel = context.elementByUId[key];\n    const el = wel && wel.get();\n\n    if (el && parent) {\n      if (!parent.contains(el)) {\n        continue;\n      }\n    }\n\n    delete context.elementByUId[key];\n  }\n} // IE11 doesn't have document.contains()...\n\nfunction documentContains(doc, element) {\n  var _a;\n\n  return !!((_a = doc === null || doc === void 0 ? void 0 : doc.body) === null || _a === void 0 ? void 0 : _a.contains(element));\n}\nfunction matchesSelector(element, selector) {\n  const matches = element.matches || element.matchesSelector || element.msMatchesSelector || element.webkitMatchesSelector;\n  return matches && matches.call(element, selector);\n}\nfunction getPromise(getWindow) {\n  const context = getInstanceContext(getWindow);\n\n  if (context.basics.Promise) {\n    return context.basics.Promise;\n  }\n\n  throw new Error(\"No Promise defined.\");\n}\nfunction getWeakRef(context) {\n  return context.basics.WeakRef;\n}\nlet _lastTabsterPartId = 0;\nclass TabsterPart {\n  constructor(tabster, element, props) {\n    const getWindow = tabster.getWindow;\n    this._tabster = tabster;\n    this._element = new WeakHTMLElement(getWindow, element);\n    this._props = { ...props\n    };\n    this.id = \"i\" + ++_lastTabsterPartId;\n  }\n\n  getElement() {\n    return this._element.get();\n  }\n\n  getProps() {\n    return this._props;\n  }\n\n  setProps(props) {\n    this._props = { ...props\n    };\n  }\n\n}\n/**\r\n * Dummy HTML elements that are used as focus sentinels for the DOM enclosed within them\r\n */\n\nclass DummyInput {\n  constructor(getWindow, isOutside, props, element) {\n    var _a;\n\n    this._focusIn = e => {\n      const input = this.input;\n\n      if (this.onFocusIn && input) {\n        const relatedTarget = DummyInputManager.getLastPhantomFrom() || e.relatedTarget;\n        this.onFocusIn(this, this._isBackward(true, input, relatedTarget), relatedTarget);\n      }\n    };\n\n    this._focusOut = e => {\n      this.useDefaultAction = false;\n      const input = this.input;\n\n      if (this.onFocusOut && input) {\n        const relatedTarget = e.relatedTarget;\n        this.onFocusOut(this, this._isBackward(false, input, relatedTarget), relatedTarget);\n      }\n    };\n\n    const win = getWindow();\n    const input = win.document.createElement(\"i\");\n    input.tabIndex = 0;\n    input.setAttribute(\"role\", \"none\");\n    input.setAttribute(TabsterDummyInputAttributeName, \"\");\n    input.setAttribute(\"aria-hidden\", \"true\");\n    const style = input.style;\n    style.position = \"fixed\";\n    style.width = style.height = \"1px\";\n    style.opacity = \"0.001\";\n    style.zIndex = \"-1\";\n    style.setProperty(\"content-visibility\", \"hidden\");\n    makeFocusIgnored(input);\n    this.input = input;\n    this.isFirst = props.isFirst;\n    this.isOutside = isOutside;\n    this._isPhantom = (_a = props.isPhantom) !== null && _a !== void 0 ? _a : false;\n    input.addEventListener(\"focusin\", this._focusIn);\n    input.addEventListener(\"focusout\", this._focusOut);\n    input.__tabsterDummyContainer = element;\n\n    if (this._isPhantom) {\n      this._disposeTimer = win.setTimeout(() => {\n        delete this._disposeTimer;\n        this.dispose();\n      }, 0);\n\n      this._clearDisposeTimeout = () => {\n        if (this._disposeTimer) {\n          win.clearTimeout(this._disposeTimer);\n          delete this._disposeTimer;\n        }\n\n        delete this._clearDisposeTimeout;\n      };\n    }\n  }\n\n  dispose() {\n    var _a;\n\n    if (this._clearDisposeTimeout) {\n      this._clearDisposeTimeout();\n    }\n\n    const input = this.input;\n\n    if (!input) {\n      return;\n    }\n\n    delete this.onFocusIn;\n    delete this.onFocusOut;\n    delete this.input;\n    input.removeEventListener(\"focusin\", this._focusIn);\n    input.removeEventListener(\"focusout\", this._focusOut);\n    delete input.__tabsterDummyContainer;\n    (_a = input.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(input);\n  }\n\n  setTopLeft(top, left) {\n    var _a;\n\n    const style = (_a = this.input) === null || _a === void 0 ? void 0 : _a.style;\n\n    if (style) {\n      style.top = `${top}px`;\n      style.left = `${left}px`;\n    }\n  }\n\n  _isBackward(isIn, current, previous) {\n    return isIn && !previous ? !this.isFirst : !!(previous && current.compareDocumentPosition(previous) & Node.DOCUMENT_POSITION_FOLLOWING);\n  }\n\n}\nconst DummyInputManagerPriorities = {\n  Root: 1,\n  Modalizer: 2,\n  Mover: 3,\n  Groupper: 4\n};\nclass DummyInputManager {\n  constructor(tabster, element, priority, sys, outsideByDefault, callForDefaultAction) {\n    this._element = element;\n    this._instance = new DummyInputManagerCore(tabster, element, this, priority, sys, outsideByDefault, callForDefaultAction);\n\n    this.moveOut = backwards => {\n      var _a;\n\n      (_a = this._instance) === null || _a === void 0 ? void 0 : _a.moveOut(backwards);\n    };\n\n    this.moveOutWithDefaultAction = backwards => {\n      var _a;\n\n      (_a = this._instance) === null || _a === void 0 ? void 0 : _a.moveOutWithDefaultAction(backwards);\n    };\n  }\n\n  _setHandlers(onFocusIn, onFocusOut) {\n    this._onFocusIn = onFocusIn;\n    this._onFocusOut = onFocusOut;\n  }\n\n  getHandler(isIn) {\n    return isIn ? this._onFocusIn : this._onFocusOut;\n  }\n\n  setTabbable(tabbable) {\n    var _a;\n\n    (_a = this._instance) === null || _a === void 0 ? void 0 : _a.setTabbable(this, tabbable);\n  }\n\n  dispose() {\n    if (this._instance) {\n      this._instance.dispose(this);\n\n      delete this._instance;\n    }\n\n    delete this._onFocusIn;\n    delete this._onFocusOut;\n  }\n\n  static getLastPhantomFrom() {\n    const ret = DummyInputManager._lastPhantomFrom;\n    delete DummyInputManager._lastPhantomFrom;\n    return ret;\n  }\n\n  static moveWithPhantomDummy(tabster, element, moveOutside, isBackward) {\n    const dummy = new DummyInput(tabster.getWindow, true, {\n      isPhantom: true,\n      isFirst: true\n    });\n    const input = dummy.input;\n\n    if (input) {\n      const parent = element.parentElement;\n\n      if (parent) {\n        let insertBefore = moveOutside && !isBackward || !moveOutside && isBackward ? element.nextElementSibling : element;\n\n        if (insertBefore) {\n          if (isBackward) {\n            const beforeBefore = insertBefore.previousElementSibling;\n\n            if (beforeBefore && beforeBefore.__tabsterDummyContainer) {\n              insertBefore = beforeBefore;\n            }\n          } else if (insertBefore.__tabsterDummyContainer) {\n            insertBefore = insertBefore.nextElementSibling;\n          }\n        }\n\n        parent.insertBefore(input, insertBefore);\n        DummyInputManager._lastPhantomFrom = element;\n        tabster.getWindow().setTimeout(() => {\n          delete DummyInputManager._lastPhantomFrom;\n        }, 0);\n        nativeFocus(input);\n      }\n    }\n  }\n\n}\n\nfunction setDummyInputDebugValue(dummy, wrappers) {\n  var _a;\n\n  const what = {\n    1: \"Root\",\n    2: \"Modalizer\",\n    3: \"Mover\",\n    4: \"Groupper\"\n  };\n  (_a = dummy.input) === null || _a === void 0 ? void 0 : _a.setAttribute(TabsterDummyInputAttributeName, [`isFirst=${dummy.isFirst}`, `isOutside=${dummy.isOutside}`, ...wrappers.map(w => `(${what[w.priority]}, tabbable=${w.tabbable})`)].join(\", \"));\n}\n\nclass DummyInputObserver {\n  constructor(win) {\n    this._updateQueue = new Set();\n    this._lastUpdateQueueTime = 0;\n    this._changedParents = new WeakSet();\n    this._dummies = new Map();\n\n    this._domChanged = parent => {\n      var _a;\n\n      if (this._changedParents.has(parent)) {\n        return;\n      }\n\n      this._changedParents.add(parent);\n\n      if (this._updateDummyInputsTimer) {\n        return;\n      }\n\n      this._updateDummyInputsTimer = (_a = this._win) === null || _a === void 0 ? void 0 : _a.call(this).setTimeout(() => {\n        delete this._updateDummyInputsTimer;\n\n        for (const [dummy, callback] of this._dummies) {\n          const dummyParent = dummy.parentElement;\n\n          if (!dummyParent || this._changedParents.has(dummyParent)) {\n            callback();\n          }\n        }\n\n        this._changedParents = new WeakSet();\n      }, _updateDummyInputsTimeout);\n    };\n\n    this._win = win;\n  }\n\n  add(dummy, callback) {\n    this._dummies.set(dummy, callback);\n\n    this.domChanged = this._domChanged;\n  }\n\n  remove(dummy) {\n    const dummyInputElements = this._dummies;\n    dummyInputElements.delete(dummy);\n\n    if (dummyInputElements.size === 0) {\n      delete this.domChanged;\n    }\n  }\n\n  dispose() {\n    var _a;\n\n    const win = (_a = this._win) === null || _a === void 0 ? void 0 : _a.call(this);\n\n    if (this._updateTimer) {\n      win === null || win === void 0 ? void 0 : win.clearTimeout(this._updateTimer);\n      delete this._updateTimer;\n    }\n\n    if (this._updateDummyInputsTimer) {\n      win === null || win === void 0 ? void 0 : win.clearTimeout(this._updateDummyInputsTimer);\n      delete this._updateDummyInputsTimer;\n    }\n\n    this._changedParents = new WeakSet();\n\n    this._dummies.clear();\n\n    delete this._win;\n  }\n\n  updatePositions(compute) {\n    if (!this._win) {\n      // As this is a public method, we make sure that it has no effect when\n      // called after dispose().\n      return;\n    }\n\n    this._updateQueue.add(compute);\n\n    this._lastUpdateQueueTime = Date.now();\n\n    this._scheduledUpdatePositions();\n  }\n\n  _scheduledUpdatePositions() {\n    var _a;\n\n    if (this._updateTimer) {\n      return;\n    }\n\n    this._updateTimer = (_a = this._win) === null || _a === void 0 ? void 0 : _a.call(this).setTimeout(() => {\n      delete this._updateTimer; // updatePositions() might be called quite a lot during the scrolling.\n      // So, instead of clearing the timeout and scheduling a new one, we\n      // check if enough time has passed since the last updatePositions() call\n      // and only schedule a new one if not.\n      // At maximum, we will update dummy inputs positions\n      // _updateDummyInputsTimeout * 2 after the last updatePositions() call.\n\n      if (this._lastUpdateQueueTime + _updateDummyInputsTimeout <= Date.now()) {\n        // A cache for current bulk of updates to reduce getComputedStyle() calls.\n        const scrollTopLeftCache = new Map();\n        const setTopLeftCallbacks = [];\n\n        for (const compute of this._updateQueue) {\n          setTopLeftCallbacks.push(compute(scrollTopLeftCache));\n        }\n\n        this._updateQueue.clear(); // We're splitting the computation of offsets and setting them to avoid extra\n        // reflows.\n\n\n        for (const setTopLeft of setTopLeftCallbacks) {\n          setTopLeft();\n        } // Explicitly clear to not hold references till the next garbage collection.\n\n\n        scrollTopLeftCache.clear();\n      } else {\n        this._scheduledUpdatePositions();\n      }\n    }, _updateDummyInputsTimeout);\n  }\n\n}\n/**\r\n * Parent class that encapsulates the behaviour of dummy inputs (focus sentinels)\r\n */\n\nclass DummyInputManagerCore {\n  constructor(tabster, element, manager, priority, sys, outsideByDefault, callForDefaultAction) {\n    this._wrappers = [];\n    this._isOutside = false;\n    this._transformElements = new Set();\n\n    this._onFocusIn = (dummyInput, isBackward, relatedTarget) => {\n      this._onFocus(true, dummyInput, isBackward, relatedTarget);\n    };\n\n    this._onFocusOut = (dummyInput, isBackward, relatedTarget) => {\n      this._onFocus(false, dummyInput, isBackward, relatedTarget);\n    };\n\n    this.moveOut = backwards => {\n      var _a;\n\n      const first = this._firstDummy;\n      const last = this._lastDummy;\n\n      if (first && last) {\n        // For the sake of performance optimization, the dummy input\n        // position in the DOM updates asynchronously from the DOM change.\n        // Calling _ensurePosition() to make sure the position is correct.\n        this._ensurePosition();\n\n        const firstInput = first.input;\n        const lastInput = last.input;\n        const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();\n\n        if (firstInput && lastInput && element) {\n          let toFocus;\n\n          if (backwards) {\n            firstInput.tabIndex = 0;\n            toFocus = firstInput;\n          } else {\n            lastInput.tabIndex = 0;\n            toFocus = lastInput;\n          }\n\n          if (toFocus) {\n            nativeFocus(toFocus);\n          }\n        }\n      }\n    };\n    /**\r\n     * Prepares to move focus out of the given element by focusing\r\n     * one of the dummy inputs and setting the `useDefaultAction` flag\r\n     * @param backwards focus moving to an element behind the given element\r\n     */\n\n\n    this.moveOutWithDefaultAction = backwards => {\n      var _a;\n\n      const first = this._firstDummy;\n      const last = this._lastDummy;\n\n      if (first && last) {\n        // For the sake of performance optimization, the dummy input\n        // position in the DOM updates asynchronously from the DOM change.\n        // Calling _ensurePosition() to make sure the position is correct.\n        this._ensurePosition();\n\n        const firstInput = first.input;\n        const lastInput = last.input;\n        const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();\n\n        if (firstInput && lastInput && element) {\n          let toFocus;\n\n          if (backwards) {\n            if (!first.isOutside && this._tabster.focusable.isFocusable(element, true, true, true)) {\n              toFocus = element;\n            } else {\n              first.useDefaultAction = true;\n              firstInput.tabIndex = 0;\n              toFocus = firstInput;\n            }\n          } else {\n            last.useDefaultAction = true;\n            lastInput.tabIndex = 0;\n            toFocus = lastInput;\n          }\n\n          if (toFocus) {\n            nativeFocus(toFocus);\n          }\n        }\n      }\n    };\n\n    this.setTabbable = (manager, tabbable) => {\n      var _a, _b;\n\n      for (const w of this._wrappers) {\n        if (w.manager === manager) {\n          w.tabbable = tabbable;\n          break;\n        }\n      }\n\n      const wrapper = this._getCurrent();\n\n      if (wrapper) {\n        const tabIndex = wrapper.tabbable ? 0 : -1;\n        let input = (_a = this._firstDummy) === null || _a === void 0 ? void 0 : _a.input;\n\n        if (input) {\n          input.tabIndex = tabIndex;\n        }\n\n        input = (_b = this._lastDummy) === null || _b === void 0 ? void 0 : _b.input;\n\n        if (input) {\n          input.tabIndex = tabIndex;\n        }\n      }\n\n      if (process.env.NODE_ENV === 'development') {\n        this._firstDummy && setDummyInputDebugValue(this._firstDummy, this._wrappers);\n        this._lastDummy && setDummyInputDebugValue(this._lastDummy, this._wrappers);\n      }\n    };\n    /**\r\n     * Adds dummy inputs as the first and last child of the given element\r\n     * Called each time the children under the element is mutated\r\n     */\n\n\n    this._addDummyInputs = () => {\n      if (this._addTimer) {\n        return;\n      }\n\n      this._addTimer = this._getWindow().setTimeout(() => {\n        delete this._addTimer;\n\n        this._ensurePosition();\n\n        if (process.env.NODE_ENV === 'development') {\n          this._firstDummy && setDummyInputDebugValue(this._firstDummy, this._wrappers);\n          this._lastDummy && setDummyInputDebugValue(this._lastDummy, this._wrappers);\n        }\n\n        this._addTransformOffsets();\n      }, 0);\n    };\n\n    this._addTransformOffsets = () => {\n      this._tabster._dummyObserver.updatePositions(this._computeTransformOffsets);\n    };\n\n    this._computeTransformOffsets = scrollTopLeftCache => {\n      var _a, _b;\n\n      const from = ((_a = this._firstDummy) === null || _a === void 0 ? void 0 : _a.input) || ((_b = this._lastDummy) === null || _b === void 0 ? void 0 : _b.input);\n      const transformElements = this._transformElements;\n      const newTransformElements = new Set();\n      let scrollTop = 0;\n      let scrollLeft = 0;\n\n      const win = this._getWindow();\n\n      for (let element = from; element && element.nodeType === Node.ELEMENT_NODE; element = element.parentElement) {\n        let scrollTopLeft = scrollTopLeftCache.get(element); // getComputedStyle() and element.scrollLeft/Top() cause style recalculation,\n        // so we cache the result across all elements in the current bulk.\n\n        if (scrollTopLeft === undefined) {\n          const transform = win.getComputedStyle(element).transform;\n\n          if (transform && transform !== \"none\") {\n            scrollTopLeft = {\n              scrollTop: element.scrollTop,\n              scrollLeft: element.scrollLeft\n            };\n          }\n\n          scrollTopLeftCache.set(element, scrollTopLeft || null);\n        }\n\n        if (scrollTopLeft) {\n          newTransformElements.add(element);\n\n          if (!transformElements.has(element)) {\n            element.addEventListener(\"scroll\", this._addTransformOffsets);\n          }\n\n          scrollTop += scrollTopLeft.scrollTop;\n          scrollLeft += scrollTopLeft.scrollLeft;\n        }\n      }\n\n      for (const el of transformElements) {\n        if (!newTransformElements.has(el)) {\n          el.removeEventListener(\"scroll\", this._addTransformOffsets);\n        }\n      }\n\n      this._transformElements = newTransformElements;\n      return () => {\n        var _a, _b;\n\n        (_a = this._firstDummy) === null || _a === void 0 ? void 0 : _a.setTopLeft(scrollTop, scrollLeft);\n        (_b = this._lastDummy) === null || _b === void 0 ? void 0 : _b.setTopLeft(scrollTop, scrollLeft);\n      };\n    };\n\n    const el = element.get();\n\n    if (!el) {\n      throw new Error(\"No element\");\n    }\n\n    this._tabster = tabster;\n    this._getWindow = tabster.getWindow;\n    this._callForDefaultAction = callForDefaultAction;\n    const instance = el.__tabsterDummy;\n\n    (instance || this)._wrappers.push({\n      manager,\n      priority,\n      tabbable: true\n    });\n\n    if (instance) {\n      if (process.env.NODE_ENV === 'development') {\n        this._firstDummy && setDummyInputDebugValue(this._firstDummy, instance._wrappers);\n        this._lastDummy && setDummyInputDebugValue(this._lastDummy, instance._wrappers);\n      }\n\n      return instance;\n    }\n\n    el.__tabsterDummy = this; // Some elements allow only specific types of direct descendants and we need to\n    // put our dummy inputs inside or outside of the element accordingly.\n\n    const forcedDummyPosition = sys === null || sys === void 0 ? void 0 : sys.dummyInputsPosition;\n    const tagName = el.tagName;\n    this._isOutside = !forcedDummyPosition ? (outsideByDefault || tagName === \"UL\" || tagName === \"OL\" || tagName === \"TABLE\") && !(tagName === \"LI\" || tagName === \"TD\" || tagName === \"TH\") : forcedDummyPosition === SysDummyInputsPositions.Outside;\n    this._firstDummy = new DummyInput(this._getWindow, this._isOutside, {\n      isFirst: true\n    }, element);\n    this._lastDummy = new DummyInput(this._getWindow, this._isOutside, {\n      isFirst: false\n    }, element); // We will be checking dummy input parents to see if their child list have changed.\n    // So, it is enough to have just one of the inputs observed, because\n    // both dummy inputs always have the same parent.\n\n    const dummyElement = this._firstDummy.input;\n    dummyElement && tabster._dummyObserver.add(dummyElement, this._addDummyInputs);\n    this._firstDummy.onFocusIn = this._onFocusIn;\n    this._firstDummy.onFocusOut = this._onFocusOut;\n    this._lastDummy.onFocusIn = this._onFocusIn;\n    this._lastDummy.onFocusOut = this._onFocusOut;\n    this._element = element;\n\n    this._addDummyInputs();\n  }\n\n  dispose(manager, force) {\n    var _a, _b, _c, _d;\n\n    const wrappers = this._wrappers = this._wrappers.filter(w => w.manager !== manager && !force);\n\n    if (process.env.NODE_ENV === 'development') {\n      this._firstDummy && setDummyInputDebugValue(this._firstDummy, wrappers);\n      this._lastDummy && setDummyInputDebugValue(this._lastDummy, wrappers);\n    }\n\n    if (wrappers.length === 0) {\n      delete ((_a = this._element) === null || _a === void 0 ? void 0 : _a.get()).__tabsterDummy;\n\n      for (const el of this._transformElements) {\n        el.removeEventListener(\"scroll\", this._addTransformOffsets);\n      }\n\n      this._transformElements.clear();\n\n      const win = this._getWindow();\n\n      if (this._addTimer) {\n        win.clearTimeout(this._addTimer);\n        delete this._addTimer;\n      }\n\n      const dummyElement = (_b = this._firstDummy) === null || _b === void 0 ? void 0 : _b.input;\n      dummyElement && this._tabster._dummyObserver.remove(dummyElement);\n      (_c = this._firstDummy) === null || _c === void 0 ? void 0 : _c.dispose();\n      (_d = this._lastDummy) === null || _d === void 0 ? void 0 : _d.dispose();\n    }\n  }\n\n  _onFocus(isIn, dummyInput, isBackward, relatedTarget) {\n    var _a;\n\n    const wrapper = this._getCurrent();\n\n    if (wrapper && (!dummyInput.useDefaultAction || this._callForDefaultAction)) {\n      (_a = wrapper.manager.getHandler(isIn)) === null || _a === void 0 ? void 0 : _a(dummyInput, isBackward, relatedTarget);\n    }\n  }\n\n  _getCurrent() {\n    this._wrappers.sort((a, b) => {\n      if (a.tabbable !== b.tabbable) {\n        return a.tabbable ? -1 : 1;\n      }\n\n      return a.priority - b.priority;\n    });\n\n    return this._wrappers[0];\n  }\n\n  _ensurePosition() {\n    var _a, _b, _c;\n\n    const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();\n    const firstDummyInput = (_b = this._firstDummy) === null || _b === void 0 ? void 0 : _b.input;\n    const lastDummyInput = (_c = this._lastDummy) === null || _c === void 0 ? void 0 : _c.input;\n\n    if (!element || !firstDummyInput || !lastDummyInput) {\n      return;\n    }\n\n    if (this._isOutside) {\n      const elementParent = element.parentElement;\n\n      if (elementParent) {\n        const nextSibling = element.nextElementSibling;\n\n        if (nextSibling !== lastDummyInput) {\n          elementParent.insertBefore(lastDummyInput, nextSibling);\n        }\n\n        if (element.previousElementSibling !== firstDummyInput) {\n          elementParent.insertBefore(firstDummyInput, element);\n        }\n      }\n    } else {\n      if (element.lastElementChild !== lastDummyInput) {\n        element.appendChild(lastDummyInput);\n      }\n\n      const firstElementChild = element.firstElementChild;\n\n      if (firstElementChild && firstElementChild !== firstDummyInput) {\n        element.insertBefore(firstDummyInput, firstElementChild);\n      }\n    }\n  }\n\n}\n\nfunction getLastChild(container) {\n  let lastChild = null;\n\n  for (let i = container.lastElementChild; i; i = i.lastElementChild) {\n    lastChild = i;\n  }\n\n  return lastChild || undefined;\n}\nfunction getAdjacentElement(from, prev) {\n  let cur = from;\n  let adjacent = null;\n\n  while (cur && !adjacent) {\n    adjacent = prev ? cur.previousElementSibling : cur.nextElementSibling;\n    cur = cur.parentElement;\n  }\n\n  return adjacent || undefined;\n}\nfunction triggerEvent(target, name, details) {\n  const event = document.createEvent(\"HTMLEvents\");\n  event.initEvent(name, true, true);\n  event.details = details;\n  target.dispatchEvent(event);\n  return !event.defaultPrevented;\n}\nfunction augmentAttribute(tabster, element, name, value // Restore original value when undefined.\n) {\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const entry = tabster.storageEntry(element, true);\n  let ret = false;\n\n  if (!entry.aug) {\n    if (value === undefined) {\n      return ret;\n    }\n\n    entry.aug = {};\n  }\n\n  if (value === undefined) {\n    if (name in entry.aug) {\n      const origVal = entry.aug[name];\n      delete entry.aug[name];\n\n      if (origVal === null) {\n        element.removeAttribute(name);\n      } else {\n        element.setAttribute(name, origVal);\n      }\n\n      ret = true;\n    }\n  } else {\n    let origValue;\n\n    if (!(name in entry.aug)) {\n      origValue = element.getAttribute(name);\n    }\n\n    if (origValue !== undefined && origValue !== value) {\n      entry.aug[name] = origValue;\n\n      if (value === null) {\n        element.removeAttribute(name);\n      } else {\n        element.setAttribute(name, value);\n      }\n\n      ret = true;\n    }\n  }\n\n  if (value === undefined && Object.keys(entry.aug).length === 0) {\n    delete entry.aug;\n    tabster.storageEntry(element, false);\n  }\n\n  return ret;\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nfunction getTabsterAttribute(props, plain) {\n  const attr = JSON.stringify(props);\n\n  if (plain === true) {\n    return attr;\n  }\n\n  return {\n    [TabsterAttributeName]: attr\n  };\n}\n/**\r\n * Updates Tabster props object with new props.\r\n * @param element an element to set data-tabster attribute on.\r\n * @param props current Tabster props to update.\r\n * @param newProps new Tabster props to add.\r\n *  When the value of a property in newProps is undefined, the property\r\n *  will be removed from the attribute.\r\n */\n\nfunction mergeTabsterProps(props, newProps) {\n  for (const key of Object.keys(newProps)) {\n    const value = newProps[key];\n\n    if (value) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      props[key] = value;\n    } else {\n      delete props[key];\n    }\n  }\n}\n/**\r\n * Sets or updates Tabster attribute of the element.\r\n * @param element an element to set data-tabster attribute on.\r\n * @param newProps new Tabster props to set.\r\n * @param update if true, newProps will be merged with the existing props.\r\n *  When true and the value of a property in newProps is undefined, the property\r\n *  will be removed from the attribute.\r\n */\n\nfunction setTabsterAttribute(element, newProps, update) {\n  let props;\n\n  if (update) {\n    const attr = element.getAttribute(TabsterAttributeName);\n\n    if (attr) {\n      try {\n        props = JSON.parse(attr);\n      } catch (e) {\n        if (process.env.NODE_ENV === 'development') {\n          console.error(`data-tabster attribute error: ${e}`, element);\n        }\n      }\n    }\n  }\n\n  if (!props) {\n    props = {};\n  }\n\n  mergeTabsterProps(props, newProps);\n\n  if (Object.keys(props).length > 0) {\n    element.setAttribute(TabsterAttributeName, getTabsterAttribute(props, true));\n  } else {\n    element.removeAttribute(TabsterAttributeName);\n  }\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nfunction _setInformativeStyle$3(weakElement, remove, id) {\n  if (process.env.NODE_ENV === 'development') {\n    const element = weakElement.get();\n\n    if (element) {\n      if (remove) {\n        element.style.removeProperty(\"--tabster-root\");\n      } else {\n        element.style.setProperty(\"--tabster-root\", id + \",\");\n      }\n    }\n  }\n}\n\nclass RootDummyManager extends DummyInputManager {\n  constructor(tabster, element, setFocused, sys) {\n    super(tabster, element, DummyInputManagerPriorities.Root, sys, undefined, true);\n\n    this._onDummyInputFocus = dummyInput => {\n      var _a;\n\n      if (dummyInput.useDefaultAction) {\n        // When we've reached the last focusable element, we want to let the browser\n        // to move the focus outside of the page. In order to do that we're synchronously\n        // calling focus() of the dummy input from the Tab key handler and allowing\n        // the default action to move the focus out.\n        this._setFocused(false, true);\n      } else {\n        // The only way a dummy input gets focused is during the keyboard navigation.\n        this._tabster.keyboardNavigation.setNavigatingWithKeyboard(true);\n\n        const element = this._element.get();\n\n        if (element) {\n          this._setFocused(true, true);\n\n          const toFocus = this._tabster.focusedElement.getFirstOrLastTabbable(dummyInput.isFirst, {\n            container: element,\n            ignoreAccessibility: true\n          });\n\n          if (toFocus) {\n            nativeFocus(toFocus);\n            return;\n          }\n        }\n\n        (_a = dummyInput.input) === null || _a === void 0 ? void 0 : _a.blur();\n      }\n    };\n\n    this._setHandlers(this._onDummyInputFocus);\n\n    this._tabster = tabster;\n    this._setFocused = setFocused;\n  }\n\n}\n\nclass Root extends TabsterPart {\n  constructor(tabster, element, onDispose, props, sys) {\n    super(tabster, element, props);\n    this._isFocused = false;\n\n    this._setFocused = (hasFocused, fromAdjacent) => {\n      if (this._setFocusedTimer) {\n        this._tabster.getWindow().clearTimeout(this._setFocusedTimer);\n\n        delete this._setFocusedTimer;\n      }\n\n      if (this._isFocused === hasFocused) {\n        return;\n      }\n\n      const element = this._element.get();\n\n      if (element) {\n        if (hasFocused) {\n          this._isFocused = true;\n          triggerEvent(this._tabster.root.eventTarget, \"focus\", {\n            element,\n            fromAdjacent\n          });\n        } else {\n          this._setFocusedTimer = this._tabster.getWindow().setTimeout(() => {\n            delete this._setFocusedTimer;\n            this._isFocused = false;\n            triggerEvent(this._tabster.root.eventTarget, \"blur\", {\n              element,\n              fromAdjacent\n            });\n          }, 0);\n        }\n      }\n    };\n\n    this._onFocus = e => {\n      var _a;\n\n      const win = this._tabster.getWindow();\n\n      if (this._setTabbableTimer) {\n        win.clearTimeout(this._setTabbableTimer);\n        delete this._setTabbableTimer;\n      }\n\n      if (e) {\n        const ctx = RootAPI.getTabsterContext(this._tabster, e);\n\n        if (ctx) {\n          this._setFocused(ctx.root.getElement() === this._element.get());\n        }\n\n        if (!ctx || ctx.uncontrolled || this._tabster.rootDummyInputs) {\n          (_a = this._dummyManager) === null || _a === void 0 ? void 0 : _a.setTabbable(false);\n          return;\n        }\n      } else {\n        this._setFocused(false);\n      }\n\n      this._setTabbableTimer = win.setTimeout(() => {\n        var _a;\n\n        delete this._setTabbableTimer;\n        (_a = this._dummyManager) === null || _a === void 0 ? void 0 : _a.setTabbable(true);\n      }, 0);\n    };\n\n    this._onDispose = onDispose;\n    const win = tabster.getWindow;\n    this.uid = getElementUId(win, element);\n    this._sys = sys;\n\n    if (tabster.controlTab || tabster.rootDummyInputs) {\n      this.addDummyInputs();\n    }\n\n    tabster.focusedElement.subscribe(this._onFocus);\n\n    this._add();\n  }\n\n  addDummyInputs() {\n    if (!this._dummyManager) {\n      this._dummyManager = new RootDummyManager(this._tabster, this._element, this._setFocused, this._sys);\n    }\n  }\n\n  dispose() {\n    var _a;\n\n    this._onDispose(this);\n\n    const win = this._tabster.getWindow();\n\n    if (this._setFocusedTimer) {\n      win.clearTimeout(this._setFocusedTimer);\n      delete this._setFocusedTimer;\n    }\n\n    if (this._setTabbableTimer) {\n      win.clearTimeout(this._setTabbableTimer);\n      delete this._setTabbableTimer;\n    }\n\n    (_a = this._dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();\n\n    this._remove();\n  }\n\n  moveOutWithDefaultAction(isBackward) {\n    const dummyManager = this._dummyManager;\n\n    if (dummyManager) {\n      dummyManager.moveOutWithDefaultAction(isBackward);\n    } else {\n      const el = this.getElement();\n\n      if (el) {\n        RootDummyManager.moveWithPhantomDummy(this._tabster, el, true, isBackward);\n      }\n    }\n  }\n\n  _add() {\n    if (process.env.NODE_ENV === 'development') {\n      _setInformativeStyle$3(this._element, false, this.uid);\n    }\n  }\n\n  _remove() {\n    if (process.env.NODE_ENV === 'development') {\n      _setInformativeStyle$3(this._element, true);\n    }\n  }\n\n} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\nclass RootAPI {\n  constructor(tabster, autoRoot) {\n    this._autoRootWaiting = false;\n    this._roots = {};\n    this._forceDummy = false;\n    this.rootById = {};\n\n    this._autoRootCreate = () => {\n      var _a;\n\n      const doc = this._win().document;\n\n      const body = doc.body;\n\n      if (body) {\n        this._autoRootUnwait(doc);\n\n        const props = this._autoRoot;\n\n        if (props) {\n          setTabsterAttribute(body, {\n            root: props\n          }, true);\n          updateTabsterByAttribute(this._tabster, body);\n          return (_a = getTabsterOnElement(this._tabster, body)) === null || _a === void 0 ? void 0 : _a.root;\n        }\n      } else if (!this._autoRootWaiting) {\n        this._autoRootWaiting = true;\n        doc.addEventListener(\"readystatechange\", this._autoRootCreate);\n      }\n\n      return undefined;\n    };\n\n    this._onRootDispose = root => {\n      delete this._roots[root.id];\n    };\n\n    this._tabster = tabster;\n    this._win = tabster.getWindow;\n    this._autoRoot = autoRoot;\n    this.eventTarget = createEventTarget(this._win);\n    tabster.queueInit(() => {\n      if (this._autoRoot) {\n        this._autoRootCreate();\n      }\n    });\n  }\n\n  _autoRootUnwait(doc) {\n    doc.removeEventListener(\"readystatechange\", this._autoRootCreate);\n    this._autoRootWaiting = false;\n  }\n\n  dispose() {\n    const win = this._win();\n\n    this._autoRootUnwait(win.document);\n\n    delete this._autoRoot;\n    Object.keys(this._roots).forEach(rootId => {\n      if (this._roots[rootId]) {\n        this._roots[rootId].dispose();\n\n        delete this._roots[rootId];\n      }\n    });\n    this.rootById = {};\n  }\n\n  createRoot(element, props, sys) {\n    if (process.env.NODE_ENV === 'development') ;\n\n    const newRoot = new Root(this._tabster, element, this._onRootDispose, props, sys);\n    this._roots[newRoot.id] = newRoot;\n\n    if (this._forceDummy) {\n      newRoot.addDummyInputs();\n    }\n\n    return newRoot;\n  }\n\n  addDummyInputs() {\n    this._forceDummy = true;\n    const roots = this._roots;\n\n    for (const id of Object.keys(roots)) {\n      roots[id].addDummyInputs();\n    }\n  }\n\n  static getRootByUId(getWindow, id) {\n    const tabster = getWindow().__tabsterInstance;\n\n    return tabster && tabster.root.rootById[id];\n  }\n  /**\r\n   * Fetches the tabster context for an element walking up its ancestors\r\n   *\r\n   * @param tabster Tabster instance\r\n   * @param element The element the tabster context should represent\r\n   * @param options Additional options\r\n   * @returns undefined if the element is not a child of a tabster root, otherwise all applicable tabster behaviours and configurations\r\n   */\n\n\n  static getTabsterContext(tabster, element, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _a, _b, _c, _d;\n\n    if (!element.ownerDocument) {\n      return undefined;\n    } // Normally, the initialization starts on the next tick after the tabster\n    // instance creation. However, if the application starts using it before\n    // the next tick, we need to make sure the initialization is done.\n\n\n    tabster.drainInitQueue();\n    const checkRtl = options.checkRtl;\n    let root;\n    let modalizer;\n    let groupper;\n    let mover;\n    let isExcludedFromMover = false;\n    let isGroupperFirst;\n    let modalizerInGroupper;\n    let isRtl;\n    let uncontrolled;\n    let curElement = element;\n    const ignoreKeydown = {};\n\n    while (curElement && (!root || checkRtl)) {\n      const tabsterOnElement = getTabsterOnElement(tabster, curElement);\n\n      if (checkRtl && isRtl === undefined) {\n        const dir = curElement.dir;\n\n        if (dir) {\n          isRtl = dir.toLowerCase() === \"rtl\";\n        }\n      }\n\n      if (!tabsterOnElement) {\n        curElement = curElement.parentElement;\n        continue;\n      }\n\n      const tagName = curElement.tagName;\n\n      if (tabsterOnElement.uncontrolled || tagName === \"IFRAME\" || tagName === \"WEBVIEW\") {\n        uncontrolled = curElement;\n      }\n\n      if (!mover && ((_a = tabsterOnElement.focusable) === null || _a === void 0 ? void 0 : _a.excludeFromMover) && !groupper) {\n        isExcludedFromMover = true;\n      }\n\n      const curModalizer = tabsterOnElement.modalizer;\n      const curGroupper = tabsterOnElement.groupper;\n      const curMover = tabsterOnElement.mover;\n\n      if (!modalizer && curModalizer) {\n        modalizer = curModalizer;\n      }\n\n      if (!groupper && curGroupper && (!modalizer || curModalizer)) {\n        if (modalizer) {\n          // Modalizer dominates the groupper when they are on the same node and the groupper is active.\n          if (!curGroupper.isActive() && curGroupper.getProps().tabbability && modalizer.userId !== ((_b = tabster.modalizer) === null || _b === void 0 ? void 0 : _b.activeId)) {\n            modalizer = undefined;\n            groupper = curGroupper;\n          }\n\n          modalizerInGroupper = curGroupper;\n        } else {\n          groupper = curGroupper;\n        }\n      }\n\n      if (!mover && curMover && (!modalizer || curModalizer) && (!curGroupper || curElement !== element)) {\n        mover = curMover;\n        isGroupperFirst = !!groupper && groupper !== curGroupper;\n      }\n\n      if (tabsterOnElement.root) {\n        root = tabsterOnElement.root;\n      }\n\n      if ((_c = tabsterOnElement.focusable) === null || _c === void 0 ? void 0 : _c.ignoreKeydown) {\n        Object.assign(ignoreKeydown, tabsterOnElement.focusable.ignoreKeydown);\n      }\n\n      curElement = curElement.parentElement;\n    } // No root element could be found, try to get an auto root\n\n\n    if (!root) {\n      const rootAPI = tabster.root;\n      const autoRoot = rootAPI._autoRoot;\n\n      if (autoRoot) {\n        if ((_d = element.ownerDocument) === null || _d === void 0 ? void 0 : _d.body) {\n          root = rootAPI._autoRootCreate();\n        }\n      }\n    }\n\n    if (groupper && !mover) {\n      isGroupperFirst = true;\n    }\n\n    if (process.env.NODE_ENV === 'development' && !root) {\n      if (modalizer || groupper || mover) {\n        console.error(\"Tabster Root is required for Mover, Groupper and Modalizer to work.\");\n      }\n    }\n\n    const shouldIgnoreKeydown = event => !!ignoreKeydown[event.key];\n\n    return root ? {\n      root,\n      modalizer,\n      groupper,\n      mover,\n      isGroupperFirst,\n      modalizerInGroupper,\n      isRtl: checkRtl ? !!isRtl : undefined,\n      uncontrolled,\n      isExcludedFromMover,\n      ignoreKeydown: shouldIgnoreKeydown\n    } : undefined;\n  }\n\n  static getRoot(tabster, element) {\n    var _a;\n\n    for (let el = element; el; el = el.parentElement) {\n      const root = (_a = getTabsterOnElement(tabster, el)) === null || _a === void 0 ? void 0 : _a.root;\n\n      if (root) {\n        return root;\n      }\n    }\n\n    return undefined;\n  }\n\n  onRoot(root, removed) {\n    if (removed) {\n      delete this.rootById[root.uid];\n    } else {\n      this.rootById[root.uid] = root;\n    }\n  }\n\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst _containerHistoryLength = 10;\nclass DeloserItemBase {}\nclass DeloserItem extends DeloserItemBase {\n  constructor(tabster, deloser) {\n    super();\n    this.uid = deloser.uid;\n    this._tabster = tabster;\n    this._deloser = deloser;\n  }\n\n  belongsTo(deloser) {\n    return deloser === this._deloser;\n  }\n\n  unshift(element) {\n    this._deloser.unshift(element);\n  }\n\n  async focusAvailable() {\n    const available = this._deloser.findAvailable();\n\n    return available ? this._tabster.focusedElement.focus(available) : false;\n  }\n\n  async resetFocus() {\n    const getWindow = this._tabster.getWindow;\n    return getPromise(getWindow).resolve(this._deloser.resetFocus());\n  }\n\n}\nclass DeloserHistoryByRootBase {\n  constructor(tabster, rootUId) {\n    this._history = [];\n    this._tabster = tabster;\n    this.rootUId = rootUId;\n  }\n\n  getLength() {\n    return this._history.length;\n  }\n\n  removeDeloser(deloser) {\n    this._history = this._history.filter(c => !c.belongsTo(deloser));\n  }\n\n  hasDeloser(deloser) {\n    return this._history.some(d => d.belongsTo(deloser));\n  }\n\n}\n\nclass DeloserHistoryByRoot extends DeloserHistoryByRootBase {\n  unshiftToDeloser(deloser, element) {\n    let item;\n\n    for (let i = 0; i < this._history.length; i++) {\n      if (this._history[i].belongsTo(deloser)) {\n        item = this._history[i];\n\n        this._history.splice(i, 1);\n\n        break;\n      }\n    }\n\n    if (!item) {\n      item = new DeloserItem(this._tabster, deloser);\n    }\n\n    item.unshift(element);\n\n    this._history.unshift(item);\n\n    this._history.splice(_containerHistoryLength, this._history.length - _containerHistoryLength);\n  }\n\n  async focusAvailable(from) {\n    let skip = !!from;\n\n    for (const i of this._history) {\n      if (from && i.belongsTo(from)) {\n        skip = false;\n      }\n\n      if (!skip && (await i.focusAvailable())) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  async resetFocus(from) {\n    let skip = !!from;\n    const resetQueue = {};\n\n    for (const i of this._history) {\n      if (from && i.belongsTo(from)) {\n        skip = false;\n      }\n\n      if (!skip && !resetQueue[i.uid]) {\n        resetQueue[i.uid] = i;\n      }\n    } // Nothing is found, at least try to reset.\n\n\n    for (const id of Object.keys(resetQueue)) {\n      if (await resetQueue[id].resetFocus()) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n}\n\nclass DeloserHistory {\n  constructor(tabster) {\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    this._history = [];\n    this._tabster = tabster;\n  }\n\n  dispose() {\n    this._history = [];\n  }\n\n  process(element) {\n    var _a;\n\n    const ctx = RootAPI.getTabsterContext(this._tabster, element);\n    const rootUId = ctx && ctx.root.uid;\n    const deloser = DeloserAPI.getDeloser(this._tabster, element);\n\n    if (!rootUId || !deloser) {\n      return undefined;\n    }\n\n    const historyByRoot = this.make(rootUId, () => new DeloserHistoryByRoot(this._tabster, rootUId));\n\n    if (!ctx || !ctx.modalizer || ((_a = ctx.modalizer) === null || _a === void 0 ? void 0 : _a.isActive())) {\n      historyByRoot.unshiftToDeloser(deloser, element);\n    }\n\n    return deloser;\n  }\n\n  make(rootUId, createInstance) {\n    let historyByRoot;\n\n    for (let i = 0; i < this._history.length; i++) {\n      const hbr = this._history[i];\n\n      if (hbr.rootUId === rootUId) {\n        historyByRoot = hbr;\n\n        this._history.splice(i, 1);\n\n        break;\n      }\n    }\n\n    if (!historyByRoot) {\n      historyByRoot = createInstance();\n    }\n\n    this._history.unshift(historyByRoot);\n\n    this._history.splice(_containerHistoryLength, this._history.length - _containerHistoryLength);\n\n    return historyByRoot;\n  }\n\n  removeDeloser(deloser) {\n    this._history.forEach(i => {\n      i.removeDeloser(deloser);\n    });\n\n    this._history = this._history.filter(i => i.getLength() > 0);\n  }\n\n  async focusAvailable(from) {\n    let skip = !!from;\n\n    for (const h of this._history) {\n      if (from && h.hasDeloser(from)) {\n        skip = false;\n      }\n\n      if (!skip && (await h.focusAvailable(from))) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  async resetFocus(from) {\n    let skip = !!from;\n\n    for (const h of this._history) {\n      if (from && h.hasDeloser(from)) {\n        skip = false;\n      }\n\n      if (!skip && (await h.resetFocus(from))) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n}\n\nfunction _setInformativeStyle$2(weakElement, remove, isActive, snapshotIndex) {\n  if (process.env.NODE_ENV === 'development') {\n    const element = weakElement.get();\n\n    if (element) {\n      if (remove) {\n        element.style.removeProperty(\"--tabster-deloser\");\n      } else {\n        element.style.setProperty(\"--tabster-deloser\", (isActive ? \"active\" : \"inactive\") + \",\" + (\"snapshot-\" + snapshotIndex));\n      }\n    }\n  }\n}\n\nfunction buildElementSelector(element, withClass, withIndex) {\n  const selector = [];\n  const escapeRegExp = /(:|\\.|\\[|\\]|,|=|@)/g;\n  const escapeReplaceValue = \"\\\\$1\";\n\n  if (element.id) {\n    selector.push(\"#\" + element.id.replace(escapeRegExp, escapeReplaceValue));\n  }\n\n  if (withClass !== false && element.className) {\n    element.className.split(\" \").forEach(cls => {\n      cls = cls.trim();\n\n      if (cls) {\n        selector.push(\".\" + cls.replace(escapeRegExp, escapeReplaceValue));\n      }\n    });\n  }\n\n  let index = 0;\n  let el;\n\n  if (withIndex !== false && selector.length === 0) {\n    el = element;\n\n    while (el) {\n      index++;\n      el = el.previousElementSibling;\n    }\n\n    selector.unshift(\":nth-child(\" + index + \")\");\n  }\n\n  selector.unshift(element.tagName.toLowerCase());\n  return selector.join(\"\");\n}\n\nfunction buildSelector(element) {\n  if (!documentContains(element.ownerDocument, element)) {\n    return undefined;\n  }\n\n  const selector = [buildElementSelector(element)];\n  let el = element.parentElement;\n\n  while (el) {\n    const isBody = el.tagName === \"BODY\";\n    selector.unshift(buildElementSelector(el, false, !isBody));\n\n    if (isBody) {\n      break;\n    }\n\n    el = el.parentElement;\n  }\n\n  return selector.join(\" \");\n}\n\nclass Deloser extends TabsterPart {\n  constructor(tabster, element, onDispose, props) {\n    super(tabster, element, props);\n    this._isActive = false;\n    this._history = [[]];\n    this._snapshotIndex = 0;\n\n    this.isActive = () => {\n      return this._isActive;\n    };\n\n    this.setSnapshot = index => {\n      this._snapshotIndex = index;\n\n      if (this._history.length > index + 1) {\n        this._history.splice(index + 1, this._history.length - index - 1);\n      }\n\n      if (!this._history[index]) {\n        this._history[index] = [];\n      }\n\n      if (process.env.NODE_ENV === 'development') {\n        _setInformativeStyle$2(this._element, false, this._isActive, this._snapshotIndex);\n      }\n    };\n\n    this.focusFirst = () => {\n      const e = this._element.get();\n\n      return !!e && this._tabster.focusedElement.focusFirst({\n        container: e\n      });\n    };\n\n    this.focusDefault = () => {\n      const e = this._element.get();\n\n      return !!e && this._tabster.focusedElement.focusDefault(e);\n    };\n\n    this.resetFocus = () => {\n      const e = this._element.get();\n\n      return !!e && this._tabster.focusedElement.resetFocus(e);\n    };\n\n    this.clearHistory = preserveExisting => {\n      const element = this._element.get();\n\n      if (!element) {\n        this._history[this._snapshotIndex] = [];\n        return;\n      }\n\n      this._history[this._snapshotIndex] = this._history[this._snapshotIndex].filter(we => {\n        const e = we.get();\n        return e && preserveExisting ? element.contains(e) : false;\n      });\n    };\n\n    this.uid = getElementUId(tabster.getWindow, element);\n    this._onDispose = onDispose;\n\n    if (process.env.NODE_ENV === 'development') {\n      _setInformativeStyle$2(this._element, false, this._isActive, this._snapshotIndex);\n    }\n  }\n\n  dispose() {\n    this._remove();\n\n    this._onDispose(this);\n\n    this._isActive = false;\n    this._snapshotIndex = 0;\n    this._props = {};\n    this._history = [];\n  }\n\n  setActive(active) {\n    this._isActive = active;\n\n    if (process.env.NODE_ENV === 'development') {\n      _setInformativeStyle$2(this._element, false, this._isActive, this._snapshotIndex);\n    }\n  }\n\n  getActions() {\n    return {\n      focusDefault: this.focusDefault,\n      focusFirst: this.focusFirst,\n      resetFocus: this.resetFocus,\n      clearHistory: this.clearHistory,\n      setSnapshot: this.setSnapshot,\n      isActive: this.isActive\n    };\n  }\n\n  unshift(element) {\n    let cur = this._history[this._snapshotIndex];\n    cur = this._history[this._snapshotIndex] = cur.filter(we => {\n      const e = we.get();\n      return e && e !== element;\n    });\n    cur.unshift(new WeakHTMLElement(this._tabster.getWindow, element, buildSelector(element)));\n\n    while (cur.length > _containerHistoryLength) {\n      cur.pop();\n    }\n  }\n\n  findAvailable() {\n    const element = this._element.get();\n\n    if (!element || !this._tabster.focusable.isVisible(element)) {\n      return null;\n    }\n\n    let restoreFocusOrder = this._props.restoreFocusOrder;\n    let available = null;\n    const ctx = RootAPI.getTabsterContext(this._tabster, element);\n\n    if (!ctx) {\n      return null;\n    }\n\n    const root = ctx.root;\n    const rootElement = root.getElement();\n\n    if (!rootElement) {\n      return null;\n    }\n\n    if (restoreFocusOrder === undefined) {\n      restoreFocusOrder = root.getProps().restoreFocusOrder;\n    }\n\n    if (restoreFocusOrder === RestoreFocusOrders.RootDefault) {\n      available = this._tabster.focusable.findDefault({\n        container: rootElement\n      });\n    }\n\n    if (!available && restoreFocusOrder === RestoreFocusOrders.RootFirst) {\n      available = this._findFirst(rootElement);\n    }\n\n    if (available) {\n      return available;\n    }\n\n    const availableInHistory = this._findInHistory();\n\n    const availableDefault = this._tabster.focusable.findDefault({\n      container: element\n    });\n\n    const availableFirst = this._findFirst(element);\n\n    if (availableInHistory && restoreFocusOrder === RestoreFocusOrders.History) {\n      return availableInHistory;\n    }\n\n    if (availableDefault && restoreFocusOrder === RestoreFocusOrders.DeloserDefault) {\n      return availableDefault;\n    }\n\n    if (availableFirst && restoreFocusOrder === RestoreFocusOrders.DeloserFirst) {\n      return availableFirst;\n    }\n\n    return availableDefault || availableInHistory || availableFirst || null;\n  }\n\n  customFocusLostHandler(element) {\n    return triggerEvent(element, DeloserEventName, this.getActions());\n  }\n\n  _findInHistory() {\n    const cur = this._history[this._snapshotIndex].slice(0);\n\n    this.clearHistory(true);\n\n    for (let i = 0; i < cur.length; i++) {\n      const we = cur[i];\n      const e = we.get();\n\n      const element = this._element.get();\n\n      if (e && element && element.contains(e)) {\n        if (this._tabster.focusable.isFocusable(e)) {\n          return e;\n        }\n      } else if (!this._props.noSelectorCheck) {\n        // Element is not in the DOM, try to locate the node by it's\n        // selector. This might return not exactly the right node,\n        // but it would be easily fixable by having more detailed selectors.\n        const selector = we.getData();\n\n        if (selector && element) {\n          let els;\n\n          try {\n            els = element.ownerDocument.querySelectorAll(selector);\n          } catch (e) {\n            if (process.env.NODE_ENV === 'development') {\n              // This should never happen, unless there is some bug in buildElementSelector().\n              console.error(`Failed to querySelectorAll('${selector}')`);\n            }\n\n            continue;\n          }\n\n          for (let i = 0; i < els.length; i++) {\n            const el = els[i];\n\n            if (el && this._tabster.focusable.isFocusable(el)) {\n              return el;\n            }\n          }\n        }\n      }\n    }\n\n    return null;\n  }\n\n  _findFirst(element) {\n    if (this._tabster.keyboardNavigation.isNavigatingWithKeyboard()) {\n      const first = this._tabster.focusable.findFirst({\n        container: element,\n        ignoreUncontrolled: true,\n        useActiveModalizer: true\n      });\n\n      if (first) {\n        return first;\n      }\n    }\n\n    return null;\n  }\n\n  _remove() {\n    if (process.env.NODE_ENV === 'development') {\n      _setInformativeStyle$2(this._element, true);\n    }\n  }\n\n} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\nclass DeloserAPI {\n  constructor(tabster, props) {\n    /**\r\n     * Tracks if focus is inside a deloser\r\n     */\n    this._inDeloser = false;\n    this._isRestoringFocus = false;\n    this._isPaused = false;\n\n    this._onFocus = e => {\n      if (this._restoreFocusTimer) {\n        this._win().clearTimeout(this._restoreFocusTimer);\n\n        this._restoreFocusTimer = undefined;\n      }\n\n      if (!e) {\n        this._scheduleRestoreFocus();\n\n        return;\n      }\n\n      const deloser = this._history.process(e);\n\n      if (deloser) {\n        this._activate(deloser);\n      } else {\n        this._deactivate();\n      }\n    };\n\n    this._onDeloserDispose = deloser => {\n      this._history.removeDeloser(deloser);\n\n      if (deloser.isActive()) {\n        this._scheduleRestoreFocus();\n      }\n    };\n\n    this._tabster = tabster;\n    this._win = tabster.getWindow;\n    this._history = new DeloserHistory(tabster);\n    tabster.queueInit(() => {\n      this._tabster.focusedElement.subscribe(this._onFocus);\n\n      const doc = this._win().document;\n\n      const activeElement = doc.activeElement;\n\n      if (activeElement && activeElement !== doc.body) {\n        // Adding currently focused element to the deloser history.\n        this._onFocus(activeElement);\n      }\n    });\n    const autoDeloser = props === null || props === void 0 ? void 0 : props.autoDeloser;\n\n    if (autoDeloser) {\n      this._autoDeloser = autoDeloser;\n    }\n  }\n\n  dispose() {\n    const win = this._win();\n\n    if (this._restoreFocusTimer) {\n      win.clearTimeout(this._restoreFocusTimer);\n      this._restoreFocusTimer = undefined;\n    }\n\n    if (this._autoDeloserInstance) {\n      this._autoDeloserInstance.dispose();\n\n      delete this._autoDeloserInstance;\n      delete this._autoDeloser;\n    }\n\n    this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n    this._history.dispose();\n\n    delete this._curDeloser;\n  }\n\n  createDeloser(element, props) {\n    var _a;\n\n    if (process.env.NODE_ENV === 'development') ;\n\n    const deloser = new Deloser(this._tabster, element, this._onDeloserDispose, props);\n\n    if (element.contains((_a = this._tabster.focusedElement.getFocusedElement()) !== null && _a !== void 0 ? _a : null)) {\n      this._activate(deloser);\n    }\n\n    return deloser;\n  }\n\n  getActions(element) {\n    for (let e = element; e; e = e.parentElement) {\n      const tabsterOnElement = getTabsterOnElement(this._tabster, e);\n\n      if (tabsterOnElement && tabsterOnElement.deloser) {\n        return tabsterOnElement.deloser.getActions();\n      }\n    }\n\n    return undefined;\n  }\n\n  pause() {\n    this._isPaused = true;\n\n    if (this._restoreFocusTimer) {\n      this._win().clearTimeout(this._restoreFocusTimer);\n\n      this._restoreFocusTimer = undefined;\n    }\n  }\n\n  resume(restore) {\n    this._isPaused = false;\n\n    if (restore) {\n      this._scheduleRestoreFocus();\n    }\n  }\n  /**\r\n   * Activates and sets the current deloser\r\n   */\n\n\n  _activate(deloser) {\n    const curDeloser = this._curDeloser;\n\n    if (curDeloser !== deloser) {\n      this._inDeloser = true;\n      curDeloser === null || curDeloser === void 0 ? void 0 : curDeloser.setActive(false);\n      deloser.setActive(true);\n      this._curDeloser = deloser;\n    }\n  }\n  /**\r\n   * Called when focus should no longer be in a deloser\r\n   */\n\n\n  _deactivate() {\n    var _a;\n\n    this._inDeloser = false;\n    (_a = this._curDeloser) === null || _a === void 0 ? void 0 : _a.setActive(false);\n    this._curDeloser = undefined;\n  }\n\n  _scheduleRestoreFocus(force) {\n    if (this._isPaused || this._isRestoringFocus) {\n      return;\n    }\n\n    const restoreFocus = async () => {\n      this._restoreFocusTimer = undefined;\n\n      const lastFocused = this._tabster.focusedElement.getLastFocusedElement();\n\n      if (!force && (this._isRestoringFocus || !this._inDeloser || !!(lastFocused === null || lastFocused === void 0 ? void 0 : lastFocused.offsetParent))) {\n        return;\n      }\n\n      const curDeloser = this._curDeloser;\n\n      if (curDeloser) {\n        if (lastFocused && curDeloser.customFocusLostHandler(lastFocused)) {\n          return;\n        }\n\n        const el = curDeloser.findAvailable();\n\n        if (el && this._tabster.focusedElement.focus(el)) {\n          return;\n        }\n      }\n\n      this._deactivate();\n\n      this._isRestoringFocus = true;\n\n      if (!(await this._history.focusAvailable(null))) {\n        await this._history.resetFocus(null);\n      }\n\n      this._isRestoringFocus = false;\n    };\n\n    if (force) {\n      restoreFocus();\n    } else {\n      this._restoreFocusTimer = this._win().setTimeout(restoreFocus, 100);\n    }\n  }\n\n  static getDeloser(tabster, element) {\n    var _a;\n\n    let root;\n\n    for (let e = element; e; e = e.parentElement) {\n      const tabsterOnElement = getTabsterOnElement(tabster, e);\n\n      if (tabsterOnElement) {\n        if (!root) {\n          root = tabsterOnElement.root;\n        }\n\n        const deloser = tabsterOnElement.deloser;\n\n        if (deloser) {\n          return deloser;\n        }\n      }\n    }\n\n    const deloserAPI = tabster.deloser && tabster.deloser;\n\n    if (deloserAPI) {\n      if (deloserAPI._autoDeloserInstance) {\n        return deloserAPI._autoDeloserInstance;\n      }\n\n      const autoDeloserProps = deloserAPI._autoDeloser;\n\n      if (root && !deloserAPI._autoDeloserInstance && autoDeloserProps) {\n        const body = (_a = element.ownerDocument) === null || _a === void 0 ? void 0 : _a.body;\n\n        if (body) {\n          deloserAPI._autoDeloserInstance = new Deloser(tabster, body, tabster.deloser._onDeloserDispose, autoDeloserProps);\n        }\n      }\n\n      return deloserAPI._autoDeloserInstance;\n    }\n\n    return undefined;\n  }\n\n  static getHistory(instance) {\n    return instance._history;\n  }\n\n  static forceRestoreFocus(instance) {\n    instance._scheduleRestoreFocus(true);\n  }\n\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nclass Subscribable {\n  constructor() {\n    this._callbacks = [];\n  }\n\n  dispose() {\n    this._callbacks = [];\n    delete this._val;\n  }\n\n  subscribe(callback) {\n    const callbacks = this._callbacks;\n    const index = callbacks.indexOf(callback);\n\n    if (index < 0) {\n      callbacks.push(callback);\n    }\n  }\n\n  subscribeFirst(callback) {\n    const callbacks = this._callbacks;\n    const index = callbacks.indexOf(callback);\n\n    if (index >= 0) {\n      callbacks.splice(index, 1);\n    }\n\n    callbacks.unshift(callback);\n  }\n\n  unsubscribe(callback) {\n    const index = this._callbacks.indexOf(callback);\n\n    if (index >= 0) {\n      this._callbacks.splice(index, 1);\n    }\n  }\n\n  setVal(val, details) {\n    if (this._val === val) {\n      return;\n    }\n\n    this._val = val;\n\n    this._callCallbacks(val, details);\n  }\n\n  getVal() {\n    return this._val;\n  }\n\n  trigger(val, details) {\n    this._callCallbacks(val, details);\n  }\n\n  _callCallbacks(val, details) {\n    this._callbacks.forEach(callback => callback(val, details));\n  }\n\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst _transactionTimeout = 1500;\nconst _pingTimeout = 3000;\nconst _targetIdUp = \"up\";\nconst CrossOriginTransactionTypes = {\n  Bootstrap: 1,\n  FocusElement: 2,\n  State: 3,\n  GetElement: 4,\n  RestoreFocusInDeloser: 5,\n  Ping: 6\n};\n\nclass CrossOriginDeloserItem extends DeloserItemBase {\n  constructor(tabster, deloser, trasactions) {\n    super();\n    this._deloser = deloser;\n    this._transactions = trasactions;\n  }\n\n  belongsTo(deloser) {\n    return deloser.deloserUId === this._deloser.deloserUId;\n  }\n\n  async focusAvailable() {\n    const data = { ...this._deloser,\n      reset: false\n    };\n    return this._transactions.beginTransaction(RestoreFocusInDeloserTransaction, data).then(value => !!value);\n  }\n\n  async resetFocus() {\n    const data = { ...this._deloser,\n      reset: true\n    };\n    return this._transactions.beginTransaction(RestoreFocusInDeloserTransaction, data).then(value => !!value);\n  }\n\n}\n\nclass CrossOriginDeloserHistoryByRoot extends DeloserHistoryByRootBase {\n  constructor(tabster, rootUId, transactions) {\n    super(tabster, rootUId);\n    this._transactions = transactions;\n  }\n\n  unshift(deloser) {\n    let item;\n\n    for (let i = 0; i < this._history.length; i++) {\n      if (this._history[i].belongsTo(deloser)) {\n        item = this._history[i];\n\n        this._history.splice(i, 1);\n\n        break;\n      }\n    }\n\n    if (!item) {\n      item = new CrossOriginDeloserItem(this._tabster, deloser, this._transactions);\n    }\n\n    this._history.unshift(item);\n\n    this._history.splice(10, this._history.length - 10);\n  }\n\n  async focusAvailable() {\n    for (const i of this._history) {\n      if (await i.focusAvailable()) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  async resetFocus() {\n    for (const i of this._history) {\n      if (await i.resetFocus()) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n}\n\nclass CrossOriginTransaction {\n  constructor(tabster, getOwner, knownTargets, value, timeout, sentTo, targetId, sendUp) {\n    this._inProgress = {};\n    this._isDone = false;\n    this._isSelfResponding = false;\n    this._sentCount = 0;\n    this.tabster = tabster;\n    this.owner = getOwner;\n    this.ownerId = getWindowUId(getOwner());\n    this.id = getUId(getOwner());\n    this.beginData = value;\n    this._knownTargets = knownTargets;\n    this._sentTo = sentTo || {\n      [this.ownerId]: true\n    };\n    this.targetId = targetId;\n    this.sendUp = sendUp;\n    this.timeout = timeout;\n    this._promise = new (getPromise(getOwner))((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n  }\n\n  getTargets(knownTargets) {\n    return this.targetId === _targetIdUp ? this.sendUp ? {\n      [_targetIdUp]: {\n        send: this.sendUp\n      }\n    } : null : this.targetId ? knownTargets[this.targetId] ? {\n      [this.targetId]: {\n        send: knownTargets[this.targetId].send\n      }\n    } : null : Object.keys(knownTargets).length === 0 && this.sendUp ? {\n      [_targetIdUp]: {\n        send: this.sendUp\n      }\n    } : Object.keys(knownTargets).length > 0 ? knownTargets : null;\n  }\n\n  begin(selfResponse) {\n    const targets = this.getTargets(this._knownTargets);\n    const sentTo = { ...this._sentTo\n    };\n\n    if (targets) {\n      for (const id of Object.keys(targets)) {\n        sentTo[id] = true;\n      }\n    }\n\n    const data = {\n      transaction: this.id,\n      type: this.type,\n      isResponse: false,\n      timestamp: Date.now(),\n      owner: this.ownerId,\n      sentto: sentTo,\n      timeout: this.timeout,\n      beginData: this.beginData\n    };\n\n    if (this.targetId) {\n      data.target = this.targetId;\n    }\n\n    if (selfResponse) {\n      this._isSelfResponding = true;\n      selfResponse(data).then(value => {\n        this._isSelfResponding = false;\n\n        if (value !== undefined) {\n          if (!this.endData) {\n            this.endData = value;\n          }\n        }\n\n        if (this.endData || this._sentCount === 0) {\n          this.end();\n        }\n      });\n    }\n\n    if (targets) {\n      for (const id of Object.keys(targets)) {\n        if (!(id in this._sentTo)) {\n          this._send(targets[id].send, id, data);\n        }\n      }\n    }\n\n    if (this._sentCount === 0 && !this._isSelfResponding) {\n      this.end();\n    }\n\n    return this._promise;\n  }\n\n  _send(send, targetId, data) {\n    if (this._inProgress[targetId] === undefined) {\n      this._inProgress[targetId] = true;\n      this._sentCount++;\n      send(data);\n    }\n  }\n\n  end(error) {\n    if (this._isDone) {\n      return;\n    }\n\n    this._isDone = true;\n\n    if (this.endData === undefined && error) {\n      if (this._reject) {\n        this._reject(error);\n      }\n    } else if (this._resolve) {\n      this._resolve(this.endData);\n    }\n  }\n\n  onResponse(data) {\n    const endData = data.endData;\n\n    if (endData !== undefined && !this.endData) {\n      this.endData = endData;\n    }\n\n    const inProgressId = data.target === _targetIdUp ? _targetIdUp : data.owner;\n\n    if (this._inProgress[inProgressId]) {\n      this._inProgress[inProgressId] = false;\n      this._sentCount--;\n\n      if (this.endData || this._sentCount === 0 && !this._isSelfResponding) {\n        this.end();\n      }\n    }\n  }\n\n}\n\nclass BootstrapTransaction extends CrossOriginTransaction {\n  constructor() {\n    super(...arguments);\n    this.type = CrossOriginTransactionTypes.Bootstrap;\n  }\n\n  static shouldForward() {\n    return false;\n  }\n\n  static async makeResponse(tabster) {\n    return {\n      isNavigatingWithKeyboard: tabster.keyboardNavigation.isNavigatingWithKeyboard()\n    };\n  }\n\n}\n\nclass FocusElementTransaction extends CrossOriginTransaction {\n  constructor() {\n    super(...arguments);\n    this.type = CrossOriginTransactionTypes.FocusElement;\n  }\n\n  static shouldSelfRespond() {\n    return true;\n  }\n\n  static shouldForward(tabster, data, getOwner) {\n    const el = GetElementTransaction.findElement(tabster, getOwner, data.beginData);\n    return !el || !tabster.focusable.isFocusable(el);\n  }\n\n  static async makeResponse(tabster, data, getOwner, ownerId, transactions, forwardResult) {\n    const el = GetElementTransaction.findElement(tabster, getOwner, data.beginData);\n    return !!el && tabster.focusedElement.focus(el, true) || !!(await forwardResult);\n  }\n\n}\n\nconst CrossOriginStates = {\n  Focused: 1,\n  Blurred: 2,\n  Observed: 3,\n  DeadWindow: 4,\n  KeyboardNavigation: 5,\n  Outline: 6\n};\n\nclass StateTransaction extends CrossOriginTransaction {\n  constructor() {\n    super(...arguments);\n    this.type = CrossOriginTransactionTypes.State;\n  }\n\n  static shouldSelfRespond(tabster, data) {\n    return data.state !== CrossOriginStates.DeadWindow && data.state !== CrossOriginStates.KeyboardNavigation;\n  }\n\n  static async makeResponse(tabster, data, getOwner, ownerId, transactions, forwardResult, isSelfResponse) {\n    const timestamp = data.timestamp;\n    const beginData = data.beginData;\n\n    if (timestamp && beginData) {\n      switch (beginData.state) {\n        case CrossOriginStates.Focused:\n          return StateTransaction._makeFocusedResponse(tabster, timestamp, beginData, transactions, isSelfResponse);\n\n        case CrossOriginStates.Blurred:\n          return StateTransaction._makeBlurredResponse(tabster, timestamp, beginData, transactions.ctx);\n\n        case CrossOriginStates.Observed:\n          return StateTransaction._makeObservedResponse(tabster, beginData);\n\n        case CrossOriginStates.DeadWindow:\n          return StateTransaction._makeDeadWindowResponse(tabster, beginData, transactions, forwardResult);\n\n        case CrossOriginStates.KeyboardNavigation:\n          return StateTransaction._makeKeyboardNavigationResponse(tabster, transactions.ctx, beginData.isNavigatingWithKeyboard);\n\n        case CrossOriginStates.Outline:\n          return StateTransaction._makeOutlineResponse(tabster, transactions.ctx, beginData.outline);\n      }\n    }\n\n    return true;\n  }\n\n  static createElement(tabster, beginData) {\n    return beginData.uid ? new CrossOriginElement(tabster, beginData.uid, beginData.ownerUId, beginData.id, beginData.rootUId, beginData.observedName, beginData.observedDetails) : null;\n  }\n\n  static async _makeFocusedResponse(tabster, timestamp, beginData, transactions, isSelfResponse) {\n    const element = StateTransaction.createElement(tabster, beginData);\n\n    if (beginData && beginData.ownerUId && element) {\n      transactions.ctx.focusOwner = beginData.ownerUId;\n      transactions.ctx.focusOwnerTimestamp = timestamp;\n\n      if (!isSelfResponse && beginData.rootUId && beginData.deloserUId) {\n        const deloserAPI = tabster.deloser;\n\n        if (deloserAPI) {\n          const history = DeloserAPI.getHistory(deloserAPI);\n          const deloser = {\n            ownerUId: beginData.ownerUId,\n            deloserUId: beginData.deloserUId,\n            rootUId: beginData.rootUId\n          };\n          const historyItem = history.make(beginData.rootUId, () => new CrossOriginDeloserHistoryByRoot(tabster, deloser.rootUId, transactions));\n          historyItem.unshift(deloser);\n        }\n      }\n\n      CrossOriginFocusedElementState.setVal( // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      tabster.crossOrigin.focusedElement, element, {\n        isFocusedProgrammatically: beginData.isFocusedProgrammatically\n      });\n    }\n\n    return true;\n  }\n\n  static async _makeBlurredResponse(tabster, timestamp, beginData, context) {\n    if (beginData && (beginData.ownerUId === context.focusOwner || beginData.force) && (!context.focusOwnerTimestamp || context.focusOwnerTimestamp < timestamp)) {\n      CrossOriginFocusedElementState.setVal( // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      tabster.crossOrigin.focusedElement, undefined, {});\n    }\n\n    return true;\n  }\n\n  static async _makeObservedResponse(tabster, beginData) {\n    const name = beginData.observedName;\n    const element = StateTransaction.createElement(tabster, beginData);\n\n    if (name && element) {\n      CrossOriginObservedElementState.trigger( // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      tabster.crossOrigin.observedElement, element, {\n        names: [name],\n        details: beginData.observedDetails\n      });\n    }\n\n    return true;\n  }\n\n  static async _makeDeadWindowResponse(tabster, beginData, transactions, forwardResult) {\n    const deadUId = beginData && beginData.ownerUId;\n\n    if (deadUId) {\n      transactions.removeTarget(deadUId);\n    }\n\n    return forwardResult.then(() => {\n      if (deadUId === transactions.ctx.focusOwner) {\n        const deloserAPI = tabster.deloser;\n\n        if (deloserAPI) {\n          DeloserAPI.forceRestoreFocus(deloserAPI);\n        }\n      }\n\n      return true;\n    });\n  }\n\n  static async _makeKeyboardNavigationResponse(tabster, context, isNavigatingWithKeyboard) {\n    if (isNavigatingWithKeyboard !== undefined && tabster.keyboardNavigation.isNavigatingWithKeyboard() !== isNavigatingWithKeyboard) {\n      context.ignoreKeyboardNavigationStateUpdate = true;\n      tabster.keyboardNavigation.setNavigatingWithKeyboard(isNavigatingWithKeyboard);\n      context.ignoreKeyboardNavigationStateUpdate = false;\n    }\n\n    return true;\n  }\n\n  static async _makeOutlineResponse(tabster, context, props) {\n    if (context.origOutlineSetup) {\n      context.origOutlineSetup.call( // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      tabster.outline, props);\n    }\n\n    return true;\n  }\n\n}\n\nclass GetElementTransaction extends CrossOriginTransaction {\n  constructor() {\n    super(...arguments);\n    this.type = CrossOriginTransactionTypes.GetElement;\n  }\n\n  static shouldSelfRespond() {\n    return true;\n  }\n\n  static findElement(tabster, getOwner, data) {\n    let element;\n\n    if (data && (!data.ownerId || data.ownerId === getWindowUId(getOwner()))) {\n      if (data.id) {\n        element = getOwner().document.getElementById(data.id);\n\n        if (element && data.rootId) {\n          const ctx = RootAPI.getTabsterContext(tabster, element);\n\n          if (!ctx || ctx.root.uid !== data.rootId) {\n            return null;\n          }\n        }\n      } else if (data.uid) {\n        const ref = getInstanceContext(getOwner).elementByUId[data.uid];\n        element = ref && ref.get();\n      } else if (data.observedName) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        element = tabster.observedElement.getElement(data.observedName, data.accessibility);\n      }\n    }\n\n    return element || null;\n  }\n\n  static getElementData(tabster, element, getOwner, context, ownerUId) {\n    const deloser = DeloserAPI.getDeloser(tabster, element);\n    const ctx = RootAPI.getTabsterContext(tabster, element);\n    const tabsterOnElement = getTabsterOnElement(tabster, element);\n    const observed = tabsterOnElement && tabsterOnElement.observed;\n    return {\n      uid: getElementUId(getOwner, element),\n      ownerUId,\n      id: element.id || undefined,\n      rootUId: ctx ? ctx.root.uid : undefined,\n      deloserUId: deloser ? getDeloserUID(getOwner, context, deloser) : undefined,\n      observedName: observed && observed.names && observed.names[0],\n      observedDetails: observed && observed.details\n    };\n  }\n\n  static async makeResponse(tabster, data, getOwner, ownerUId, transactions, forwardResult) {\n    const beginData = data.beginData;\n    let element;\n    let dataOut;\n\n    if (beginData === undefined) {\n      element = tabster.focusedElement.getFocusedElement();\n    } else if (beginData) {\n      element = GetElementTransaction.findElement(tabster, getOwner, beginData) || undefined;\n    }\n\n    if (!element && beginData) {\n      const name = beginData.observedName;\n      const timeout = data.timeout;\n      const accessibility = beginData.accessibility;\n\n      if (name && timeout) {\n        const e = await new (getPromise(getOwner))(resolve => {\n          let isWaitElementResolved = false;\n          let isForwardResolved = false;\n          let isResolved = false; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n          tabster.observedElement.waitElement(name, timeout, accessibility).result.then(value => {\n            isWaitElementResolved = true;\n\n            if (!isResolved && (value || isForwardResolved)) {\n              isResolved = true;\n              resolve({\n                element: value\n              });\n            }\n          });\n          forwardResult.then(value => {\n            isForwardResolved = true;\n\n            if (!isResolved && (value || isWaitElementResolved)) {\n              isResolved = true;\n              resolve({\n                crossOrigin: value\n              });\n            }\n          });\n        });\n\n        if (e.element) {\n          element = e.element;\n        } else if (e.crossOrigin) {\n          dataOut = e.crossOrigin;\n        }\n      }\n    }\n\n    return element ? GetElementTransaction.getElementData(tabster, element, getOwner, transactions.ctx, ownerUId) : dataOut;\n  }\n\n}\n\nclass RestoreFocusInDeloserTransaction extends CrossOriginTransaction {\n  constructor() {\n    super(...arguments);\n    this.type = CrossOriginTransactionTypes.RestoreFocusInDeloser;\n  }\n\n  static async makeResponse(tabster, data, getOwner, ownerId, transactions, forwardResult) {\n    const forwardRet = await forwardResult;\n    const begin = !forwardRet && data.beginData;\n    const uid = begin && begin.deloserUId;\n    const deloser = uid && transactions.ctx.deloserByUId[uid];\n    const deloserAPI = tabster.deloser;\n\n    if (begin && deloser && deloserAPI) {\n      const history = DeloserAPI.getHistory(deloserAPI);\n      return begin.reset ? history.resetFocus(deloser) : history.focusAvailable(deloser);\n    }\n\n    return !!forwardRet;\n  }\n\n}\n\nclass PingTransaction extends CrossOriginTransaction {\n  constructor() {\n    super(...arguments);\n    this.type = CrossOriginTransactionTypes.Ping;\n  }\n\n  static shouldForward() {\n    return false;\n  }\n\n  static async makeResponse() {\n    return true;\n  }\n\n}\n\nclass CrossOriginTransactions {\n  constructor(tabster, getOwner, context) {\n    this._knownTargets = {};\n    this._transactions = {};\n    this._isDefaultSendUp = false;\n    this.isSetUp = false;\n\n    this._onMessage = e => {\n      if (e.data.owner === this._ownerUId || !this._tabster) {\n        return;\n      } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n      const data = e.data;\n      let transactionId;\n\n      if (!data || !(transactionId = data.transaction) || !data.type || !data.timestamp || !data.owner || !data.sentto) {\n        return;\n      }\n\n      let knownTarget = this._knownTargets[data.owner];\n\n      if (!knownTarget && e.send && data.owner !== this._ownerUId) {\n        knownTarget = this._knownTargets[data.owner] = {\n          send: e.send\n        };\n      }\n\n      if (knownTarget) {\n        knownTarget.last = Date.now();\n      }\n\n      if (data.isResponse) {\n        const t = this._transactions[transactionId];\n\n        if (t && t.transaction && t.transaction.type === data.type) {\n          t.transaction.onResponse(data);\n        }\n      } else {\n        const Transaction = this._getTransactionClass(data.type);\n\n        const forwardResult = this.forwardTransaction(data);\n\n        if (Transaction && e.send) {\n          Transaction.makeResponse(this._tabster, data, this._owner, this._ownerUId, this, forwardResult, false).then(r => {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const response = {\n              transaction: data.transaction,\n              type: data.type,\n              isResponse: true,\n              timestamp: Date.now(),\n              owner: this._ownerUId,\n              timeout: data.timeout,\n              sentto: {},\n              target: data.target === _targetIdUp ? _targetIdUp : data.owner,\n              endData: r\n            };\n            e.send(response);\n          });\n        }\n      }\n    };\n\n    this._onPageHide = () => {\n      this._dead();\n    };\n\n    this._onBrowserMessage = e => {\n      if (e.source === this._owner()) {\n        return;\n      } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n      const send = data => {\n        if (e.source && e.source.postMessage) {\n          // eslint-disable-next-line @typescript-eslint/ban-types\n          e.source.postMessage(JSON.stringify(data), \"*\");\n        }\n      };\n\n      try {\n        this._onMessage({\n          data: JSON.parse(e.data),\n          send\n        });\n      } catch (e) {\n        /* Ignore */\n      }\n    };\n\n    this._tabster = tabster;\n    this._owner = getOwner;\n    this._ownerUId = getWindowUId(getOwner());\n    this.ctx = context;\n  }\n\n  setup(sendUp) {\n    if (this.isSetUp) {\n      if (process.env.NODE_ENV === 'development') {\n        console.error(\"CrossOrigin is already set up.\");\n      }\n    } else {\n      this.isSetUp = true;\n      this.setSendUp(sendUp);\n\n      this._owner().addEventListener(\"pagehide\", this._onPageHide);\n\n      this._ping();\n    }\n\n    return this._onMessage;\n  }\n\n  setSendUp(sendUp) {\n    if (!this.isSetUp) {\n      throw new Error(\"CrossOrigin is not set up.\");\n    }\n\n    this.sendUp = sendUp || undefined;\n\n    const owner = this._owner();\n\n    if (sendUp === undefined) {\n      if (!this._isDefaultSendUp) {\n        if (owner.document) {\n          this._isDefaultSendUp = true;\n\n          if (owner.parent && owner.parent !== owner && owner.parent.postMessage) {\n            this.sendUp = ( // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            data) => {\n              owner.parent.postMessage(JSON.stringify(data), \"*\");\n            };\n          }\n\n          owner.addEventListener(\"message\", this._onBrowserMessage);\n        }\n      }\n    } else if (this._isDefaultSendUp) {\n      owner.removeEventListener(\"message\", this._onBrowserMessage);\n      this._isDefaultSendUp = false;\n    }\n\n    return this._onMessage;\n  }\n\n  async dispose() {\n    const owner = this._owner();\n\n    if (this._pingTimer) {\n      owner.clearTimeout(this._pingTimer);\n      this._pingTimer = undefined;\n    }\n\n    owner.removeEventListener(\"message\", this._onBrowserMessage);\n    owner.removeEventListener(\"pagehide\", this._onPageHide);\n    await this._dead();\n    delete this._deadPromise;\n\n    for (const id of Object.keys(this._transactions)) {\n      const t = this._transactions[id];\n\n      if (t.timer) {\n        owner.clearTimeout(t.timer);\n        delete t.timer;\n      }\n\n      t.transaction.end();\n    }\n\n    this._knownTargets = {};\n    delete this.sendUp;\n  }\n\n  beginTransaction(Transaction, value, timeout, sentTo, targetId, withReject) {\n    if (!this._owner) {\n      return getPromise(this._owner).reject();\n    }\n\n    const transaction = new Transaction(this._tabster, this._owner, this._knownTargets, value, timeout, sentTo, targetId, this.sendUp);\n    let selfResponse;\n\n    if (Transaction.shouldSelfRespond && Transaction.shouldSelfRespond(this._tabster, value, this._owner, this._ownerUId)) {\n      selfResponse = data => {\n        return Transaction.makeResponse(this._tabster, data, this._owner, this._ownerUId, this, getPromise(this._owner).resolve(undefined), true);\n      };\n    }\n\n    return this._beginTransaction(transaction, timeout, selfResponse, withReject);\n  }\n\n  removeTarget(uid) {\n    delete this._knownTargets[uid];\n  }\n\n  _beginTransaction(transaction, timeout, selfResponse, withReject) {\n    const owner = this._owner();\n\n    const wrapper = {\n      transaction,\n      timer: owner.setTimeout(() => {\n        delete wrapper.timer;\n        transaction.end(\"Cross origin transaction timed out.\");\n      }, _transactionTimeout + (timeout || 0))\n    };\n    this._transactions[transaction.id] = wrapper;\n    const ret = transaction.begin(selfResponse);\n    ret.catch(() => {\n      /**/\n    }).finally(() => {\n      if (wrapper.timer) {\n        owner.clearTimeout(wrapper.timer);\n      }\n\n      delete this._transactions[transaction.id];\n    });\n    return ret.then(value => value, withReject ? undefined : () => undefined);\n  }\n\n  forwardTransaction( // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  data // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ) {\n    const owner = this._owner;\n    let targetId = data.target;\n\n    if (targetId === this._ownerUId) {\n      return getPromise(owner).resolve();\n    }\n\n    const Transaction = this._getTransactionClass(data.type);\n\n    if (Transaction) {\n      if (Transaction.shouldForward === undefined || Transaction.shouldForward(this._tabster, data, owner, this._ownerUId)) {\n        const sentTo = data.sentto;\n\n        if (targetId === _targetIdUp) {\n          targetId = undefined;\n          sentTo[this._ownerUId] = true;\n        }\n\n        delete sentTo[_targetIdUp];\n        return this._beginTransaction(new Transaction(this._tabster, owner, this._knownTargets, data.beginData, data.timeout, sentTo, targetId, this.sendUp), data.timeout);\n      } else {\n        return getPromise(owner).resolve();\n      }\n    }\n\n    return getPromise(owner).reject(`Unknown transaction type ${data.type}`);\n  }\n\n  _getTransactionClass(type // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ) {\n    switch (type) {\n      case CrossOriginTransactionTypes.Bootstrap:\n        return BootstrapTransaction;\n\n      case CrossOriginTransactionTypes.FocusElement:\n        return FocusElementTransaction;\n\n      case CrossOriginTransactionTypes.State:\n        return StateTransaction;\n\n      case CrossOriginTransactionTypes.GetElement:\n        return GetElementTransaction;\n\n      case CrossOriginTransactionTypes.RestoreFocusInDeloser:\n        return RestoreFocusInDeloserTransaction;\n\n      case CrossOriginTransactionTypes.Ping:\n        return PingTransaction;\n\n      default:\n        return null;\n    }\n  }\n\n  async _dead() {\n    if (!this._deadPromise && this.ctx.focusOwner === this._ownerUId) {\n      this._deadPromise = this.beginTransaction(StateTransaction, {\n        ownerUId: this._ownerUId,\n        state: CrossOriginStates.DeadWindow\n      });\n    }\n\n    if (this._deadPromise) {\n      await this._deadPromise;\n    }\n  }\n\n  async _ping() {\n    if (this._pingTimer) {\n      return;\n    }\n\n    let deadWindows;\n    const now = Date.now();\n    const targets = Object.keys(this._knownTargets).filter(uid => now - (this._knownTargets[uid].last || 0) > _pingTimeout);\n\n    if (this.sendUp) {\n      targets.push(_targetIdUp);\n    }\n\n    if (targets.length) {\n      await getPromise(this._owner).all(targets.map(uid => this.beginTransaction(PingTransaction, undefined, undefined, undefined, uid, true).then(() => true, () => {\n        if (uid !== _targetIdUp) {\n          if (!deadWindows) {\n            deadWindows = {};\n          }\n\n          deadWindows[uid] = true;\n          delete this._knownTargets[uid];\n        }\n\n        return false;\n      })));\n    }\n\n    if (deadWindows) {\n      const focused = await this.beginTransaction(GetElementTransaction, undefined);\n\n      if (!focused && this.ctx.focusOwner && this.ctx.focusOwner in deadWindows) {\n        await this.beginTransaction(StateTransaction, {\n          ownerUId: this._ownerUId,\n          state: CrossOriginStates.Blurred,\n          force: true\n        });\n        const deloserAPI = this._tabster.deloser;\n\n        if (deloserAPI) {\n          DeloserAPI.forceRestoreFocus(deloserAPI);\n        }\n      }\n    }\n\n    this._pingTimer = this._owner().setTimeout(() => {\n      this._pingTimer = undefined;\n\n      this._ping();\n    }, _pingTimeout);\n  }\n\n}\n\nclass CrossOriginElement {\n  constructor(tabster, uid, ownerId, id, rootId, observedName, observedDetails) {\n    this._tabster = tabster;\n    this.uid = uid;\n    this.ownerId = ownerId;\n    this.id = id;\n    this.rootId = rootId;\n    this.observedName = observedName;\n    this.observedDetails = observedDetails;\n  }\n\n  focus(noFocusedProgrammaticallyFlag, noAccessibleCheck) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this._tabster.crossOrigin.focusedElement.focus(this, noFocusedProgrammaticallyFlag, noAccessibleCheck);\n  }\n\n}\nclass CrossOriginFocusedElementState extends Subscribable {\n  constructor(transactions) {\n    super();\n    this._transactions = transactions;\n  }\n\n  async focus(element, noFocusedProgrammaticallyFlag, noAccessibleCheck) {\n    return this._focus({\n      uid: element.uid,\n      id: element.id,\n      rootId: element.rootId,\n      ownerId: element.ownerId,\n      observedName: element.observedName\n    }, noFocusedProgrammaticallyFlag, noAccessibleCheck);\n  }\n\n  async focusById(elementId, rootId, noFocusedProgrammaticallyFlag, noAccessibleCheck) {\n    return this._focus({\n      id: elementId,\n      rootId\n    }, noFocusedProgrammaticallyFlag, noAccessibleCheck);\n  }\n\n  async focusByObservedName(observedName, timeout, rootId, noFocusedProgrammaticallyFlag, noAccessibleCheck) {\n    return this._focus({\n      observedName,\n      rootId\n    }, noFocusedProgrammaticallyFlag, noAccessibleCheck, timeout);\n  }\n\n  async _focus(elementData, noFocusedProgrammaticallyFlag, noAccessibleCheck, timeout) {\n    return this._transactions.beginTransaction(FocusElementTransaction, { ...elementData,\n      noFocusedProgrammaticallyFlag,\n      noAccessibleCheck\n    }, timeout).then(value => !!value);\n  }\n\n  static setVal(instance, val, details) {\n    instance.setVal(val, details);\n  }\n\n}\nclass CrossOriginObservedElementState extends Subscribable {\n  constructor(tabster, transactions) {\n    super();\n    this._lastRequestFocusId = 0;\n    this._tabster = tabster;\n    this._transactions = transactions;\n  }\n\n  async getElement(observedName, accessibility) {\n    return this.waitElement(observedName, 0, accessibility);\n  }\n\n  async waitElement(observedName, timeout, accessibility) {\n    return this._transactions.beginTransaction(GetElementTransaction, {\n      observedName,\n      accessibility\n    }, timeout).then(value => value ? StateTransaction.createElement(this._tabster, value) : null);\n  }\n\n  async requestFocus(observedName, timeout) {\n    const requestId = ++this._lastRequestFocusId;\n    return this.waitElement(observedName, timeout, ObservedElementAccesibilities.Focusable).then(element => this._lastRequestFocusId === requestId && element ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this._tabster.crossOrigin.focusedElement.focus(element, true) : false);\n  }\n\n  static trigger(instance, element, details) {\n    instance.trigger(element, details);\n  }\n\n}\nclass CrossOriginAPI {\n  constructor(tabster) {\n    this._init = () => {\n      const tabster = this._tabster;\n      tabster.keyboardNavigation.subscribe(this._onKeyboardNavigationStateChanged);\n      tabster.focusedElement.subscribe(this._onFocus); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n      tabster.observedElement.subscribe(this._onObserved);\n\n      if (!this._ctx.origOutlineSetup) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this._ctx.origOutlineSetup = tabster.outline.setup; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n        tabster.outline.setup = this._outlineSetup;\n      }\n\n      this._transactions.beginTransaction(BootstrapTransaction, undefined, undefined, undefined, _targetIdUp).then(data => {\n        if (data && this._tabster.keyboardNavigation.isNavigatingWithKeyboard() !== data.isNavigatingWithKeyboard) {\n          this._ctx.ignoreKeyboardNavigationStateUpdate = true;\n\n          this._tabster.keyboardNavigation.setNavigatingWithKeyboard(data.isNavigatingWithKeyboard);\n\n          this._ctx.ignoreKeyboardNavigationStateUpdate = false;\n        }\n      });\n    };\n\n    this._onKeyboardNavigationStateChanged = value => {\n      if (!this._ctx.ignoreKeyboardNavigationStateUpdate) {\n        this._transactions.beginTransaction(StateTransaction, {\n          state: CrossOriginStates.KeyboardNavigation,\n          ownerUId: getWindowUId(this._win()),\n          isNavigatingWithKeyboard: value\n        });\n      }\n    };\n\n    this._onFocus = element => {\n      const win = this._win();\n\n      const ownerUId = getWindowUId(win);\n\n      if (this._blurTimer) {\n        win.clearTimeout(this._blurTimer);\n        this._blurTimer = undefined;\n      }\n\n      if (element) {\n        this._transactions.beginTransaction(StateTransaction, { ...GetElementTransaction.getElementData(this._tabster, element, this._win, this._ctx, ownerUId),\n          state: CrossOriginStates.Focused\n        });\n      } else {\n        this._blurTimer = win.setTimeout(() => {\n          this._blurTimer = undefined;\n\n          if (this._ctx.focusOwner && this._ctx.focusOwner === ownerUId) {\n            this._transactions.beginTransaction(GetElementTransaction, undefined).then(value => {\n              if (!value && this._ctx.focusOwner === ownerUId) {\n                this._transactions.beginTransaction(StateTransaction, {\n                  ownerUId,\n                  state: CrossOriginStates.Blurred,\n                  force: false\n                });\n              }\n            });\n          }\n        }, 0);\n      }\n    };\n\n    this._onObserved = (element, details) => {\n      var _a;\n\n      const d = GetElementTransaction.getElementData(this._tabster, element, this._win, this._ctx, getWindowUId(this._win()));\n      d.state = CrossOriginStates.Observed;\n      d.observedName = (_a = details.names) === null || _a === void 0 ? void 0 : _a[0];\n      d.observedDetails = details.details;\n\n      this._transactions.beginTransaction(StateTransaction, d);\n    };\n\n    this._outlineSetup = props => {\n      this._transactions.beginTransaction(StateTransaction, {\n        state: CrossOriginStates.Outline,\n        ownerUId: getWindowUId(this._win()),\n        outline: props\n      });\n    };\n\n    this._tabster = tabster;\n    this._win = tabster.getWindow;\n    this._ctx = {\n      ignoreKeyboardNavigationStateUpdate: false,\n      deloserByUId: {}\n    };\n    this._transactions = new CrossOriginTransactions(tabster, this._win, this._ctx);\n    this.focusedElement = new CrossOriginFocusedElementState(this._transactions);\n    this.observedElement = new CrossOriginObservedElementState(tabster, this._transactions);\n  }\n\n  setup(sendUp) {\n    if (this.isSetUp()) {\n      return this._transactions.setSendUp(sendUp);\n    } else {\n      this._tabster.queueInit(this._init);\n\n      return this._transactions.setup(sendUp);\n    }\n  }\n\n  isSetUp() {\n    return this._transactions.isSetUp;\n  }\n\n  dispose() {\n    var _a;\n\n    const tabster = this._tabster;\n    tabster.keyboardNavigation.unsubscribe(this._onKeyboardNavigationStateChanged);\n    tabster.focusedElement.unsubscribe(this._onFocus);\n    (_a = tabster.observedElement) === null || _a === void 0 ? void 0 : _a.unsubscribe(this._onObserved);\n\n    this._transactions.dispose();\n\n    this.focusedElement.dispose();\n    this.observedElement.dispose();\n    this._ctx.deloserByUId = {};\n  }\n\n}\n\nfunction getDeloserUID(getWindow, context, deloser) {\n  const deloserElement = deloser.getElement();\n\n  if (deloserElement) {\n    const uid = getElementUId(getWindow, deloserElement);\n\n    if (!context.deloserByUId[uid]) {\n      context.deloserByUId[uid] = deloser;\n    }\n\n    return uid;\n  }\n\n  return undefined;\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nconst _focusableSelector = /*#__PURE__*/[\"a[href]\", \"button:not([disabled])\", \"input:not([disabled])\", \"select:not([disabled])\", \"textarea:not([disabled])\", \"*[tabindex]\", \"*[contenteditable]\"].join(\", \");\n\nclass FocusableAPI {\n  constructor(tabster) {\n    this._tabster = tabster;\n  }\n\n  dispose() {\n    /**/\n  }\n\n  getProps(element) {\n    const tabsterOnElement = getTabsterOnElement(this._tabster, element);\n    return tabsterOnElement && tabsterOnElement.focusable || {};\n  }\n\n  isFocusable(el, includeProgrammaticallyFocusable, noVisibleCheck, noAccessibleCheck) {\n    if (matchesSelector(el, _focusableSelector) && (includeProgrammaticallyFocusable || el.tabIndex !== -1)) {\n      return (noVisibleCheck || this.isVisible(el)) && (noAccessibleCheck || this.isAccessible(el));\n    }\n\n    return false;\n  }\n\n  isVisible(el) {\n    if (!el.ownerDocument || el.nodeType !== Node.ELEMENT_NODE) {\n      return false;\n    }\n\n    if (el.offsetParent === null && el.ownerDocument.body !== el) {\n      return false;\n    }\n\n    const win = el.ownerDocument.defaultView;\n\n    if (!win) {\n      return false;\n    }\n\n    const rect = el.ownerDocument.body.getBoundingClientRect();\n\n    if (rect.width === 0 && rect.height === 0) {\n      // This might happen, for example, if our <body> is in hidden <iframe>.\n      return false;\n    }\n\n    const computedStyle = win.getComputedStyle(el);\n\n    if (computedStyle.visibility === \"hidden\") {\n      return false;\n    }\n\n    return true;\n  }\n\n  isAccessible(el) {\n    var _a;\n\n    for (let e = el; e; e = e.parentElement) {\n      const tabsterOnElement = getTabsterOnElement(this._tabster, e);\n\n      if (this._isHidden(e)) {\n        return false;\n      }\n\n      const ignoreDisabled = (_a = tabsterOnElement === null || tabsterOnElement === void 0 ? void 0 : tabsterOnElement.focusable) === null || _a === void 0 ? void 0 : _a.ignoreAriaDisabled;\n\n      if (!ignoreDisabled && this._isDisabled(e)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  _isDisabled(el) {\n    return el.hasAttribute(\"disabled\");\n  }\n\n  _isHidden(el) {\n    var _a;\n\n    const attrVal = el.getAttribute(\"aria-hidden\");\n\n    if (attrVal && attrVal.toLowerCase() === \"true\") {\n      if (!((_a = this._tabster.modalizer) === null || _a === void 0 ? void 0 : _a.isAugmented(el))) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  findFirst(options) {\n    return this.findElement({ ...options\n    });\n  }\n\n  findLast(options) {\n    return this.findElement({\n      isBackward: true,\n      ...options\n    });\n  }\n\n  findNext(options) {\n    return this.findElement({ ...options\n    });\n  }\n\n  findPrev(options) {\n    return this.findElement({\n      isBackward: true,\n      ...options\n    });\n  }\n\n  findDefault(options) {\n    return this.findElement({ ...options,\n      acceptCondition: el => this._tabster.focusable.isFocusable(el, options.includeProgrammaticallyFocusable) && !!this.getProps(el).isDefault\n    }) || null;\n  }\n\n  findAll(options) {\n    return this._findElements(true, options) || [];\n  }\n\n  findElement(options) {\n    const found = this._findElements(false, options);\n\n    return found ? found[0] : found;\n  }\n\n  _findElements(findAll, options) {\n    var _a, _b, _c;\n\n    const {\n      container,\n      currentElement = null,\n      includeProgrammaticallyFocusable,\n      useActiveModalizer,\n      ignoreUncontrolled,\n      ignoreAccessibility,\n      modalizerId,\n      isBackward,\n      onUncontrolled,\n      onElement\n    } = options;\n    const elements = [];\n    let {\n      acceptCondition\n    } = options;\n\n    if (!container) {\n      return null;\n    }\n\n    if (!acceptCondition) {\n      acceptCondition = el => this._tabster.focusable.isFocusable(el, includeProgrammaticallyFocusable, false, ignoreAccessibility);\n    }\n\n    const acceptElementState = {\n      container,\n      modalizerUserId: modalizerId === undefined && useActiveModalizer ? (_a = this._tabster.modalizer) === null || _a === void 0 ? void 0 : _a.activeId : modalizerId || ((_c = (_b = RootAPI.getTabsterContext(this._tabster, container)) === null || _b === void 0 ? void 0 : _b.modalizer) === null || _c === void 0 ? void 0 : _c.userId),\n      from: currentElement || container,\n      isBackward,\n      acceptCondition,\n      includeProgrammaticallyFocusable,\n      ignoreUncontrolled,\n      ignoreAccessibility,\n      cachedGrouppers: {}\n    };\n    const walker = createElementTreeWalker(container.ownerDocument, container, node => this._acceptElement(node, acceptElementState));\n\n    if (!walker) {\n      return null;\n    }\n\n    const prepareForNextElement = shouldContinueIfNotFound => {\n      const foundElement = acceptElementState.foundElement;\n\n      if (foundElement) {\n        elements.push(foundElement);\n      }\n\n      if (findAll) {\n        if (foundElement) {\n          acceptElementState.found = false;\n          delete acceptElementState.foundElement;\n          delete acceptElementState.fromCtx;\n          acceptElementState.from = foundElement;\n\n          if (onElement && !onElement(foundElement)) {\n            return false;\n          }\n        }\n\n        return !!(foundElement || shouldContinueIfNotFound);\n      } else {\n        return !!(shouldContinueIfNotFound && !foundElement);\n      }\n    };\n\n    if (currentElement) {\n      walker.currentNode = currentElement;\n    } else if (isBackward) {\n      const lastChild = getLastChild(container);\n\n      if (!lastChild) {\n        return null;\n      }\n\n      if (this._acceptElement(lastChild, acceptElementState) === NodeFilter.FILTER_ACCEPT && !prepareForNextElement(true)) {\n        return elements;\n      }\n\n      walker.currentNode = lastChild;\n    }\n\n    let foundElement;\n\n    do {\n      foundElement = (isBackward ? walker.previousNode() : walker.nextNode()) || undefined;\n    } while (prepareForNextElement());\n\n    if (!findAll) {\n      const nextUncontrolled = acceptElementState.nextUncontrolled;\n\n      if (nextUncontrolled) {\n        if (onUncontrolled) {\n          onUncontrolled(nextUncontrolled);\n        }\n\n        if (foundElement) {\n          // We have an uncontrolled area and there is a controlled element after it.\n          // Return undefined for the default Tab action.\n          return undefined;\n        } else {\n          // Otherwise, return null to moveOutWithDefaultAction().\n          return null;\n        }\n      }\n    }\n\n    return elements.length ? elements : null;\n  }\n\n  _acceptElement(element, state) {\n    var _a, _b, _c, _d, _e;\n\n    if (state.found) {\n      return NodeFilter.FILTER_ACCEPT;\n    }\n\n    const container = state.container;\n\n    if (element === container) {\n      return NodeFilter.FILTER_SKIP;\n    }\n\n    if (!container.contains(element)) {\n      return NodeFilter.FILTER_REJECT;\n    }\n\n    if (element.__tabsterDummyContainer) {\n      return NodeFilter.FILTER_REJECT;\n    }\n\n    let lastToIgnore = state.lastToIgnore;\n\n    if (lastToIgnore) {\n      if (lastToIgnore.contains(element)) {\n        return NodeFilter.FILTER_REJECT;\n      } else {\n        lastToIgnore = state.lastToIgnore = undefined;\n      }\n    }\n\n    const ctx = state.currentCtx = RootAPI.getTabsterContext(this._tabster, element); // Tabster is opt in, if it is not managed, don't try and get do anything special\n\n    if (!ctx) {\n      return NodeFilter.FILTER_SKIP;\n    }\n\n    if (state.ignoreUncontrolled) {\n      if (shouldIgnoreFocus(element)) {\n        return NodeFilter.FILTER_SKIP;\n      }\n    } else if (ctx.uncontrolled && !state.nextUncontrolled && this._tabster.focusable.isFocusable(element, undefined, true, true)) {\n      if (!ctx.groupper && !ctx.mover) {\n        if (((_a = ctx.modalizer) === null || _a === void 0 ? void 0 : _a.userId) === ((_b = this._tabster.modalizer) === null || _b === void 0 ? void 0 : _b.activeId)) {\n          if (this.isVisible(ctx.uncontrolled)) {\n            state.nextUncontrolled = ctx.uncontrolled;\n          }\n\n          return NodeFilter.FILTER_REJECT;\n        }\n      }\n    } // We assume iframes are focusable because native tab behaviour would tab inside\n\n\n    if (element.tagName === \"IFRAME\" || element.tagName === \"WEBVIEW\") {\n      if (((_c = ctx.modalizer) === null || _c === void 0 ? void 0 : _c.userId) === ((_d = this._tabster.modalizer) === null || _d === void 0 ? void 0 : _d.activeId)) {\n        state.found = true;\n        state.lastToIgnore = state.foundElement = element;\n        return NodeFilter.FILTER_ACCEPT;\n      } else {\n        return NodeFilter.FILTER_REJECT;\n      }\n    }\n\n    if (!state.ignoreAccessibility && !this.isAccessible(element)) {\n      return NodeFilter.FILTER_REJECT;\n    }\n\n    let result;\n    let fromCtx = state.fromCtx;\n\n    if (!fromCtx) {\n      fromCtx = state.fromCtx = RootAPI.getTabsterContext(this._tabster, state.from);\n    }\n\n    const fromMover = fromCtx === null || fromCtx === void 0 ? void 0 : fromCtx.mover;\n    let groupper = ctx.groupper;\n    let mover = ctx.mover;\n    result = (_e = this._tabster.modalizer) === null || _e === void 0 ? void 0 : _e.acceptElement(element, state);\n\n    if (result === undefined && (groupper || mover || fromMover)) {\n      const groupperElement = groupper === null || groupper === void 0 ? void 0 : groupper.getElement();\n      const fromMoverElement = fromMover === null || fromMover === void 0 ? void 0 : fromMover.getElement();\n      let moverElement = mover === null || mover === void 0 ? void 0 : mover.getElement();\n\n      if (moverElement && fromMoverElement && container.contains(fromMoverElement) && (!groupperElement || !mover || fromMoverElement.contains(groupperElement))) {\n        mover = fromMover;\n        moverElement = fromMoverElement;\n      }\n\n      if (groupperElement && (groupperElement === container || !container.contains(groupperElement))) {\n        groupper = undefined;\n      }\n\n      if (moverElement && !container.contains(moverElement)) {\n        mover = undefined;\n      }\n\n      if (groupper && mover) {\n        if (moverElement && groupperElement && !groupperElement.contains(moverElement)) {\n          mover = undefined;\n        } else {\n          groupper = undefined;\n        }\n      }\n\n      if (groupper) {\n        result = groupper.acceptElement(element, state);\n      }\n\n      if (mover) {\n        result = mover.acceptElement(element, state);\n      }\n    }\n\n    if (result === undefined) {\n      result = state.acceptCondition(element) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n\n    if (result === NodeFilter.FILTER_ACCEPT && !state.found) {\n      state.found = true;\n      state.foundElement = element;\n    }\n\n    return result;\n  }\n\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst Keys = {\n  Tab: 9,\n  Enter: 13,\n  Esc: 27,\n  Space: 32,\n  PageUp: 33,\n  PageDown: 34,\n  End: 35,\n  Home: 36,\n  Left: 37,\n  Up: 38,\n  Right: 39,\n  Down: 40\n};\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nclass FocusedElementState extends Subscribable {\n  constructor(tabster, getWindow) {\n    super();\n\n    this._init = () => {\n      const win = this._win();\n\n      const doc = win.document; // Add these event listeners as capture - we want Tabster to run before user event handlers\n\n      doc.addEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);\n      doc.addEventListener(\"focusout\", this._onFocusOut, true);\n      win.addEventListener(\"keydown\", this._onKeyDown, true);\n      const activeElement = doc.activeElement;\n\n      if (activeElement && activeElement !== doc.body) {\n        this._setFocusedElement(activeElement);\n      }\n\n      this.subscribe(this._onChanged);\n    };\n\n    this._onFocusIn = e => {\n      this._setFocusedElement(e.target, e.details.relatedTarget, e.details.isFocusedProgrammatically);\n    };\n\n    this._onFocusOut = e => {\n      this._setFocusedElement(undefined, e.relatedTarget);\n    }; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n    this._validateFocusedElement = element => {// TODO: Make sure this is not needed anymore and write tests.\n    };\n\n    this._onKeyDown = e => {\n      var _a, _b, _c, _d, _e, _f;\n\n      if (e.keyCode !== Keys.Tab || e.ctrlKey) {\n        return;\n      }\n\n      const currentElement = this.getVal();\n\n      if (!currentElement || !currentElement.ownerDocument || currentElement.contentEditable === \"true\") {\n        return;\n      }\n\n      const tabster = this._tabster;\n      const controlTab = tabster.controlTab;\n      const ctx = RootAPI.getTabsterContext(tabster, currentElement);\n\n      if (!ctx || ctx.ignoreKeydown(e)) {\n        return;\n      }\n\n      const isBackward = e.shiftKey;\n      const next = FocusedElementState.findNextTabbable(tabster, ctx, undefined, currentElement, isBackward, undefined, true);\n      let nextElement;\n\n      if (next) {\n        let uncontrolled = next.uncontrolled;\n\n        if (uncontrolled) {\n          const isGroupperFirst = ctx.isGroupperFirst;\n          let moveOutside = false;\n\n          if (isGroupperFirst !== undefined) {\n            const groupper = (_a = ctx.groupper) === null || _a === void 0 ? void 0 : _a.getElement();\n            const mover = (_b = ctx.mover) === null || _b === void 0 ? void 0 : _b.getElement();\n            let moveFrom;\n\n            if (isGroupperFirst && groupper && uncontrolled.contains(groupper)) {\n              moveFrom = groupper;\n            } else if (!isGroupperFirst && mover && uncontrolled.contains(mover)) {\n              moveFrom = mover;\n            }\n\n            if (moveFrom) {\n              uncontrolled = moveFrom;\n              moveOutside = true;\n            }\n          }\n\n          if (uncontrolled && ctx.uncontrolled !== uncontrolled) {\n            // We have met an uncontrolled area, just allow default action.\n            DummyInputManager.moveWithPhantomDummy(this._tabster, uncontrolled, moveOutside, isBackward);\n          }\n\n          return;\n        }\n\n        nextElement = next.element;\n      }\n\n      if (nextElement) {\n        const preventDefault = () => {\n          e.preventDefault();\n          e.stopImmediatePropagation();\n        }; // For iframes just allow normal Tab behaviour\n\n\n        if (!controlTab) {\n          const lastMoverOrGroupper = next === null || next === void 0 ? void 0 : next.lastMoverOrGroupper;\n          let outOfDOMOrder = next === null || next === void 0 ? void 0 : next.outOfDOMOrder;\n\n          if (!outOfDOMOrder && currentElement.compareDocumentPosition(nextElement) & (isBackward ? document.DOCUMENT_POSITION_FOLLOWING : document.DOCUMENT_POSITION_PRECEDING)) {\n            outOfDOMOrder = true;\n          }\n\n          if (outOfDOMOrder) {\n            // The next element is out of DOM order (for example because of a trapped groupper),\n            // do not let the browser to move focus.\n            preventDefault();\n            nativeFocus(nextElement);\n          } else if (lastMoverOrGroupper) {\n            (_c = lastMoverOrGroupper.dummyManager) === null || _c === void 0 ? void 0 : _c.moveOutWithDefaultAction(isBackward);\n          } else if (ctx.modalizer) {\n            const nextElementCtx = RootAPI.getTabsterContext(tabster, nextElement);\n\n            if ((!nextElementCtx || ctx.root.uid !== nextElementCtx.root.uid || !((_d = nextElementCtx.modalizer) === null || _d === void 0 ? void 0 : _d.isActive())) && ctx.modalizer.triggerFocusEvent(ModalizerBeforeFocusOutEventName, true)) {\n              preventDefault();\n            } else if (!((_e = ctx.modalizer.getElement()) === null || _e === void 0 ? void 0 : _e.contains(nextElement))) {\n              preventDefault();\n              (_f = ctx.modalizer.dummyManager) === null || _f === void 0 ? void 0 : _f.moveOut(isBackward);\n            }\n          }\n        } else if (nextElement.tagName !== \"IFRAME\") {\n          preventDefault();\n          nativeFocus(nextElement);\n        }\n      } else {\n        ctx.root.moveOutWithDefaultAction(isBackward);\n      }\n    };\n\n    this._onChanged = (element, details) => {\n      var _a, _b;\n\n      if (element) {\n        triggerEvent(element, FocusInEventName, details);\n      } else {\n        const last = (_a = this._lastVal) === null || _a === void 0 ? void 0 : _a.get();\n\n        if (last) {\n          const d = { ...details\n          };\n          const lastCtx = RootAPI.getTabsterContext(this._tabster, last);\n          const modalizerId = (_b = lastCtx === null || lastCtx === void 0 ? void 0 : lastCtx.modalizer) === null || _b === void 0 ? void 0 : _b.userId;\n\n          if (modalizerId) {\n            d.modalizerId = modalizerId;\n          }\n\n          triggerEvent(last, FocusOutEventName, d);\n        }\n      }\n    };\n\n    this._tabster = tabster;\n    this._win = getWindow;\n    tabster.queueInit(this._init);\n  }\n\n  dispose() {\n    super.dispose();\n\n    const win = this._win();\n\n    win.document.removeEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);\n    win.document.removeEventListener(\"focusout\", this._onFocusOut, true);\n    win.removeEventListener(\"keydown\", this._onKeyDown, true);\n    this.unsubscribe(this._onChanged);\n    delete FocusedElementState._lastResetElement;\n    delete this._nextVal;\n    delete this._lastVal;\n  }\n\n  static forgetMemorized(instance, parent) {\n    var _a, _b;\n\n    let wel = FocusedElementState._lastResetElement;\n    let el = wel && wel.get();\n\n    if (el && parent.contains(el)) {\n      delete FocusedElementState._lastResetElement;\n    }\n\n    el = (_b = (_a = instance._nextVal) === null || _a === void 0 ? void 0 : _a.element) === null || _b === void 0 ? void 0 : _b.get();\n\n    if (el && parent.contains(el)) {\n      delete instance._nextVal;\n    }\n\n    wel = instance._lastVal;\n    el = wel && wel.get();\n\n    if (el && parent.contains(el)) {\n      delete instance._lastVal;\n    }\n  }\n\n  getFocusedElement() {\n    return this.getVal();\n  }\n\n  getLastFocusedElement() {\n    var _a;\n\n    let el = (_a = this._lastVal) === null || _a === void 0 ? void 0 : _a.get();\n\n    if (!el || el && !documentContains(el.ownerDocument, el)) {\n      this._lastVal = el = undefined;\n    }\n\n    return el;\n  }\n\n  focus(element, noFocusedProgrammaticallyFlag, noAccessibleCheck) {\n    if (!this._tabster.focusable.isFocusable(element, noFocusedProgrammaticallyFlag, false, noAccessibleCheck)) {\n      return false;\n    }\n\n    element.focus();\n    return true;\n  }\n\n  focusDefault(container) {\n    const el = this._tabster.focusable.findDefault({\n      container\n    });\n\n    if (el) {\n      this._tabster.focusedElement.focus(el);\n\n      return true;\n    }\n\n    return false;\n  }\n\n  getFirstOrLastTabbable(isFirst, props) {\n    const tabsterFocusable = this._tabster.focusable;\n    const {\n      container,\n      ignoreAccessibility\n    } = props;\n    let uncontrolled;\n    let toFocus;\n\n    if (container) {\n      const ctx = RootAPI.getTabsterContext(this._tabster, container);\n\n      if (ctx) {\n        let next = FocusedElementState.findNextTabbable(this._tabster, ctx, container, undefined, !isFirst, undefined, ignoreAccessibility);\n\n        if (next) {\n          toFocus = next.element;\n          uncontrolled = next.uncontrolled;\n\n          while (!toFocus && uncontrolled) {\n            if (tabsterFocusable.isFocusable(uncontrolled, false, true, true)) {\n              toFocus = uncontrolled;\n            } else {\n              toFocus = tabsterFocusable[isFirst ? \"findFirst\" : \"findLast\"]({\n                container: uncontrolled,\n                ignoreUncontrolled: true,\n                ignoreAccessibility,\n                useActiveModalizer: true\n              });\n            }\n\n            if (!toFocus) {\n              next = FocusedElementState.findNextTabbable(this._tabster, ctx, uncontrolled, undefined, !isFirst, undefined, ignoreAccessibility);\n\n              if (next) {\n                toFocus = next.element;\n                uncontrolled = next.uncontrolled;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (toFocus && !(container === null || container === void 0 ? void 0 : container.contains(toFocus))) {\n      toFocus = undefined;\n    }\n\n    return toFocus || undefined;\n  }\n\n  _focusFirstOrLast(isFirst, props) {\n    const toFocus = this.getFirstOrLastTabbable(isFirst, props);\n\n    if (toFocus) {\n      this.focus(toFocus, false, true);\n      return true;\n    }\n\n    return false;\n  }\n\n  focusFirst(props) {\n    return this._focusFirstOrLast(true, props);\n  }\n\n  focusLast(props) {\n    return this._focusFirstOrLast(false, props);\n  }\n\n  resetFocus(container) {\n    if (!this._tabster.focusable.isVisible(container)) {\n      return false;\n    }\n\n    if (!this._tabster.focusable.isFocusable(container, true, true, true)) {\n      const prevTabIndex = container.getAttribute(\"tabindex\");\n      const prevAriaHidden = container.getAttribute(\"aria-hidden\");\n      container.tabIndex = -1;\n      container.setAttribute(\"aria-hidden\", \"true\");\n      FocusedElementState._lastResetElement = new WeakHTMLElement(this._win, container);\n      this.focus(container, true, true);\n\n      this._setOrRemoveAttribute(container, \"tabindex\", prevTabIndex);\n\n      this._setOrRemoveAttribute(container, \"aria-hidden\", prevAriaHidden);\n    } else {\n      this.focus(container);\n    }\n\n    return true;\n  }\n\n  _setOrRemoveAttribute(element, name, value) {\n    if (value === null) {\n      element.removeAttribute(name);\n    } else {\n      element.setAttribute(name, value);\n    }\n  }\n\n  _setFocusedElement(element, relatedTarget, isFocusedProgrammatically) {\n    var _a, _b;\n\n    if (this._tabster._noop) {\n      return;\n    }\n\n    const details = {\n      relatedTarget\n    };\n\n    if (element) {\n      const lastResetElement = (_a = FocusedElementState._lastResetElement) === null || _a === void 0 ? void 0 : _a.get();\n      FocusedElementState._lastResetElement = undefined;\n\n      if (lastResetElement === element || shouldIgnoreFocus(element)) {\n        return;\n      }\n\n      details.isFocusedProgrammatically = isFocusedProgrammatically;\n      const ctx = RootAPI.getTabsterContext(this._tabster, element);\n      const modalizerId = (_b = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer) === null || _b === void 0 ? void 0 : _b.userId;\n\n      if (modalizerId) {\n        details.modalizerId = modalizerId;\n      }\n    }\n\n    const nextVal = this._nextVal = {\n      element: element ? new WeakHTMLElement(this._win, element) : undefined,\n      details\n    };\n\n    if (element && element !== this._val) {\n      this._validateFocusedElement(element);\n    } // _validateFocusedElement() might cause the refocus which will trigger\n    // another call to this function. Making sure that the value is correct.\n\n\n    if (this._nextVal === nextVal) {\n      this.setVal(element, details);\n    }\n\n    this._nextVal = undefined;\n  }\n\n  setVal(val, details) {\n    super.setVal(val, details);\n\n    if (val) {\n      this._lastVal = new WeakHTMLElement(this._win, val);\n    }\n  }\n\n  static findNextTabbable(tabster, ctx, container, currentElement, isBackward, ignoreUncontrolled, ignoreAccessibility) {\n    const actualContainer = container || ctx.root.getElement();\n\n    if (!actualContainer) {\n      return null;\n    }\n\n    let next = null;\n    const isTabbingTimer = FocusedElementState._isTabbingTimer;\n    const win = tabster.getWindow();\n\n    if (isTabbingTimer) {\n      win.clearTimeout(isTabbingTimer);\n    }\n\n    FocusedElementState.isTabbing = true;\n    FocusedElementState._isTabbingTimer = win.setTimeout(() => {\n      delete FocusedElementState._isTabbingTimer;\n      FocusedElementState.isTabbing = false;\n    }, 0);\n\n    const callFindNext = (what, cur) => {\n      next = what.findNextTabbable(cur || currentElement, isBackward, ignoreUncontrolled, ignoreAccessibility);\n      const lastMoverOrGroupper = next === null || next === void 0 ? void 0 : next.lastMoverOrGroupper;\n\n      if (lastMoverOrGroupper && !(next === null || next === void 0 ? void 0 : next.element) && !(next === null || next === void 0 ? void 0 : next.uncontrolled)) {\n        // Handling nested Movers and Grouppers. If not found in the current one,\n        // try the parent one.\n        const lastMoverOrGroupperElement = lastMoverOrGroupper.getElement();\n        const parentElement = lastMoverOrGroupperElement === null || lastMoverOrGroupperElement === void 0 ? void 0 : lastMoverOrGroupperElement.parentElement;\n        const parentCtx = parentElement && RootAPI.getTabsterContext(tabster, parentElement);\n\n        if (parentCtx) {\n          const isGroupperFirst = parentCtx.isGroupperFirst;\n          const parentMoverOrGroupper = isGroupperFirst ? parentCtx.groupper : parentCtx.mover;\n\n          if (parentMoverOrGroupper) {\n            const newCurrent = isBackward ? lastMoverOrGroupperElement : getLastChild(lastMoverOrGroupperElement);\n            callFindNext(parentMoverOrGroupper, newCurrent);\n\n            if (next) {\n              next.outOfDOMOrder = true;\n            }\n          }\n        }\n      }\n    };\n\n    const modalizer = ctx.modalizer;\n    const groupper = ctx.groupper;\n    const mover = ctx.mover;\n\n    if (groupper && mover) {\n      callFindNext(ctx.isGroupperFirst ? groupper : mover);\n    } else if (groupper) {\n      callFindNext(groupper);\n    } else if (mover) {\n      callFindNext(mover);\n    } else if (modalizer) {\n      callFindNext(modalizer);\n    } else {\n      let uncontrolled;\n\n      const onUncontrolled = el => {\n        uncontrolled = el;\n      };\n\n      const nextElement = isBackward ? tabster.focusable.findPrev({\n        container: actualContainer,\n        currentElement,\n        onUncontrolled,\n        ignoreUncontrolled,\n        ignoreAccessibility,\n        useActiveModalizer: true\n      }) : tabster.focusable.findNext({\n        container: actualContainer,\n        currentElement,\n        onUncontrolled,\n        ignoreUncontrolled,\n        ignoreAccessibility,\n        useActiveModalizer: true\n      });\n      next = {\n        element: uncontrolled ? undefined : nextElement,\n        uncontrolled\n      };\n    }\n\n    const lastMoverOrGroupper = next === null || next === void 0 ? void 0 : next.lastMoverOrGroupper;\n    const lastMoverOrGroupperElement = lastMoverOrGroupper === null || lastMoverOrGroupper === void 0 ? void 0 : lastMoverOrGroupper.getElement();\n\n    if (lastMoverOrGroupperElement) {\n      next = null;\n      const adjacentElement = getAdjacentElement(lastMoverOrGroupperElement, isBackward);\n\n      if (adjacentElement) {\n        const adjacentCtx = RootAPI.getTabsterContext(tabster, adjacentElement, {\n          checkRtl: true\n        });\n\n        if (adjacentCtx) {\n          let adjacentFrom = getAdjacentElement(adjacentElement, !isBackward);\n\n          if (adjacentFrom) {\n            if (!isBackward) {\n              adjacentFrom = getLastChild(adjacentFrom) || adjacentFrom;\n            }\n\n            next = FocusedElementState.findNextTabbable(tabster, adjacentCtx, actualContainer, adjacentFrom, isBackward, ignoreUncontrolled, ignoreAccessibility);\n\n            if (next && !next.lastMoverOrGroupper) {\n              next.lastMoverOrGroupper = lastMoverOrGroupper;\n            }\n          }\n        }\n      }\n    }\n\n    return next;\n  }\n\n}\nFocusedElementState.isTabbing = false;\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nclass GroupperDummyManager extends DummyInputManager {\n  constructor(element, groupper, tabster, sys) {\n    super(tabster, element, DummyInputManagerPriorities.Groupper, sys, true);\n\n    this._setHandlers((dummyInput, isBackward, relatedTarget) => {\n      var _a, _b;\n\n      const container = element.get();\n      const input = dummyInput.input;\n\n      if (container && input) {\n        const ctx = RootAPI.getTabsterContext(tabster, input);\n\n        if (ctx) {\n          let next;\n          next = (_a = groupper.findNextTabbable(relatedTarget || undefined, isBackward, true, true)) === null || _a === void 0 ? void 0 : _a.element;\n\n          if (!next) {\n            next = (_b = FocusedElementState.findNextTabbable(tabster, ctx, undefined, dummyInput.isOutside ? input : getAdjacentElement(container, !isBackward), isBackward, true, true)) === null || _b === void 0 ? void 0 : _b.element;\n          }\n\n          if (next) {\n            nativeFocus(next);\n          }\n        }\n      }\n    });\n  }\n\n}\n\nclass Groupper extends TabsterPart {\n  constructor(tabster, element, onDispose, props, sys) {\n    super(tabster, element, props);\n    this._shouldTabInside = false;\n    this.makeTabbable(false);\n    this._onDispose = onDispose;\n\n    if (!tabster.controlTab) {\n      this.dummyManager = new GroupperDummyManager(this._element, this, tabster, sys);\n    }\n  }\n\n  dispose() {\n    var _a;\n\n    this._onDispose(this);\n\n    const element = this._element.get();\n\n    (_a = this.dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();\n\n    if (element) {\n      if (process.env.NODE_ENV === 'development') {\n        _setInformativeStyle$1(this._element, true);\n      }\n    }\n\n    delete this._first;\n  }\n\n  findNextTabbable(currentElement, isBackward, ignoreUncontrolled, ignoreAccessibility) {\n    var _a;\n\n    const groupperElement = this.getElement();\n\n    if (!groupperElement) {\n      return null;\n    }\n\n    const currentIsDummy = ((_a = currentElement === null || currentElement === void 0 ? void 0 : currentElement.__tabsterDummyContainer) === null || _a === void 0 ? void 0 : _a.get()) === groupperElement;\n\n    if (!this._shouldTabInside && currentElement && groupperElement.contains(currentElement) && !currentIsDummy) {\n      return {\n        element: undefined,\n        lastMoverOrGroupper: this\n      };\n    }\n\n    const groupperFirstFocusable = this.getFirst(true);\n\n    if (!currentElement || !groupperElement.contains(currentElement) || currentIsDummy) {\n      return {\n        element: groupperFirstFocusable,\n        lastMoverOrGroupper: groupperFirstFocusable ? undefined : this\n      };\n    }\n\n    const tabster = this._tabster;\n    let next = null;\n    let uncontrolled;\n\n    const onUncontrolled = el => {\n      uncontrolled = el;\n    };\n\n    if (this._shouldTabInside && groupperFirstFocusable) {\n      next = isBackward ? tabster.focusable.findPrev({\n        container: groupperElement,\n        currentElement,\n        onUncontrolled,\n        ignoreUncontrolled,\n        ignoreAccessibility,\n        useActiveModalizer: true\n      }) : tabster.focusable.findNext({\n        container: groupperElement,\n        currentElement,\n        onUncontrolled,\n        ignoreUncontrolled,\n        ignoreAccessibility,\n        useActiveModalizer: true\n      });\n\n      if (!uncontrolled && !next && this._props.tabbability === GroupperTabbabilities.LimitedTrapFocus) {\n        next = isBackward ? tabster.focusable.findLast({\n          container: groupperElement,\n          ignoreUncontrolled: true,\n          ignoreAccessibility,\n          useActiveModalizer: true\n        }) : tabster.focusable.findFirst({\n          container: groupperElement,\n          ignoreUncontrolled: true,\n          ignoreAccessibility,\n          useActiveModalizer: true\n        });\n      }\n    }\n\n    return {\n      element: next,\n      uncontrolled,\n      lastMoverOrGroupper: next || uncontrolled ? undefined : this\n    };\n  }\n\n  makeTabbable(isTabbable) {\n    this._shouldTabInside = isTabbable || !this._props.tabbability;\n\n    if (process.env.NODE_ENV === 'development') {\n      _setInformativeStyle$1(this._element, !this._shouldTabInside);\n    }\n  }\n\n  isActive(noIfFirstIsFocused) {\n    var _a;\n\n    const element = this.getElement() || null;\n    let isParentActive = true;\n\n    for (let e = element === null || element === void 0 ? void 0 : element.parentElement; e; e = e.parentElement) {\n      const g = (_a = getTabsterOnElement(this._tabster, e)) === null || _a === void 0 ? void 0 : _a.groupper;\n\n      if (g) {\n        if (!g._shouldTabInside) {\n          isParentActive = false;\n        }\n      }\n    }\n\n    let ret = isParentActive ? this._props.tabbability ? this._shouldTabInside : false : undefined;\n\n    if (ret && noIfFirstIsFocused) {\n      const focused = this._tabster.focusedElement.getFocusedElement();\n\n      if (focused) {\n        ret = focused !== this.getFirst(true);\n      }\n    }\n\n    return ret;\n  }\n\n  getFirst(orContainer) {\n    var _a;\n\n    const groupperElement = this.getElement();\n    let first;\n\n    if (groupperElement) {\n      if (orContainer && this._tabster.focusable.isFocusable(groupperElement)) {\n        return groupperElement;\n      }\n\n      first = (_a = this._first) === null || _a === void 0 ? void 0 : _a.get();\n\n      if (!first) {\n        first = this._tabster.focusable.findFirst({\n          container: groupperElement,\n          ignoreUncontrolled: true,\n          useActiveModalizer: true\n        }) || undefined;\n\n        if (first) {\n          this.setFirst(first);\n        }\n      }\n    }\n\n    return first;\n  }\n\n  setFirst(element) {\n    if (element) {\n      this._first = new WeakHTMLElement(this._tabster.getWindow, element);\n    } else {\n      delete this._first;\n    }\n  }\n\n  acceptElement(element, state) {\n    var _a;\n\n    const cachedGrouppers = state.cachedGrouppers;\n    const parentElement = (_a = this.getElement()) === null || _a === void 0 ? void 0 : _a.parentElement;\n    const parentCtx = parentElement && RootAPI.getTabsterContext(this._tabster, parentElement);\n    const parentCtxGroupper = parentCtx === null || parentCtx === void 0 ? void 0 : parentCtx.groupper;\n    const parentGroupper = (parentCtx === null || parentCtx === void 0 ? void 0 : parentCtx.isGroupperFirst) ? parentCtxGroupper : undefined;\n    let parentGroupperElement;\n\n    const getIsActive = groupper => {\n      let cached = cachedGrouppers[groupper.id];\n      let isActive;\n\n      if (cached) {\n        isActive = cached.isActive;\n      } else {\n        isActive = this.isActive(true);\n        cached = cachedGrouppers[groupper.id] = {\n          isActive\n        };\n      }\n\n      return isActive;\n    };\n\n    if (parentGroupper) {\n      parentGroupperElement = parentGroupper.getElement();\n\n      if (!getIsActive(parentGroupper) && parentGroupperElement && state.container !== parentGroupperElement && state.container.contains(parentGroupperElement)) {\n        // Do not fall into a child groupper of inactive parent groupper if it's in the scope of the search.\n        return NodeFilter.FILTER_REJECT;\n      }\n    }\n\n    const isActive = getIsActive(this);\n    const groupperElement = this.getElement();\n\n    if (groupperElement) {\n      if (isActive !== true) {\n        if (groupperElement === element && parentCtxGroupper) {\n          if (!parentGroupperElement) {\n            parentGroupperElement = parentCtxGroupper.getElement();\n          }\n\n          if (parentGroupperElement && !getIsActive(parentCtxGroupper) && state.container.contains(parentGroupperElement) && parentGroupperElement !== state.container) {\n            return NodeFilter.FILTER_REJECT;\n          }\n        }\n\n        if (groupperElement !== element && groupperElement.contains(element)) {\n          return NodeFilter.FILTER_REJECT;\n        }\n\n        const cached = cachedGrouppers[this.id];\n        let first;\n\n        if (\"first\" in cached) {\n          first = cached.first;\n        } else {\n          first = cached.first = this.getFirst(true);\n        }\n\n        if (first && state.acceptCondition(first)) {\n          state.lastToIgnore = groupperElement;\n\n          if (first !== state.from) {\n            state.found = true;\n            state.foundElement = first;\n            return NodeFilter.FILTER_ACCEPT;\n          } else {\n            return NodeFilter.FILTER_REJECT;\n          }\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\nclass GroupperAPI {\n  constructor(tabster, getWindow) {\n    this._current = {};\n    this._grouppers = {};\n\n    this._init = () => {\n      const win = this._win(); // Making sure groupper's onFocus is called before modalizer's onFocus.\n\n\n      this._tabster.focusedElement.subscribeFirst(this._onFocus);\n\n      win.document.addEventListener(\"mousedown\", this._onMouseDown, true);\n      win.addEventListener(\"keydown\", this._onKeyDown, true);\n    };\n\n    this._onGroupperDispose = groupper => {\n      delete this._grouppers[groupper.id];\n    };\n\n    this._onFocus = element => {\n      if (element) {\n        this._updateCurrent(element, true, true);\n      }\n    };\n\n    this._onMouseDown = e => {\n      if (e.target) {\n        this._updateCurrent(e.target, true);\n      }\n    };\n\n    this._onKeyDown = event => {\n      if (event.keyCode !== Keys.Enter && event.keyCode !== Keys.Esc) {\n        return;\n      } // Give a chance to other listeners to handle the event.\n\n\n      if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {\n        return;\n      }\n\n      const element = this._tabster.focusedElement.getFocusedElement();\n\n      if (element) {\n        this.handleKeyPress(element, event);\n      }\n    };\n\n    this._tabster = tabster;\n    this._win = getWindow;\n    tabster.queueInit(this._init);\n  }\n\n  dispose() {\n    const win = this._win();\n\n    this._current = {};\n\n    if (this._updateTimer) {\n      win.clearTimeout(this._updateTimer);\n      delete this._updateTimer;\n    }\n\n    this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n    win.document.removeEventListener(\"mousedown\", this._onMouseDown, true);\n    win.removeEventListener(\"keydown\", this._onKeyDown, true);\n    Object.keys(this._grouppers).forEach(groupperId => {\n      if (this._grouppers[groupperId]) {\n        this._grouppers[groupperId].dispose();\n\n        delete this._grouppers[groupperId];\n      }\n    });\n  }\n\n  createGroupper(element, props, sys) {\n    if (process.env.NODE_ENV === 'development') ;\n\n    const newGroupper = new Groupper(this._tabster, element, this._onGroupperDispose, props, sys);\n    this._grouppers[newGroupper.id] = newGroupper;\n\n    const focusedElement = this._tabster.focusedElement.getFocusedElement(); // Newly created groupper contains currently focused element, update the state on the next tick (to\n    // make sure all grouppers are processed).\n\n\n    if (focusedElement && element.contains(focusedElement) && !this._updateTimer) {\n      this._updateTimer = this._win().setTimeout(() => {\n        delete this._updateTimer; // Making sure the focused element hasn't changed.\n\n        if (focusedElement === this._tabster.focusedElement.getFocusedElement()) {\n          this._updateCurrent(focusedElement, true, true);\n        }\n      }, 0);\n    }\n\n    return newGroupper;\n  }\n\n  forgetCurrentGrouppers() {\n    this._current = {};\n  }\n\n  _updateCurrent(element, includeTarget, checkTarget) {\n    var _a;\n\n    if (this._updateTimer) {\n      this._win().clearTimeout(this._updateTimer);\n\n      delete this._updateTimer;\n    }\n\n    const newIds = {};\n    let isTarget = true;\n\n    for (let el = element; el; el = el.parentElement) {\n      const groupper = (_a = getTabsterOnElement(this._tabster, el)) === null || _a === void 0 ? void 0 : _a.groupper;\n\n      if (groupper) {\n        newIds[groupper.id] = true;\n\n        if (isTarget && checkTarget && el !== element) {\n          isTarget = false;\n        }\n\n        if (includeTarget || !isTarget) {\n          this._current[groupper.id] = groupper;\n          const isTabbable = groupper.isActive() || element !== el && (!groupper.getProps().delegated || groupper.getFirst(false) !== element);\n          groupper.makeTabbable(isTabbable);\n        }\n\n        isTarget = false;\n      }\n    }\n\n    for (const id of Object.keys(this._current)) {\n      const groupper = this._current[id];\n\n      if (!(groupper.id in newIds)) {\n        groupper.makeTabbable(false);\n        groupper.setFirst(undefined);\n        delete this._current[id];\n      }\n    }\n  }\n\n  handleKeyPress(element, event, noGoUp) {\n    var _a;\n\n    const tabster = this._tabster;\n    const ctx = RootAPI.getTabsterContext(tabster, element);\n    const modalizerInGroupper = ctx === null || ctx === void 0 ? void 0 : ctx.modalizerInGroupper;\n    let groupper = (ctx === null || ctx === void 0 ? void 0 : ctx.groupper) || modalizerInGroupper;\n\n    if (ctx && groupper) {\n      if (ctx.ignoreKeydown(event)) {\n        return;\n      }\n\n      let next;\n      const groupperElement = groupper.getElement();\n\n      if (event.keyCode === Keys.Enter) {\n        if (groupperElement && (element === groupperElement || groupper.getProps().delegated && element === groupper.getFirst(false))) {\n          next = tabster.focusable.findNext({\n            container: groupperElement,\n            currentElement: element,\n            useActiveModalizer: true\n          });\n        }\n      } else if (event.keyCode === Keys.Esc) {\n        if (groupperElement && groupperElement.contains(element)) {\n          if (element !== groupperElement || noGoUp) {\n            next = groupper.getFirst(true);\n          } else {\n            const parentElement = groupperElement.parentElement;\n            const parentCtx = parentElement ? RootAPI.getTabsterContext(tabster, parentElement) : undefined;\n            groupper = parentCtx === null || parentCtx === void 0 ? void 0 : parentCtx.groupper;\n            next = groupper === null || groupper === void 0 ? void 0 : groupper.getFirst(true);\n          }\n        }\n\n        if (groupper) {\n          groupper.makeTabbable(false);\n\n          if (modalizerInGroupper) {\n            (_a = tabster.modalizer) === null || _a === void 0 ? void 0 : _a.setActive(undefined);\n          }\n        }\n      }\n\n      if (next) {\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        next.focus();\n      }\n    }\n  }\n\n}\n\nfunction _setInformativeStyle$1(weakElement, remove) {\n  if (process.env.NODE_ENV === 'development') {\n    const element = weakElement.get();\n\n    if (element) {\n      if (remove) {\n        element.style.removeProperty(\"--tabster-groupper\");\n      } else {\n        element.style.setProperty(\"--tabster-groupper\", \"unlimited\");\n      }\n    }\n  }\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nclass KeyboardNavigationState extends Subscribable {\n  constructor(getWindow) {\n    super();\n\n    this._onChange = isNavigatingWithKeyboard => {\n      this.setVal(isNavigatingWithKeyboard, undefined);\n    };\n\n    this._keyborg = createKeyborg(getWindow());\n\n    this._keyborg.subscribe(this._onChange);\n  }\n\n  dispose() {\n    super.dispose();\n\n    if (this._keyborg) {\n      this._keyborg.unsubscribe(this._onChange);\n\n      disposeKeyborg(this._keyborg);\n      delete this._keyborg;\n    }\n  }\n\n  setNavigatingWithKeyboard(isNavigatingWithKeyboard) {\n    var _a;\n\n    (_a = this._keyborg) === null || _a === void 0 ? void 0 : _a.setVal(isNavigatingWithKeyboard);\n  }\n\n  isNavigatingWithKeyboard() {\n    var _a;\n\n    return !!((_a = this._keyborg) === null || _a === void 0 ? void 0 : _a.isNavigatingWithKeyboard());\n  }\n\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nlet _wasFocusedCounter = 0;\nconst _ariaHidden = \"aria-hidden\";\n\nfunction _setInformativeStyle(weakElement, remove, internalId, userId, isActive, wasFocused) {\n  if (process.env.NODE_ENV === 'development') {\n    const element = weakElement.get();\n\n    if (element) {\n      if (remove) {\n        element.style.removeProperty(\"--tabster-modalizer\");\n      } else {\n        element.style.setProperty(\"--tabster-modalizer\", internalId + \",\" + userId + \",\" + (isActive ? \"active\" : \"inactive\") + \",\" + \",\" + (wasFocused ? `focused(${wasFocused})` : \"not-focused\"));\n      }\n    }\n  }\n}\n/**\r\n * Manages the dummy inputs for the Modalizer.\r\n */\n\n\nclass ModalizerDummyManager extends DummyInputManager {\n  constructor(element, tabster, sys) {\n    super(tabster, element, DummyInputManagerPriorities.Modalizer, sys);\n\n    this._setHandlers((dummyInput, isBackward) => {\n      var _a, _b, _c;\n\n      const el = element.get();\n      const container = el && ((_a = RootAPI.getRoot(tabster, el)) === null || _a === void 0 ? void 0 : _a.getElement());\n      const input = dummyInput.input;\n      let toFocus;\n\n      if (container && input) {\n        const dummyContainer = (_b = input.__tabsterDummyContainer) === null || _b === void 0 ? void 0 : _b.get();\n        const ctx = RootAPI.getTabsterContext(tabster, dummyContainer || input);\n\n        if (ctx) {\n          toFocus = (_c = FocusedElementState.findNextTabbable(tabster, ctx, container, input, isBackward, true, true)) === null || _c === void 0 ? void 0 : _c.element;\n        }\n\n        if (toFocus) {\n          nativeFocus(toFocus);\n        }\n      }\n    });\n  }\n\n}\n\nclass Modalizer extends TabsterPart {\n  constructor(tabster, element, onDispose, props, sys, activeElements) {\n    super(tabster, element, props);\n    this._wasFocused = 0;\n    this.userId = props.id;\n    this._onDispose = onDispose;\n    this._activeElements = activeElements;\n\n    if (!tabster.controlTab) {\n      this.dummyManager = new ModalizerDummyManager(this._element, tabster, sys);\n    }\n\n    if (process.env.NODE_ENV === 'development') {\n      _setInformativeStyle(this._element, false, this.id, this.userId, this._isActive, this._wasFocused);\n    }\n  }\n\n  makeActive(isActive) {\n    if (this._isActive !== isActive) {\n      this._isActive = isActive;\n      const element = this.getElement();\n\n      if (element) {\n        const activeElements = this._activeElements;\n        const index = activeElements.map(e => e.deref()).indexOf(element);\n\n        if (isActive) {\n          if (index < 0) {\n            activeElements.push(new WeakRef(element));\n          }\n        } else {\n          if (index >= 0) {\n            activeElements.splice(index, 1);\n          }\n        }\n      }\n\n      if (process.env.NODE_ENV === 'development') {\n        _setInformativeStyle(this._element, false, this.id, this.userId, this._isActive, this._wasFocused);\n      }\n\n      this.triggerFocusEvent(isActive ? ModalizerActiveEventName : ModalizerInactiveEventName);\n    }\n  }\n\n  focused(noIncrement) {\n    if (!noIncrement) {\n      this._wasFocused = ++_wasFocusedCounter;\n    }\n\n    return this._wasFocused;\n  }\n\n  setProps(props) {\n    if (props.id) {\n      this.userId = props.id;\n    }\n\n    this._props = { ...props\n    };\n  }\n\n  dispose() {\n    var _a;\n\n    this.makeActive(false);\n\n    this._onDispose(this);\n\n    (_a = this.dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();\n    this._activeElements = [];\n\n    this._remove();\n  }\n\n  isActive() {\n    return !!this._isActive;\n  }\n\n  contains(element) {\n    var _a;\n\n    return !!((_a = this.getElement()) === null || _a === void 0 ? void 0 : _a.contains(element));\n  }\n\n  findNextTabbable(currentElement, isBackward, ignoreUncontrolled, ignoreAccessibility) {\n    var _a, _b;\n\n    const modalizerElement = this.getElement();\n\n    if (!modalizerElement) {\n      return null;\n    }\n\n    const tabster = this._tabster;\n    let next = null;\n    let uncontrolled;\n\n    const onUncontrolled = el => {\n      uncontrolled = el;\n    };\n\n    const container = currentElement && ((_a = RootAPI.getRoot(tabster, currentElement)) === null || _a === void 0 ? void 0 : _a.getElement());\n\n    if (container) {\n      next = tabster.focusable[isBackward ? \"findPrev\" : \"findNext\"]({\n        container,\n        currentElement,\n        onUncontrolled,\n        ignoreUncontrolled,\n        ignoreAccessibility,\n        useActiveModalizer: true\n      });\n\n      if (!uncontrolled && !next && this._props.isTrapped && ((_b = tabster.modalizer) === null || _b === void 0 ? void 0 : _b.activeId)) {\n        next = tabster.focusable[isBackward ? \"findLast\" : \"findFirst\"]({\n          container,\n          ignoreUncontrolled: true,\n          ignoreAccessibility,\n          useActiveModalizer: true\n        });\n      }\n    }\n\n    return {\n      element: next,\n      uncontrolled\n    };\n  }\n\n  triggerFocusEvent(eventName, allElements) {\n    const element = this.getElement();\n    let defaultPrevented = false;\n\n    if (element) {\n      const elements = allElements ? this._activeElements.map(e => e.deref()) : [element];\n\n      for (const el of elements) {\n        if (el && !triggerEvent(el, eventName, {\n          id: this.userId,\n          element,\n          eventName\n        })) {\n          defaultPrevented = true;\n        }\n      }\n    }\n\n    return defaultPrevented;\n  }\n\n  _remove() {\n    if (process.env.NODE_ENV === 'development') {\n      _setInformativeStyle(this._element, true);\n    }\n  }\n\n} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\nclass ModalizerAPI {\n  constructor(tabster, alwaysAccessibleSelector) {\n    this._onModalizerDispose = modalizer => {\n      const id = modalizer.id;\n      const userId = modalizer.userId;\n      const part = this._parts[userId];\n      delete this._modalizers[id];\n\n      if (part) {\n        delete part[id];\n\n        if (Object.keys(part).length === 0) {\n          delete this._parts[userId];\n\n          if (this.activeId === userId) {\n            this.setActive(undefined);\n          }\n        }\n      }\n    };\n\n    this._onKeyDown = event => {\n      var _a;\n\n      if (event.keyCode !== Keys.Esc) {\n        return;\n      }\n\n      const tabster = this._tabster;\n      const element = tabster.focusedElement.getFocusedElement();\n\n      if (element) {\n        const ctx = RootAPI.getTabsterContext(tabster, element);\n        const modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;\n\n        if (ctx && !ctx.groupper && (modalizer === null || modalizer === void 0 ? void 0 : modalizer.isActive()) && !ctx.ignoreKeydown(event)) {\n          const activeId = modalizer.userId;\n\n          if (activeId) {\n            const part = this._parts[activeId];\n\n            if (part) {\n              const focusedSince = Object.keys(part).map(id => {\n                var _a;\n\n                const m = part[id];\n                const el = m.getElement();\n                let groupper;\n\n                if (el) {\n                  groupper = (_a = getTabsterOnElement(this._tabster, el)) === null || _a === void 0 ? void 0 : _a.groupper;\n                }\n\n                return m && el && groupper ? {\n                  el,\n                  focusedSince: m.focused(true)\n                } : {\n                  focusedSince: 0\n                };\n              }).filter(f => f.focusedSince > 0).sort((a, b) => a.focusedSince > b.focusedSince ? -1 : a.focusedSince < b.focusedSince ? 1 : 0);\n\n              if (focusedSince.length) {\n                const groupperElement = focusedSince[0].el;\n\n                if (groupperElement) {\n                  (_a = tabster.groupper) === null || _a === void 0 ? void 0 : _a.handleKeyPress(groupperElement, event, true);\n                }\n              }\n            }\n          }\n        }\n      }\n    };\n    /**\r\n     * Subscribes to the focus state and handles modalizer related focus events\r\n     * @param e - Element that is focused\r\n     * @param details - Additional data about the focus event\r\n     */\n\n\n    this._onFocus = (focusedElement, details) => {\n      var _a, _b;\n\n      const ctx = focusedElement && RootAPI.getTabsterContext(this._tabster, focusedElement); // Modalizer behaviour is opt in, only apply to elements that have a tabster context\n\n      if (!ctx || !focusedElement) {\n        return;\n      }\n\n      const augmentedMap = this._augMap;\n\n      for (let e = focusedElement; e; e = e.parentElement) {\n        // If the newly focused element is inside some of the hidden containers,\n        // remove aria-hidden from those synchronously for the screen readers\n        // to be able to read the element. The rest of aria-hiddens, will be removed\n        // acynchronously for the sake of performance.\n        if (augmentedMap.has(e)) {\n          augmentedMap.delete(e);\n          augmentAttribute(this._tabster, e, _ariaHidden);\n        }\n      }\n\n      const modalizer = ctx.modalizer; // An inactive groupper with the modalizer on the same node will not give the modalizer\n      // in the context, yet we still want to track that the modalizer's container was focused.\n\n      (_b = modalizer || ((_a = getTabsterOnElement(this._tabster, focusedElement)) === null || _a === void 0 ? void 0 : _a.modalizer)) === null || _b === void 0 ? void 0 : _b.focused();\n\n      if ((modalizer === null || modalizer === void 0 ? void 0 : modalizer.userId) === this.activeId) {\n        this.currentIsOthersAccessible = modalizer === null || modalizer === void 0 ? void 0 : modalizer.getProps().isOthersAccessible;\n        return;\n      } // Developers calling `element.focus()` should change/deactivate active modalizer\n\n\n      if (details.isFocusedProgrammatically || this.currentIsOthersAccessible || (modalizer === null || modalizer === void 0 ? void 0 : modalizer.getProps().isAlwaysAccessible)) {\n        this.setActive(modalizer);\n      } else {\n        // Focused outside of the active modalizer, try pull focus back to current modalizer\n        const win = this._win();\n\n        win.clearTimeout(this._restoreModalizerFocusTimer); // TODO some rendering frameworks (i.e. React) might async rerender the DOM so we need to wait for a duration\n        // Figure out a better way of doing this rather than a 100ms timeout\n\n        this._restoreModalizerFocusTimer = win.setTimeout(() => this._restoreModalizerFocus(focusedElement), 100);\n      }\n    };\n\n    this._tabster = tabster;\n    this._win = tabster.getWindow;\n    this._modalizers = {};\n    this._parts = {};\n    this._augMap = new WeakMap();\n    this._aug = [];\n    this._alwaysAccessibleSelector = alwaysAccessibleSelector;\n    this.activeElements = [];\n\n    if (!tabster.controlTab) {\n      tabster.root.addDummyInputs();\n    }\n\n    const win = this._win();\n\n    win.addEventListener(\"keydown\", this._onKeyDown, true);\n    tabster.queueInit(() => {\n      this._tabster.focusedElement.subscribe(this._onFocus);\n    });\n  }\n\n  dispose() {\n    const win = this._win();\n\n    win.removeEventListener(\"keydown\", this._onKeyDown, true); // Dispose all modalizers managed by the API\n\n    Object.keys(this._modalizers).forEach(modalizerId => {\n      if (this._modalizers[modalizerId]) {\n        this._modalizers[modalizerId].dispose();\n\n        delete this._modalizers[modalizerId];\n      }\n    });\n    win.clearTimeout(this._restoreModalizerFocusTimer);\n    win.clearTimeout(this._hiddenUpdateTimer);\n    this._parts = {};\n    delete this.activeId;\n    this.activeElements = [];\n    this._augMap = new WeakMap();\n    this._aug = [];\n\n    this._tabster.focusedElement.unsubscribe(this._onFocus);\n  }\n\n  createModalizer(element, props, sys) {\n    var _a;\n\n    if (process.env.NODE_ENV === 'development') ;\n\n    const modalizer = new Modalizer(this._tabster, element, this._onModalizerDispose, props, sys, this.activeElements);\n    const id = modalizer.id;\n    const userId = props.id;\n    this._modalizers[id] = modalizer;\n    let part = this._parts[userId];\n\n    if (!part) {\n      part = this._parts[userId] = {};\n    }\n\n    part[id] = modalizer; // Adding a modalizer which is already focused, activate it\n\n    if (element.contains((_a = this._tabster.focusedElement.getFocusedElement()) !== null && _a !== void 0 ? _a : null)) {\n      if (userId !== this.activeId) {\n        this.setActive(modalizer);\n      } else {\n        modalizer.makeActive(true);\n      }\n    }\n\n    return modalizer;\n  }\n\n  isAugmented(element) {\n    return this._augMap.has(element);\n  }\n\n  hiddenUpdate() {\n    if (this._hiddenUpdateTimer) {\n      return;\n    }\n\n    this._hiddenUpdateTimer = this._win().setTimeout(() => {\n      delete this._hiddenUpdateTimer;\n\n      this._hiddenUpdate();\n    }, 250);\n  }\n\n  setActive(modalizer) {\n    const userId = modalizer === null || modalizer === void 0 ? void 0 : modalizer.userId;\n    const activeId = this.activeId;\n\n    if (activeId === userId) {\n      return;\n    }\n\n    this.activeId = userId;\n\n    if (activeId) {\n      const part = this._parts[activeId];\n\n      if (part) {\n        for (const id of Object.keys(part)) {\n          part[id].makeActive(false);\n        }\n      }\n    }\n\n    if (userId) {\n      const part = this._parts[userId];\n\n      if (part) {\n        for (const id of Object.keys(part)) {\n          part[id].makeActive(true);\n        }\n      }\n    }\n\n    this.currentIsOthersAccessible = modalizer === null || modalizer === void 0 ? void 0 : modalizer.getProps().isOthersAccessible;\n    this.hiddenUpdate();\n  }\n\n  focus(elementFromModalizer, noFocusFirst, noFocusDefault) {\n    const ctx = RootAPI.getTabsterContext(this._tabster, elementFromModalizer);\n    const modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;\n\n    if (modalizer) {\n      this.setActive(modalizer);\n      const props = modalizer.getProps();\n      const modalizerRoot = modalizer.getElement();\n\n      if (modalizerRoot) {\n        if (noFocusFirst === undefined) {\n          noFocusFirst = props.isNoFocusFirst;\n        }\n\n        if (!noFocusFirst && this._tabster.keyboardNavigation.isNavigatingWithKeyboard() && this._tabster.focusedElement.focusFirst({\n          container: modalizerRoot\n        })) {\n          return true;\n        }\n\n        if (noFocusDefault === undefined) {\n          noFocusDefault = props.isNoFocusDefault;\n        }\n\n        if (!noFocusDefault && this._tabster.focusedElement.focusDefault(modalizerRoot)) {\n          return true;\n        }\n\n        this._tabster.focusedElement.resetFocus(modalizerRoot);\n      }\n    } else if (process.env.NODE_ENV === 'development') {\n      console.error(\"Element is not in Modalizer.\", elementFromModalizer);\n    }\n\n    return false;\n  }\n\n  acceptElement(element, state) {\n    var _a;\n\n    const modalizerUserId = state.modalizerUserId;\n    const currentModalizer = (_a = state.currentCtx) === null || _a === void 0 ? void 0 : _a.modalizer;\n\n    if (modalizerUserId) {\n      for (const e of this.activeElements) {\n        const el = e.deref();\n\n        if (el && (element.contains(el) || el === element)) {\n          // We have a part of currently active modalizer somewhere deeper in the DOM,\n          // skipping all other checks.\n          return NodeFilter.FILTER_SKIP;\n        }\n      }\n    }\n\n    return modalizerUserId === (currentModalizer === null || currentModalizer === void 0 ? void 0 : currentModalizer.userId) || !modalizerUserId && (currentModalizer === null || currentModalizer === void 0 ? void 0 : currentModalizer.getProps().isAlwaysAccessible) ? undefined : NodeFilter.FILTER_SKIP;\n  }\n\n  _hiddenUpdate() {\n    var _a;\n\n    const tabster = this._tabster;\n    const body = tabster.getWindow().document.body;\n    const activeId = this.activeId;\n    const parts = this._parts;\n    const visibleElements = [];\n    const hiddenElements = [];\n    const alwaysAccessibleSelector = this._alwaysAccessibleSelector;\n    const alwaysAccessibleElements = alwaysAccessibleSelector ? Array.from(body.querySelectorAll(alwaysAccessibleSelector)) : [];\n\n    for (const userId of Object.keys(parts)) {\n      const mParts = parts[userId];\n\n      for (const id of Object.keys(mParts)) {\n        const m = mParts[id];\n        const el = m.getElement();\n        const props = m.getProps();\n        const isAlwaysAccessible = props.isAlwaysAccessible;\n\n        if (el) {\n          if (userId === activeId) {\n            if (!this.currentIsOthersAccessible) {\n              visibleElements.push(el);\n            }\n          } else if (isAlwaysAccessible) {\n            alwaysAccessibleElements.push(el);\n          } else {\n            hiddenElements.push(el);\n          }\n        }\n      }\n    }\n\n    const augmentedMap = this._augMap;\n    const allVisibleElements = visibleElements.length > 0 ? [...visibleElements, ...alwaysAccessibleElements] : undefined;\n    const newAugmented = [];\n    const newAugmentedMap = new WeakMap();\n\n    const toggle = (element, hide) => {\n      const tagName = element.tagName;\n\n      if (tagName === \"SCRIPT\" || tagName === \"STYLE\") {\n        return;\n      }\n\n      let isAugmented = false;\n\n      if (augmentedMap.has(element)) {\n        if (hide) {\n          isAugmented = true;\n        } else {\n          augmentedMap.delete(element);\n          augmentAttribute(tabster, element, _ariaHidden);\n        }\n      } else if (hide && augmentAttribute(tabster, element, _ariaHidden, \"true\")) {\n        augmentedMap.set(element, true);\n        isAugmented = true;\n      }\n\n      if (isAugmented) {\n        newAugmented.push(new WeakRef(element));\n        newAugmentedMap.set(element, true);\n      }\n    };\n\n    const walk = element => {\n      for (let el = element.firstElementChild; el; el = el.nextElementSibling) {\n        let skip = false;\n        let containsModalizer = false;\n\n        if (allVisibleElements) {\n          for (const c of allVisibleElements) {\n            if (el === c) {\n              skip = true;\n              break;\n            }\n\n            if (el.contains(c)) {\n              containsModalizer = true;\n              break;\n            }\n          }\n\n          if (containsModalizer) {\n            walk(el);\n          } else if (!skip) {\n            toggle(el, true);\n          }\n        } else {\n          toggle(el, false);\n        }\n      }\n    };\n\n    if (!allVisibleElements) {\n      alwaysAccessibleElements.forEach(e => toggle(e, false));\n    }\n\n    hiddenElements.forEach(e => toggle(e, true));\n\n    if (body) {\n      walk(body);\n    }\n\n    (_a = this._aug) === null || _a === void 0 ? void 0 : _a.map(e => e.deref()).forEach(e => {\n      if (e && !newAugmentedMap.get(e)) {\n        toggle(e, false);\n      }\n    });\n    this._aug = newAugmented;\n    this._augMap = newAugmentedMap;\n  }\n  /**\r\n   * Called when an element is focused outside of an active modalizer.\r\n   * Attempts to pull focus back into the active modalizer\r\n   * @param outsideElement - An element being focused outside of the modalizer\r\n   */\n\n\n  _restoreModalizerFocus(outsideElement) {\n    const ownerDocument = outsideElement === null || outsideElement === void 0 ? void 0 : outsideElement.ownerDocument;\n\n    if (!outsideElement || !ownerDocument) {\n      return;\n    }\n\n    const ctx = RootAPI.getTabsterContext(this._tabster, outsideElement);\n    const modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;\n    const activeId = this.activeId;\n\n    if (!modalizer && !activeId || modalizer && activeId === modalizer.userId) {\n      return;\n    }\n\n    const container = ctx === null || ctx === void 0 ? void 0 : ctx.root.getElement();\n\n    if (container) {\n      let toFocus = this._tabster.focusable.findFirst({\n        container,\n        ignoreUncontrolled: true,\n        useActiveModalizer: true\n      });\n\n      if (toFocus) {\n        if (outsideElement.compareDocumentPosition(toFocus) & document.DOCUMENT_POSITION_PRECEDING) {\n          toFocus = this._tabster.focusable.findLast({\n            container,\n            ignoreUncontrolled: true,\n            useActiveModalizer: true\n          });\n\n          if (!toFocus) {\n            // This only might mean that findFirst/findLast are buggy and inconsistent.\n            throw new Error(\"Something went wrong.\");\n          }\n        }\n\n        this._tabster.focusedElement.focus(toFocus);\n\n        return;\n      }\n    } // Current Modalizer doesn't seem to have focusable elements.\n    // Blurring the currently focused element which is outside of the current Modalizer.\n\n\n    outsideElement.blur();\n  }\n\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nconst _inputSelector = /*#__PURE__*/[\"input\", \"textarea\", \"*[contenteditable]\"].join(\", \");\n\nclass MoverDummyManager extends DummyInputManager {\n  constructor(element, tabster, getMemorized, sys) {\n    super(tabster, element, DummyInputManagerPriorities.Mover, sys);\n\n    this._onFocusDummyInput = dummyInput => {\n      var _a, _b;\n\n      const container = this._element.get();\n\n      const input = dummyInput.input;\n\n      if (container && input) {\n        const ctx = RootAPI.getTabsterContext(this._tabster, container);\n        let toFocus;\n\n        if (ctx) {\n          toFocus = (_a = FocusedElementState.findNextTabbable(this._tabster, ctx, undefined, input, !dummyInput.isFirst, true)) === null || _a === void 0 ? void 0 : _a.element;\n        }\n\n        const memorized = (_b = this._getMemorized()) === null || _b === void 0 ? void 0 : _b.get();\n\n        if (memorized) {\n          toFocus = memorized;\n        }\n\n        if (toFocus) {\n          nativeFocus(toFocus);\n        }\n      }\n    };\n\n    this._tabster = tabster;\n    this._getMemorized = getMemorized;\n\n    this._setHandlers(this._onFocusDummyInput);\n  }\n\n} // TypeScript enums produce depressing JavaScript code, so, we're just using\n// a few old style constants here.\n\n\nconst _moverUpdateAdd = 1;\nconst _moverUpdateAttr = 2;\nconst _moverUpdateRemove = 3;\nclass Mover extends TabsterPart {\n  constructor(tabster, element, onDispose, props, sys) {\n    var _a;\n\n    super(tabster, element, props);\n    this._visible = {};\n\n    this._onIntersection = entries => {\n      for (const entry of entries) {\n        const el = entry.target;\n        const id = getElementUId(this._win, el);\n        let newVisibility;\n        let fullyVisible = this._fullyVisible;\n\n        if (entry.intersectionRatio >= 0.25) {\n          newVisibility = entry.intersectionRatio >= 0.75 ? Visibilities.Visible : Visibilities.PartiallyVisible;\n\n          if (newVisibility === Visibilities.Visible) {\n            fullyVisible = id;\n          }\n        } else {\n          newVisibility = Visibilities.Invisible;\n        }\n\n        if (this._visible[id] !== newVisibility) {\n          if (newVisibility === undefined) {\n            delete this._visible[id];\n\n            if (fullyVisible === id) {\n              delete this._fullyVisible;\n            }\n          } else {\n            this._visible[id] = newVisibility;\n            this._fullyVisible = fullyVisible;\n          }\n\n          const state = this.getState(el);\n\n          if (state) {\n            triggerEvent(el, MoverEventName, state);\n          }\n        }\n      }\n    };\n\n    this._win = tabster.getWindow;\n    this.visibilityTolerance = (_a = props.visibilityTolerance) !== null && _a !== void 0 ? _a : 0.8;\n\n    if (this._props.trackState || this._props.visibilityAware) {\n      this._intersectionObserver = new IntersectionObserver(this._onIntersection, {\n        threshold: [0, 0.25, 0.5, 0.75, 1]\n      });\n\n      this._observeState();\n    }\n\n    this._onDispose = onDispose;\n\n    const getMemorized = () => props.memorizeCurrent ? this._current : undefined;\n\n    if (!tabster.controlTab) {\n      this.dummyManager = new MoverDummyManager(this._element, tabster, getMemorized, sys);\n    }\n  }\n\n  dispose() {\n    var _a;\n\n    this._onDispose(this);\n\n    if (this._intersectionObserver) {\n      this._intersectionObserver.disconnect();\n\n      delete this._intersectionObserver;\n    }\n\n    delete this._current;\n    delete this._fullyVisible;\n    delete this._allElements;\n    delete this._updateQueue;\n\n    if (this._unobserve) {\n      this._unobserve();\n\n      delete this._unobserve;\n    }\n\n    const win = this._win();\n\n    if (this._setCurrentTimer) {\n      win.clearTimeout(this._setCurrentTimer);\n      delete this._setCurrentTimer;\n    }\n\n    if (this._updateTimer) {\n      win.clearTimeout(this._updateTimer);\n      delete this._updateTimer;\n    }\n\n    (_a = this.dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();\n  }\n\n  setCurrent(element) {\n    if (element) {\n      this._current = new WeakHTMLElement(this._win, element);\n    } else {\n      this._current = undefined;\n    }\n\n    if ((this._props.trackState || this._props.visibilityAware) && !this._setCurrentTimer) {\n      this._setCurrentTimer = this._win().setTimeout(() => {\n        var _a;\n\n        delete this._setCurrentTimer;\n        const changed = [];\n\n        if (this._current !== this._prevCurrent) {\n          changed.push(this._current);\n          changed.push(this._prevCurrent);\n          this._prevCurrent = this._current;\n        }\n\n        for (const weak of changed) {\n          const el = weak === null || weak === void 0 ? void 0 : weak.get();\n\n          if (el && ((_a = this._allElements) === null || _a === void 0 ? void 0 : _a.get(el)) === this) {\n            const props = this._props;\n\n            if (el && (props.visibilityAware !== undefined || props.trackState)) {\n              const state = this.getState(el);\n\n              if (state) {\n                triggerEvent(el, MoverEventName, state);\n              }\n            }\n          }\n        }\n      });\n    }\n  }\n\n  getCurrent() {\n    var _a;\n\n    return ((_a = this._current) === null || _a === void 0 ? void 0 : _a.get()) || null;\n  }\n\n  findNextTabbable(currentElement, isBackward, ignoreUncontrolled, ignoreAccessibility) {\n    var _a;\n\n    const container = this.getElement();\n    const currentIsDummy = container && ((_a = currentElement === null || currentElement === void 0 ? void 0 : currentElement.__tabsterDummyContainer) === null || _a === void 0 ? void 0 : _a.get()) === container;\n\n    if (!container) {\n      return null;\n    }\n\n    const tabster = this._tabster;\n    const focusable = tabster.focusable;\n    let next = null;\n    let uncontrolled;\n\n    const onUncontrolled = el => {\n      uncontrolled = el;\n    };\n\n    if (this._props.tabbable || currentIsDummy || currentElement && !container.contains(currentElement)) {\n      next = isBackward ? focusable.findPrev({\n        currentElement,\n        container,\n        onUncontrolled,\n        ignoreUncontrolled,\n        ignoreAccessibility,\n        useActiveModalizer: true\n      }) : focusable.findNext({\n        currentElement,\n        container,\n        onUncontrolled,\n        ignoreUncontrolled,\n        ignoreAccessibility,\n        useActiveModalizer: true\n      });\n    }\n\n    return {\n      element: next,\n      uncontrolled,\n      lastMoverOrGroupper: next || uncontrolled ? undefined : this\n    };\n  }\n\n  acceptElement(element, state) {\n    var _a, _b, _c;\n\n    if (!FocusedElementState.isTabbing) {\n      return ((_a = state.currentCtx) === null || _a === void 0 ? void 0 : _a.isExcludedFromMover) ? NodeFilter.FILTER_REJECT : undefined;\n    }\n\n    const {\n      memorizeCurrent,\n      visibilityAware,\n      hasDefault = true\n    } = this._props;\n    const moverElement = this.getElement();\n\n    if (moverElement && (memorizeCurrent || visibilityAware || hasDefault) && (!moverElement.contains(state.from) || ((_b = state.from.__tabsterDummyContainer) === null || _b === void 0 ? void 0 : _b.get()) === moverElement)) {\n      let found;\n\n      if (memorizeCurrent) {\n        const current = (_c = this._current) === null || _c === void 0 ? void 0 : _c.get();\n\n        if (current && state.acceptCondition(current)) {\n          found = current;\n        }\n      }\n\n      if (!found && hasDefault) {\n        found = this._tabster.focusable.findDefault({\n          container: moverElement,\n          ignoreUncontrolled: true,\n          useActiveModalizer: true\n        });\n      }\n\n      if (!found && visibilityAware) {\n        found = this._tabster.focusable.findElement({\n          container: moverElement,\n          ignoreUncontrolled: true,\n          useActiveModalizer: true,\n          isBackward: state.isBackward,\n          acceptCondition: el => {\n            var _a;\n\n            const id = getElementUId(this._win, el);\n            const visibility = this._visible[id];\n            return moverElement !== el && !!((_a = this._allElements) === null || _a === void 0 ? void 0 : _a.get(el)) && state.acceptCondition(el) && (visibility === Visibilities.Visible || visibility === Visibilities.PartiallyVisible && (visibilityAware === Visibilities.PartiallyVisible || !this._fullyVisible));\n          }\n        });\n      }\n\n      if (found) {\n        state.found = true;\n        state.foundElement = found;\n        state.lastToIgnore = moverElement;\n        return NodeFilter.FILTER_ACCEPT;\n      }\n    }\n\n    return undefined;\n  }\n\n  _observeState() {\n    const element = this.getElement();\n\n    if (this._unobserve || !element || typeof MutationObserver === \"undefined\") {\n      return;\n    }\n\n    const win = this._win();\n\n    const allElements = this._allElements = new WeakMap();\n    const tabsterFocusable = this._tabster.focusable;\n    let updateQueue = this._updateQueue = [];\n    const observer = new MutationObserver(mutations => {\n      for (const mutation of mutations) {\n        const target = mutation.target;\n        const removed = mutation.removedNodes;\n        const added = mutation.addedNodes;\n\n        if (mutation.type === \"attributes\") {\n          if (mutation.attributeName === \"tabindex\") {\n            updateQueue.push({\n              element: target,\n              type: _moverUpdateAttr\n            });\n          }\n        } else {\n          for (let i = 0; i < removed.length; i++) {\n            updateQueue.push({\n              element: removed[i],\n              type: _moverUpdateRemove\n            });\n          }\n\n          for (let i = 0; i < added.length; i++) {\n            updateQueue.push({\n              element: added[i],\n              type: _moverUpdateAdd\n            });\n          }\n        }\n      }\n\n      requestUpdate();\n    });\n\n    const setElement = (element, remove) => {\n      var _a, _b;\n\n      const current = allElements.get(element);\n\n      if (current && remove) {\n        (_a = this._intersectionObserver) === null || _a === void 0 ? void 0 : _a.unobserve(element);\n        allElements.delete(element);\n      }\n\n      if (!current && !remove) {\n        allElements.set(element, this);\n        (_b = this._intersectionObserver) === null || _b === void 0 ? void 0 : _b.observe(element);\n      }\n    };\n\n    const updateElement = element => {\n      const isFocusable = tabsterFocusable.isFocusable(element);\n      const current = allElements.get(element);\n\n      if (current) {\n        if (!isFocusable) {\n          setElement(element, true);\n        }\n      } else {\n        if (isFocusable) {\n          setElement(element);\n        }\n      }\n    };\n\n    const addNewElements = element => {\n      const {\n        mover\n      } = getMoverGroupper(element);\n\n      if (mover && mover !== this) {\n        if (mover.getElement() === element && tabsterFocusable.isFocusable(element)) {\n          setElement(element);\n        } else {\n          return;\n        }\n      }\n\n      const walker = createElementTreeWalker(win.document, element, node => {\n        const {\n          mover,\n          groupper\n        } = getMoverGroupper(node);\n\n        if (mover && mover !== this) {\n          return NodeFilter.FILTER_REJECT;\n        }\n\n        const groupperFirstFocusable = groupper === null || groupper === void 0 ? void 0 : groupper.getFirst(true);\n\n        if (groupper && groupper.getElement() !== node && groupperFirstFocusable && groupperFirstFocusable !== node) {\n          return NodeFilter.FILTER_REJECT;\n        }\n\n        if (tabsterFocusable.isFocusable(node)) {\n          setElement(node);\n        }\n\n        return NodeFilter.FILTER_SKIP;\n      });\n\n      if (walker) {\n        walker.currentNode = element;\n\n        while (walker.nextNode()) {\n          /* Iterating for the sake of calling processNode() callback. */\n        }\n      }\n    };\n\n    const removeWalk = element => {\n      const current = allElements.get(element);\n\n      if (current) {\n        setElement(element, true);\n      }\n\n      for (let el = element.firstElementChild; el; el = el.nextElementSibling) {\n        removeWalk(el);\n      }\n    };\n\n    const requestUpdate = () => {\n      if (!this._updateTimer && updateQueue.length) {\n        this._updateTimer = win.setTimeout(() => {\n          delete this._updateTimer;\n\n          for (const {\n            element,\n            type\n          } of updateQueue) {\n            switch (type) {\n              case _moverUpdateAttr:\n                updateElement(element);\n                break;\n\n              case _moverUpdateAdd:\n                addNewElements(element);\n                break;\n\n              case _moverUpdateRemove:\n                removeWalk(element);\n                break;\n            }\n          }\n\n          updateQueue = this._updateQueue = [];\n        }, 0);\n      }\n    };\n\n    const getMoverGroupper = element => {\n      const ret = {};\n\n      for (let el = element; el; el = el.parentElement) {\n        const toe = getTabsterOnElement(this._tabster, el);\n\n        if (toe) {\n          if (toe.groupper && !ret.groupper) {\n            ret.groupper = toe.groupper;\n          }\n\n          if (toe.mover) {\n            ret.mover = toe.mover;\n            break;\n          }\n        }\n      }\n\n      return ret;\n    };\n\n    updateQueue.push({\n      element,\n      type: _moverUpdateAdd\n    });\n    requestUpdate();\n    observer.observe(element, {\n      childList: true,\n      subtree: true,\n      attributes: true,\n      attributeFilter: [\"tabindex\"]\n    });\n\n    this._unobserve = () => {\n      observer.disconnect();\n    };\n  }\n\n  getState(element) {\n    const id = getElementUId(this._win, element);\n\n    if (id in this._visible) {\n      const visibility = this._visible[id] || Visibilities.Invisible;\n      const isCurrent = this._current ? this._current.get() === element : undefined;\n      return {\n        isCurrent,\n        visibility\n      };\n    }\n\n    return undefined;\n  }\n\n} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n/**\r\n * Calculates distance between two rectangles.\r\n *\r\n * @param ax1 first rectangle left\r\n * @param ay1 first rectangle top\r\n * @param ax2 first rectangle right\r\n * @param ay2 first rectangle bottom\r\n * @param bx1 second rectangle left\r\n * @param by1 second rectangle top\r\n * @param bx2 second rectangle right\r\n * @param by2 second rectangle bottom\r\n * @returns number, shortest distance between the rectangles.\r\n */\n\n\nfunction getDistance(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {\n  const xDistance = ax2 < bx1 ? bx1 - ax2 : bx2 < ax1 ? ax1 - bx2 : 0;\n  const yDistance = ay2 < by1 ? by1 - ay2 : by2 < ay1 ? ay1 - by2 : 0;\n  return xDistance === 0 ? yDistance : yDistance === 0 ? xDistance : Math.sqrt(xDistance * xDistance + yDistance * yDistance);\n}\n\nclass MoverAPI {\n  constructor(tabster, getWindow) {\n    this._init = () => {\n      const win = this._win();\n\n      win.addEventListener(\"keydown\", this._onKeyDown, true);\n\n      this._tabster.focusedElement.subscribe(this._onFocus);\n    };\n\n    this._onMoverDispose = mover => {\n      delete this._movers[mover.id];\n    };\n\n    this._onFocus = e => {\n      var _a;\n\n      for (let el = e; el; el = el.parentElement) {\n        const mover = (_a = getTabsterOnElement(this._tabster, el)) === null || _a === void 0 ? void 0 : _a.mover;\n\n        if (mover) {\n          mover.setCurrent(e);\n          break;\n        }\n      }\n    };\n\n    this._onKeyDown = async event => {\n      var _a, _b, _c, _d;\n\n      if (this._ignoredInputTimer) {\n        this._win().clearTimeout(this._ignoredInputTimer);\n\n        delete this._ignoredInputTimer;\n      }\n\n      (_a = this._ignoredInputResolve) === null || _a === void 0 ? void 0 : _a.call(this, false);\n      let keyCode = event.keyCode; // Give a chance to other listeners to handle the event (for example,\n      // to scroll instead of moving focus).\n\n      if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {\n        return;\n      }\n\n      switch (keyCode) {\n        case Keys.Down:\n        case Keys.Right:\n        case Keys.Up:\n        case Keys.Left:\n        case Keys.PageDown:\n        case Keys.PageUp:\n        case Keys.Home:\n        case Keys.End:\n          break;\n\n        default:\n          return;\n      }\n\n      const tabster = this._tabster;\n      const focused = tabster.focusedElement.getFocusedElement();\n\n      if (!focused || (await this._isIgnoredInput(focused, keyCode))) {\n        return;\n      }\n\n      const ctx = RootAPI.getTabsterContext(tabster, focused, {\n        checkRtl: true\n      });\n\n      if (!ctx || !ctx.mover || ctx.isExcludedFromMover || ctx.ignoreKeydown(event)) {\n        return;\n      }\n\n      const mover = ctx.mover;\n      const container = mover.getElement();\n\n      if (ctx.isGroupperFirst) {\n        const groupper = ctx.groupper;\n\n        if (groupper && !groupper.isActive(true)) {\n          // For the cases when we have Mover/Active Groupper/Inactive Groupper, we need to check\n          // the grouppers between the current element and the current mover.\n          for (let el = (_b = groupper.getElement()) === null || _b === void 0 ? void 0 : _b.parentElement; el && el !== container; el = el.parentElement) {\n            if ((_d = (_c = getTabsterOnElement(tabster, el)) === null || _c === void 0 ? void 0 : _c.groupper) === null || _d === void 0 ? void 0 : _d.isActive(true)) {\n              return;\n            }\n          }\n        } else {\n          return;\n        }\n      }\n\n      if (!container) {\n        return;\n      }\n\n      const focusable = tabster.focusable;\n      const moverProps = mover.getProps();\n      const direction = moverProps.direction || MoverDirections.Both;\n      const isBoth = direction === MoverDirections.Both;\n      const isVertical = isBoth || direction === MoverDirections.Vertical;\n      const isHorizontal = isBoth || direction === MoverDirections.Horizontal;\n      const isGridLinear = direction === MoverDirections.GridLinear;\n      const isGrid = isGridLinear || direction === MoverDirections.Grid;\n      const isCyclic = moverProps.cyclic;\n      let next;\n      let focusedElementRect;\n      let focusedElementX1 = 0;\n      let focusedElementX2 = 0;\n\n      if (isGrid) {\n        focusedElementRect = focused.getBoundingClientRect();\n        focusedElementX1 = Math.ceil(focusedElementRect.left);\n        focusedElementX2 = Math.floor(focusedElementRect.right);\n      }\n\n      if (ctx.isRtl) {\n        if (keyCode === Keys.Right) {\n          keyCode = Keys.Left;\n        } else if (keyCode === Keys.Left) {\n          keyCode = Keys.Right;\n        }\n      }\n\n      if (keyCode === Keys.Down && isVertical || keyCode === Keys.Right && (isHorizontal || isGrid)) {\n        next = focusable.findNext({\n          currentElement: focused,\n          container,\n          useActiveModalizer: true\n        });\n\n        if (next && isGrid) {\n          const nextElementX1 = Math.ceil(next.getBoundingClientRect().left);\n\n          if (!isGridLinear && focusedElementX2 > nextElementX1) {\n            next = undefined;\n          }\n        } else if (!next && isCyclic) {\n          next = focusable.findFirst({\n            container,\n            ignoreUncontrolled: true,\n            useActiveModalizer: true\n          });\n        }\n      } else if (keyCode === Keys.Up && isVertical || keyCode === Keys.Left && (isHorizontal || isGrid)) {\n        next = focusable.findPrev({\n          currentElement: focused,\n          container,\n          useActiveModalizer: true\n        });\n\n        if (next && isGrid) {\n          const nextElementX2 = Math.floor(next.getBoundingClientRect().right);\n\n          if (!isGridLinear && nextElementX2 > focusedElementX1) {\n            next = undefined;\n          }\n        } else if (!next && isCyclic) {\n          next = focusable.findLast({\n            container,\n            ignoreUncontrolled: true,\n            useActiveModalizer: true\n          });\n        }\n      } else if (keyCode === Keys.Home) {\n        if (isGrid) {\n          focusable.findElement({\n            container,\n            currentElement: focused,\n            ignoreUncontrolled: true,\n            useActiveModalizer: true,\n            isBackward: true,\n            acceptCondition: el => {\n              var _a;\n\n              if (!focusable.isFocusable(el)) {\n                return false;\n              }\n\n              const nextElementX1 = Math.ceil((_a = el.getBoundingClientRect().left) !== null && _a !== void 0 ? _a : 0);\n\n              if (el !== focused && focusedElementX1 <= nextElementX1) {\n                return true;\n              }\n\n              next = el;\n              return false;\n            }\n          });\n        } else {\n          next = focusable.findFirst({\n            container,\n            ignoreUncontrolled: true,\n            useActiveModalizer: true\n          });\n        }\n      } else if (keyCode === Keys.End) {\n        if (isGrid) {\n          focusable.findElement({\n            container,\n            currentElement: focused,\n            ignoreUncontrolled: true,\n            useActiveModalizer: true,\n            acceptCondition: el => {\n              var _a;\n\n              if (!focusable.isFocusable(el)) {\n                return false;\n              }\n\n              const nextElementX1 = Math.ceil((_a = el.getBoundingClientRect().left) !== null && _a !== void 0 ? _a : 0);\n\n              if (el !== focused && focusedElementX1 >= nextElementX1) {\n                return true;\n              }\n\n              next = el;\n              return false;\n            }\n          });\n        } else {\n          next = focusable.findLast({\n            container,\n            ignoreUncontrolled: true,\n            useActiveModalizer: true\n          });\n        }\n      } else if (keyCode === Keys.PageUp) {\n        focusable.findElement({\n          currentElement: focused,\n          container,\n          useActiveModalizer: true,\n          isBackward: true,\n          acceptCondition: el => {\n            if (!focusable.isFocusable(el)) {\n              return false;\n            }\n\n            if (isElementVerticallyVisibleInContainer(this._win, el, mover.visibilityTolerance)) {\n              next = el;\n              return false;\n            }\n\n            return true;\n          }\n        }); // will be on the first column move forward and preserve previous column\n\n        if (isGrid && next) {\n          const firstColumnX1 = Math.ceil(next.getBoundingClientRect().left);\n          focusable.findElement({\n            currentElement: next,\n            container,\n            useActiveModalizer: true,\n            acceptCondition: el => {\n              if (!focusable.isFocusable(el)) {\n                return false;\n              }\n\n              const nextElementX1 = Math.ceil(el.getBoundingClientRect().left);\n\n              if (focusedElementX1 < nextElementX1 || firstColumnX1 >= nextElementX1) {\n                return true;\n              }\n\n              next = el;\n              return false;\n            }\n          });\n        }\n\n        if (next) {\n          scrollIntoView(this._win, next, false);\n        }\n      } else if (keyCode === Keys.PageDown) {\n        focusable.findElement({\n          currentElement: focused,\n          container,\n          useActiveModalizer: true,\n          acceptCondition: el => {\n            if (!focusable.isFocusable(el)) {\n              return false;\n            }\n\n            if (isElementVerticallyVisibleInContainer(this._win, el, mover.visibilityTolerance)) {\n              next = el;\n              return false;\n            }\n\n            return true;\n          }\n        }); // will be on the last column move backwards and preserve previous column\n\n        if (isGrid && next) {\n          const lastColumnX1 = Math.ceil(next.getBoundingClientRect().left);\n          focusable.findElement({\n            currentElement: next,\n            container,\n            useActiveModalizer: true,\n            isBackward: true,\n            acceptCondition: el => {\n              if (!focusable.isFocusable(el)) {\n                return false;\n              }\n\n              const nextElementX1 = Math.ceil(el.getBoundingClientRect().left);\n\n              if (focusedElementX1 > nextElementX1 || lastColumnX1 <= nextElementX1) {\n                return true;\n              }\n\n              next = el;\n              return false;\n            }\n          });\n        }\n\n        if (next) {\n          scrollIntoView(this._win, next, true);\n        }\n      } else if (isGrid) {\n        const isBackward = keyCode === Keys.Up;\n        const ax1 = focusedElementX1; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n        const ay1 = Math.ceil(focusedElementRect.top);\n        const ax2 = focusedElementX2; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n        const ay2 = Math.floor(focusedElementRect.bottom);\n        let targetElement;\n        let lastDistance;\n        let lastIntersection = 0;\n        focusable.findAll({\n          container,\n          currentElement: focused,\n          isBackward,\n          onElement: el => {\n            // Find element which has maximal intersection with the focused element horizontally,\n            // or the closest one.\n            const rect = el.getBoundingClientRect();\n            const bx1 = Math.ceil(rect.left);\n            const by1 = Math.ceil(rect.top);\n            const bx2 = Math.floor(rect.right);\n            const by2 = Math.floor(rect.bottom);\n\n            if (isBackward && ay1 < by2 || !isBackward && ay2 > by1) {\n              // Only consider elements which are below/above curretly focused.\n              return true;\n            }\n\n            const xIntersectionWidth = Math.ceil(Math.min(ax2, bx2)) - Math.floor(Math.max(ax1, bx1));\n            const minWidth = Math.ceil(Math.min(ax2 - ax1, bx2 - bx1));\n\n            if (xIntersectionWidth > 0 && minWidth >= xIntersectionWidth) {\n              // Element intersects with the focused element on X axis.\n              const intersection = xIntersectionWidth / minWidth;\n\n              if (intersection > lastIntersection) {\n                targetElement = el;\n                lastIntersection = intersection;\n              }\n            } else if (lastIntersection === 0) {\n              // If we didn't have intersection, try just the closest one.\n              const distance = getDistance(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2);\n\n              if (lastDistance === undefined || distance < lastDistance) {\n                lastDistance = distance;\n                targetElement = el;\n              }\n            } else if (lastIntersection > 0) {\n              // Element doesn't intersect, but we had intersection already, stop search.\n              return false;\n            }\n\n            return true;\n          }\n        });\n        next = targetElement;\n      }\n\n      if (next) {\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        nativeFocus(next);\n      }\n    };\n\n    this._tabster = tabster;\n    this._win = getWindow;\n    this._movers = {};\n    tabster.queueInit(this._init);\n  }\n\n  dispose() {\n    var _a;\n\n    const win = this._win();\n\n    this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n    (_a = this._ignoredInputResolve) === null || _a === void 0 ? void 0 : _a.call(this, false);\n\n    if (this._ignoredInputTimer) {\n      win.clearTimeout(this._ignoredInputTimer);\n      delete this._ignoredInputTimer;\n    }\n\n    win.removeEventListener(\"keydown\", this._onKeyDown, true);\n    Object.keys(this._movers).forEach(moverId => {\n      if (this._movers[moverId]) {\n        this._movers[moverId].dispose();\n\n        delete this._movers[moverId];\n      }\n    });\n  }\n\n  createMover(element, props, sys) {\n    if (process.env.NODE_ENV === 'development') ;\n\n    const newMover = new Mover(this._tabster, element, this._onMoverDispose, props, sys);\n    this._movers[newMover.id] = newMover;\n    return newMover;\n  }\n\n  async _isIgnoredInput(element, keyCode) {\n    var _a;\n\n    if (element.getAttribute(\"aria-expanded\") === \"true\") {\n      return true;\n    }\n\n    if (matchesSelector(element, _inputSelector)) {\n      let selectionStart = 0;\n      let selectionEnd = 0;\n      let textLength = 0;\n      let asyncRet;\n\n      if (element.tagName === \"INPUT\" || element.tagName === \"TEXTAREA\") {\n        const type = element.type;\n        const value = element.value;\n        textLength = (value || \"\").length;\n\n        if (type === \"email\" || type === \"number\") {\n          // For these types Chromium doesn't provide selectionStart and selectionEnd.\n          // Hence the ugly workaround to find if the caret position is changed with\n          // the keypress.\n          // TODO: Have a look at range, week, time, time, date, datetime-local.\n          if (textLength) {\n            const selection = (_a = element.ownerDocument.defaultView) === null || _a === void 0 ? void 0 : _a.getSelection();\n\n            if (selection) {\n              const initialLength = selection.toString().length;\n              const isBackward = keyCode === Keys.Left || keyCode === Keys.Up;\n              selection.modify(\"extend\", isBackward ? \"backward\" : \"forward\", \"character\");\n\n              if (initialLength !== selection.toString().length) {\n                // The caret is moved, so, we're not on the edge of the value.\n                // Restore original selection.\n                selection.modify(\"extend\", isBackward ? \"forward\" : \"backward\", \"character\");\n                return true;\n              } else {\n                textLength = 0;\n              }\n            }\n          }\n        } else {\n          const selStart = element.selectionStart;\n\n          if (selStart === null) {\n            // Do not ignore not text editable inputs like checkboxes and radios (but ignore hidden).\n            return type === \"hidden\";\n          }\n\n          selectionStart = selStart || 0;\n          selectionEnd = element.selectionEnd || 0;\n        }\n      } else if (element.contentEditable === \"true\") {\n        asyncRet = new (getPromise(this._win))(resolve => {\n          this._ignoredInputResolve = value => {\n            delete this._ignoredInputResolve;\n            resolve(value);\n          };\n\n          const win = this._win();\n\n          if (this._ignoredInputTimer) {\n            win.clearTimeout(this._ignoredInputTimer);\n          }\n\n          const {\n            anchorNode: prevAnchorNode,\n            focusNode: prevFocusNode,\n            anchorOffset: prevAnchorOffset,\n            focusOffset: prevFocusOffset\n          } = win.getSelection() || {}; // Get selection gives incorrect value if we call it syncronously onKeyDown.\n\n          this._ignoredInputTimer = win.setTimeout(() => {\n            var _a, _b, _c;\n\n            delete this._ignoredInputTimer;\n            const {\n              anchorNode,\n              focusNode,\n              anchorOffset,\n              focusOffset\n            } = win.getSelection() || {};\n\n            if (anchorNode !== prevAnchorNode || focusNode !== prevFocusNode || anchorOffset !== prevAnchorOffset || focusOffset !== prevFocusOffset) {\n              (_a = this._ignoredInputResolve) === null || _a === void 0 ? void 0 : _a.call(this, false);\n              return;\n            }\n\n            selectionStart = anchorOffset || 0;\n            selectionEnd = focusOffset || 0;\n            textLength = ((_b = element.textContent) === null || _b === void 0 ? void 0 : _b.length) || 0;\n\n            if (anchorNode && focusNode) {\n              if (element.contains(anchorNode) && element.contains(focusNode)) {\n                if (anchorNode !== element) {\n                  let anchorFound = false;\n\n                  const addOffsets = node => {\n                    if (node === anchorNode) {\n                      anchorFound = true;\n                    } else if (node === focusNode) {\n                      return true;\n                    }\n\n                    const nodeText = node.textContent;\n\n                    if (nodeText && !node.firstChild) {\n                      const len = nodeText.length;\n\n                      if (anchorFound) {\n                        if (focusNode !== anchorNode) {\n                          selectionEnd += len;\n                        }\n                      } else {\n                        selectionStart += len;\n                        selectionEnd += len;\n                      }\n                    }\n\n                    let stop = false;\n\n                    for (let e = node.firstChild; e && !stop; e = e.nextSibling) {\n                      stop = addOffsets(e);\n                    }\n\n                    return stop;\n                  };\n\n                  addOffsets(element);\n                }\n              }\n            }\n\n            (_c = this._ignoredInputResolve) === null || _c === void 0 ? void 0 : _c.call(this, true);\n          }, 0);\n        });\n      }\n\n      if (asyncRet && !(await asyncRet)) {\n        return true;\n      }\n\n      if (selectionStart !== selectionEnd) {\n        return true;\n      }\n\n      if (selectionStart > 0 && (keyCode === Keys.Left || keyCode === Keys.Up || keyCode === Keys.Home)) {\n        return true;\n      }\n\n      if (selectionStart < textLength && (keyCode === Keys.Right || keyCode === Keys.Down || keyCode === Keys.End)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nfunction observeMutations(doc, tabster, updateTabsterByAttribute, syncState) {\n  if (typeof MutationObserver === \"undefined\") {\n    return () => {\n      /* Noop */\n    };\n  }\n\n  const getWindow = tabster.getWindow;\n  let elementByUId;\n\n  const onMutation = mutations => {\n    var _a, _b, _c, _d, _e;\n\n    for (const mutation of mutations) {\n      const target = mutation.target;\n      const removed = mutation.removedNodes;\n      const added = mutation.addedNodes;\n\n      if (mutation.type === \"attributes\") {\n        if (mutation.attributeName === TabsterAttributeName) {\n          updateTabsterByAttribute(tabster, target);\n        }\n      } else {\n        for (let i = 0; i < removed.length; i++) {\n          updateTabsterElements(removed[i], true);\n          (_b = (_a = tabster._dummyObserver).domChanged) === null || _b === void 0 ? void 0 : _b.call(_a, target);\n        }\n\n        for (let i = 0; i < added.length; i++) {\n          updateTabsterElements(added[i]);\n          (_d = (_c = tabster._dummyObserver).domChanged) === null || _d === void 0 ? void 0 : _d.call(_c, target);\n        }\n      }\n    }\n\n    (_e = tabster.modalizer) === null || _e === void 0 ? void 0 : _e.hiddenUpdate();\n  };\n\n  function updateTabsterElements(node, removed) {\n    if (!elementByUId) {\n      elementByUId = getInstanceContext(getWindow).elementByUId;\n    }\n\n    processNode(node, removed);\n    const walker = createElementTreeWalker(doc, node, element => {\n      return processNode(element, removed);\n    });\n\n    if (walker) {\n      while (walker.nextNode()) {\n        /* Iterating for the sake of calling processNode() callback. */\n      }\n    }\n  }\n\n  function processNode(element, removed) {\n    var _a;\n\n    if (!element.getAttribute) {\n      // It might actually be a text node.\n      return NodeFilter.FILTER_SKIP;\n    }\n\n    const uid = element.__tabsterElementUID;\n\n    if (uid && elementByUId) {\n      if (removed) {\n        delete elementByUId[uid];\n      } else {\n        (_a = elementByUId[uid]) !== null && _a !== void 0 ? _a : elementByUId[uid] = new WeakHTMLElement(getWindow, element);\n      }\n    }\n\n    if (getTabsterOnElement(tabster, element) || element.hasAttribute(TabsterAttributeName)) {\n      updateTabsterByAttribute(tabster, element, removed);\n    }\n\n    return NodeFilter.FILTER_SKIP;\n  }\n\n  const observer = new MutationObserver(onMutation);\n\n  if (syncState) {\n    updateTabsterElements(getWindow().document.body);\n  }\n\n  observer.observe(doc, {\n    childList: true,\n    subtree: true,\n    attributes: true,\n    attributeFilter: [TabsterAttributeName]\n  });\n  return () => {\n    observer.disconnect();\n  };\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst _conditionCheckTimeout = 100;\nclass ObservedElementAPI extends Subscribable {\n  constructor(tabster) {\n    super();\n    this._waiting = {};\n    this._lastRequestFocusId = 0;\n    this._observedById = {};\n    this._observedByName = {};\n    this._currentRequestTimestamp = 0;\n\n    this._onFocus = e => {\n      if (e) {\n        const current = this._currentRequest;\n\n        if (current) {\n          const delta = Date.now() - this._currentRequestTimestamp;\n\n          const settleTime = 300;\n\n          if (delta >= settleTime) {\n            // Giving some time for the focus to settle before\n            // automatically cancelling the current request on focus change.\n            delete this._currentRequest;\n            current.cancel();\n          }\n        }\n      }\n    };\n\n    this.onObservedElementUpdate = element => {\n      var _a;\n\n      const observed = (_a = getTabsterOnElement(this._tabster, element)) === null || _a === void 0 ? void 0 : _a.observed;\n      const uid = getElementUId(this._win, element);\n      let info = this._observedById[uid];\n\n      if (observed && documentContains(element.ownerDocument, element)) {\n        if (!info) {\n          info = this._observedById[uid] = {\n            element: new WeakHTMLElement(this._win, element)\n          };\n        }\n\n        observed.names.sort();\n        const observedNames = observed.names;\n        const prevNames = info.prevNames; // prevNames are already sorted\n\n        if (this._isObservedNamesUpdated(observedNames, prevNames)) {\n          if (prevNames) {\n            prevNames.forEach(prevName => {\n              const obn = this._observedByName[prevName];\n\n              if (obn && obn[uid]) {\n                if (Object.keys(obn).length > 1) {\n                  delete obn[uid];\n                } else {\n                  delete this._observedByName[prevName];\n                }\n              }\n            });\n          }\n\n          info.prevNames = observedNames;\n        }\n\n        observedNames.forEach(observedName => {\n          let obn = this._observedByName[observedName];\n\n          if (!obn) {\n            obn = this._observedByName[observedName] = {};\n          } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n\n          obn[uid] = info;\n\n          this._waitConditional(observedName);\n        });\n      } else if (info) {\n        const prevNames = info.prevNames;\n\n        if (prevNames) {\n          prevNames.forEach(prevName => {\n            const obn = this._observedByName[prevName];\n\n            if (obn && obn[uid]) {\n              if (Object.keys(obn).length > 1) {\n                delete obn[uid];\n              } else {\n                delete this._observedByName[prevName];\n              }\n            }\n          });\n        }\n\n        delete this._observedById[uid];\n      }\n    };\n\n    this._tabster = tabster;\n    this._win = tabster.getWindow;\n    tabster.queueInit(() => {\n      this._tabster.focusedElement.subscribe(this._onFocus);\n    });\n  }\n\n  dispose() {\n    this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n    for (const key of Object.keys(this._waiting)) {\n      this._rejectWaiting(key);\n    }\n\n    this._observedById = {};\n    this._observedByName = {};\n  }\n\n  _rejectWaiting(key, shouldResolve) {\n    const w = this._waiting[key];\n\n    if (w) {\n      const win = this._win();\n\n      if (w.timer) {\n        win.clearTimeout(w.timer);\n      }\n\n      if (w.conditionTimer) {\n        win.clearTimeout(w.conditionTimer);\n      }\n\n      if (!shouldResolve && w.reject) {\n        w.reject();\n      } else if (shouldResolve && w.resolve) {\n        w.resolve(null);\n      }\n\n      delete this._waiting[key];\n    }\n  }\n\n  _isObservedNamesUpdated(cur, prev) {\n    if (!prev || cur.length !== prev.length) {\n      return true;\n    }\n\n    for (let i = 0; i < cur.length; ++i) {\n      if (cur[i] !== prev[i]) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\r\n   * Returns existing element by observed name\r\n   *\r\n   * @param observedName An observed name\r\n   * @param accessibility Optionally, return only if the element is accessible or focusable\r\n   * @returns HTMLElement | null\r\n   */\n\n\n  getElement(observedName, accessibility) {\n    const o = this._observedByName[observedName];\n\n    if (o) {\n      for (const uid of Object.keys(o)) {\n        let el = o[uid].element.get() || null;\n\n        if (el) {\n          if (accessibility === ObservedElementAccesibilities.Accessible && !this._tabster.focusable.isAccessible(el) || accessibility === ObservedElementAccesibilities.Focusable && !this._tabster.focusable.isFocusable(el, true)) {\n            el = null;\n          }\n        } else {\n          delete o[uid];\n          delete this._observedById[uid];\n        }\n\n        return el;\n      }\n    }\n\n    return null;\n  }\n  /**\r\n   * Waits for the element to appear in the DOM and returns it.\r\n   *\r\n   * @param observedName An observed name\r\n   * @param timeout Wait no longer than this timeout\r\n   * @param accessibility Optionally, wait for the element to also become accessible or focusable before returning it\r\n   * @returns Promise<HTMLElement | null>\r\n   */\n\n\n  waitElement(observedName, timeout, accessibility) {\n    const el = this.getElement(observedName, accessibility);\n\n    if (el) {\n      return {\n        result: getPromise(this._win).resolve(el),\n        cancel: () => {\n          /**/\n        }\n      };\n    }\n\n    let prefix;\n\n    if (accessibility === ObservedElementAccesibilities.Accessible) {\n      prefix = \"a\";\n    } else if (accessibility === ObservedElementAccesibilities.Focusable) {\n      prefix = \"f\";\n    } else {\n      prefix = \"_\";\n    }\n\n    const key = prefix + observedName;\n    let w = this._waiting[key];\n\n    if (w && w.request) {\n      return w.request;\n    }\n\n    w = this._waiting[key] = {\n      timer: this._win().setTimeout(() => {\n        if (w.conditionTimer) {\n          this._win().clearTimeout(w.conditionTimer);\n        }\n\n        delete this._waiting[key];\n\n        if (w.resolve) {\n          w.resolve(null);\n        }\n      }, timeout)\n    };\n    const promise = new (getPromise(this._win))((resolve, reject) => {\n      w.resolve = resolve;\n      w.reject = reject;\n    });\n    w.request = {\n      result: promise,\n      cancel: () => {\n        this._rejectWaiting(key, true);\n      }\n    };\n\n    if (accessibility && this.getElement(observedName)) {\n      // If the observed element is alread in DOM, but not accessible yet,\n      // we need to run the wait logic.\n      this._waitConditional(observedName);\n    }\n\n    return w.request;\n  }\n\n  requestFocus(observedName, timeout) {\n    const requestId = ++this._lastRequestFocusId;\n    const currentRequestFocus = this._currentRequest;\n\n    if (currentRequestFocus) {\n      currentRequestFocus.cancel();\n    }\n\n    const request = this.waitElement(observedName, timeout, ObservedElementAccesibilities.Focusable);\n    this._currentRequest = request;\n    this._currentRequestTimestamp = Date.now();\n    request.result.finally(() => {\n      if (this._currentRequest === request) {\n        delete this._currentRequest;\n      }\n    });\n    return {\n      result: request.result.then(element => this._lastRequestFocusId === requestId && element ? this._tabster.focusedElement.focus(element, true) : false),\n      cancel: () => {\n        request.cancel();\n      }\n    };\n  }\n\n  _waitConditional(observedName) {\n    const waitingElementKey = \"_\" + observedName;\n    const waitingAccessibleElementKey = \"a\" + observedName;\n    const waitingFocusableElementKey = \"f\" + observedName;\n    const waitingElement = this._waiting[waitingElementKey];\n    const waitingAccessibleElement = this._waiting[waitingAccessibleElementKey];\n    const waitingFocusableElement = this._waiting[waitingFocusableElementKey];\n\n    const win = this._win();\n\n    const resolve = (element, key, waiting, accessibility) => {\n      var _a;\n\n      const observed = (_a = getTabsterOnElement(this._tabster, element)) === null || _a === void 0 ? void 0 : _a.observed;\n\n      if (!observed || !observed.names.includes(observedName)) {\n        return;\n      }\n\n      if (waiting.timer) {\n        win.clearTimeout(waiting.timer);\n      }\n\n      delete this._waiting[key];\n\n      if (waiting.resolve) {\n        waiting.resolve(element);\n      }\n\n      this.trigger(element, {\n        names: [observedName],\n        details: observed.details,\n        accessibility\n      });\n    };\n\n    if (waitingElement) {\n      const element = this.getElement(observedName);\n\n      if (element && documentContains(element.ownerDocument, element)) {\n        resolve(element, waitingElementKey, waitingElement, ObservedElementAccesibilities.Any);\n      }\n    }\n\n    if (waitingAccessibleElement && !waitingAccessibleElement.conditionTimer) {\n      const resolveAccessible = () => {\n        const element = this.getElement(observedName);\n\n        if (element && documentContains(element.ownerDocument, element) && this._tabster.focusable.isAccessible(element)) {\n          resolve(element, waitingAccessibleElementKey, waitingAccessibleElement, ObservedElementAccesibilities.Accessible);\n        } else {\n          waitingAccessibleElement.conditionTimer = win.setTimeout(resolveAccessible, _conditionCheckTimeout);\n        }\n      };\n\n      resolveAccessible();\n    }\n\n    if (waitingFocusableElement && !waitingFocusableElement.conditionTimer) {\n      const resolveFocusable = () => {\n        const element = this.getElement(observedName);\n\n        if (element && documentContains(element.ownerDocument, element) && this._tabster.focusable.isFocusable(element, true)) {\n          resolve(element, waitingFocusableElementKey, waitingFocusableElement, ObservedElementAccesibilities.Focusable);\n        } else {\n          waitingFocusableElement.conditionTimer = win.setTimeout(resolveFocusable, _conditionCheckTimeout);\n        }\n      };\n\n      resolveFocusable();\n    }\n  }\n\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst defaultProps = {\n  areaClass: \"tabster-focus-outline-area\",\n  outlineClass: \"tabster-focus-outline\",\n  outlineColor: \"#ff4500\",\n  outlineWidth: 2,\n  zIndex: 2147483647\n};\nlet _props = defaultProps;\n\nclass OutlinePosition {\n  constructor(left, top, right, bottom) {\n    this.left = left;\n    this.top = top;\n    this.right = right;\n    this.bottom = bottom;\n  }\n\n  equalsTo(other) {\n    return this.left === other.left && this.top === other.top && this.right === other.right && this.bottom === other.bottom;\n  }\n\n  clone() {\n    return new OutlinePosition(this.left, this.top, this.right, this.bottom);\n  }\n\n}\n\nclass OutlineAPI {\n  constructor(tabster) {\n    this._isVisible = false;\n    this._allOutlineElements = [];\n\n    this._init = () => {\n      this._tabster.keyboardNavigation.subscribe(this._onKeyboardNavigationStateChanged);\n\n      this._tabster.focusedElement.subscribe(this._onFocus);\n\n      const win = this._win();\n\n      win.addEventListener(\"scroll\", this._onScroll, true); // Capture!\n\n      if (this._fullScreenEventName) {\n        win.document.addEventListener(this._fullScreenEventName, this._onFullScreenChanged);\n      }\n    };\n\n    this._onFullScreenChanged = e => {\n      if (!this._fullScreenElementName || !e.target) {\n        return;\n      }\n\n      const target = e.target.body || e.target;\n\n      const outlineElements = this._getDOM(target);\n\n      if (target.ownerDocument && outlineElements) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const fsElement = target.ownerDocument[this._fullScreenElementName];\n\n        if (fsElement) {\n          fsElement.appendChild(outlineElements.container);\n          this._fullScreenElement = fsElement;\n        } else {\n          target.ownerDocument.body.appendChild(outlineElements.container);\n          this._fullScreenElement = undefined;\n        }\n      }\n    };\n\n    this._onKeyboardNavigationStateChanged = () => {\n      this._onFocus(this._tabster.focusedElement.getFocusedElement());\n    };\n\n    this._onFocus = e => {\n      if (!this._updateElement(e) && this._isVisible) {\n        this._setVisibility(false);\n      }\n    };\n\n    this._onScroll = e => {\n      if (!this._outlinedElement || !OutlineAPI._isParentChild(e.target, this._outlinedElement)) {\n        return;\n      }\n\n      this._curPos = undefined;\n\n      this._setOutlinePosition();\n    };\n\n    this._tabster = tabster;\n    this._win = tabster.getWindow;\n    tabster.queueInit(this._init);\n\n    if (typeof document !== \"undefined\") {\n      if (\"onfullscreenchange\" in document) {\n        this._fullScreenEventName = \"fullscreenchange\";\n        this._fullScreenElementName = \"fullscreenElement\";\n      } else if (\"onwebkitfullscreenchange\" in document) {\n        this._fullScreenEventName = \"webkitfullscreenchange\";\n        this._fullScreenElementName = \"webkitFullscreenElement\";\n      } else if (\"onmozfullscreenchange\" in document) {\n        this._fullScreenEventName = \"mozfullscreenchange\";\n        this._fullScreenElementName = \"mozFullScreenElement\";\n      } else if (\"onmsfullscreenchange\" in document) {\n        this._fullScreenEventName = \"msfullscreenchange\";\n        this._fullScreenElementName = \"msFullscreenElement\";\n      }\n    }\n  }\n\n  setup(props) {\n    _props = { ..._props,\n      ...props\n    };\n\n    const win = this._win();\n\n    if (!win.__tabsterOutline) {\n      win.__tabsterOutline = {};\n    }\n\n    if (!win.__tabsterOutline.style) {\n      win.__tabsterOutline.style = appendStyles(win.document, _props);\n    }\n\n    if (!props || !props.areaClass) {\n      win.document.body.classList.add(defaultProps.areaClass);\n    } else {\n      win.document.body.classList.remove(defaultProps.areaClass);\n    }\n  }\n\n  dispose() {\n    const win = this._win();\n\n    if (this._updateTimer) {\n      win.clearTimeout(this._updateTimer);\n      this._updateTimer = undefined;\n    }\n\n    this._tabster.keyboardNavigation.unsubscribe(this._onKeyboardNavigationStateChanged);\n\n    this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n    win.removeEventListener(\"scroll\", this._onScroll, true);\n\n    if (this._fullScreenEventName) {\n      win.document.removeEventListener(this._fullScreenEventName, this._onFullScreenChanged);\n    }\n\n    this._allOutlineElements.forEach(outlineElements => this._removeDOM(outlineElements.container));\n\n    this._allOutlineElements = [];\n    delete this._outlinedElement;\n    delete this._curPos;\n    delete this._curOutlineElements;\n    delete this._fullScreenElement;\n  }\n\n  _shouldShowCustomOutline(element) {\n    const tabsterOnElement = getTabsterOnElement(this._tabster, element);\n\n    if (tabsterOnElement && tabsterOnElement.outline && tabsterOnElement.outline.isIgnored) {\n      return false;\n    }\n\n    for (let i = element; i; i = i.parentElement) {\n      if (i.classList && i.classList.contains(_props.areaClass)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _updateElement(e) {\n    this._outlinedElement = undefined;\n\n    if (this._updateTimer) {\n      this._win().clearTimeout(this._updateTimer);\n\n      this._updateTimer = undefined;\n    }\n\n    this._curPos = undefined;\n\n    if (!this._tabster.keyboardNavigation.isNavigatingWithKeyboard()) {\n      return false;\n    }\n\n    if (e) {\n      // TODO: It's hard (and not necessary) to come up with every possible\n      // condition when there should be no outline, it's better to add an\n      // API to customize the ignores.\n      if (e.tagName === \"INPUT\") {\n        const inputType = e.type;\n        const outlinedInputTypes = {\n          button: true,\n          checkbox: true,\n          file: true,\n          image: true,\n          radio: true,\n          range: true,\n          reset: true,\n          submit: true\n        };\n\n        if (!(inputType in outlinedInputTypes)) {\n          return false;\n        }\n      } else if (e.tagName === \"TEXTAREA\" || e.contentEditable === \"true\" || e.tagName === \"IFRAME\") {\n        return false;\n      }\n\n      if (!this._shouldShowCustomOutline(e)) {\n        return false;\n      }\n\n      if (this._tabster.keyboardNavigation.isNavigatingWithKeyboard()) {\n        this._outlinedElement = e;\n\n        this._updateOutline();\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  _updateOutline() {\n    this._setOutlinePosition();\n\n    if (this._updateTimer) {\n      this._win().clearTimeout(this._updateTimer);\n\n      this._updateTimer = undefined;\n    }\n\n    if (!this._outlinedElement) {\n      return;\n    }\n\n    this._updateTimer = this._win().setTimeout(() => {\n      this._updateTimer = undefined;\n\n      this._updateOutline();\n    }, 30);\n  }\n\n  _setVisibility(visible) {\n    this._isVisible = visible;\n\n    if (this._curOutlineElements) {\n      if (visible) {\n        this._curOutlineElements.container.classList.add(`${_props.outlineClass}_visible`);\n      } else {\n        this._curOutlineElements.container.classList.remove(`${_props.outlineClass}_visible`);\n\n        this._curPos = undefined;\n      }\n    }\n  }\n\n  _setOutlinePosition() {\n    if (!this._outlinedElement) {\n      return;\n    }\n\n    let boundingRect = getBoundingRect(this._win, this._outlinedElement);\n    const position = new OutlinePosition(boundingRect.left, boundingRect.top, boundingRect.right, boundingRect.bottom);\n\n    if (this._curPos && position.equalsTo(this._curPos)) {\n      return;\n    }\n\n    const outlineElements = this._getDOM(this._outlinedElement);\n\n    const win = this._outlinedElement.ownerDocument && this._outlinedElement.ownerDocument.defaultView;\n\n    if (!outlineElements || !win) {\n      return;\n    }\n\n    if (this._curOutlineElements !== outlineElements) {\n      this._setVisibility(false);\n\n      this._curOutlineElements = outlineElements;\n    }\n\n    this._curPos = position;\n    const p = position.clone();\n    let hasAbsolutePositionedParent = false;\n    let hasFixedPositionedParent = false;\n    const container = outlineElements.container;\n    const scrollingElement = container && container.ownerDocument && container.ownerDocument.scrollingElement;\n\n    if (!scrollingElement) {\n      return;\n    }\n\n    for (let parent = this._outlinedElement.parentElement; parent && parent.nodeType === Node.ELEMENT_NODE; parent = parent.parentElement) {\n      // The element might be partially visible within its scrollable parent,\n      // reduce the bounding rect if this is the case.\n      if (parent === this._fullScreenElement) {\n        break;\n      }\n\n      boundingRect = getBoundingRect(this._win, parent);\n      const win = parent.ownerDocument && parent.ownerDocument.defaultView;\n\n      if (!win) {\n        return;\n      }\n\n      const computedStyle = win.getComputedStyle(parent);\n      const position = computedStyle.position;\n\n      if (position === \"absolute\") {\n        hasAbsolutePositionedParent = true;\n      } else if (position === \"fixed\" || position === \"sticky\") {\n        hasFixedPositionedParent = true;\n      }\n\n      if (computedStyle.overflow === \"visible\") {\n        continue;\n      }\n\n      if (!hasAbsolutePositionedParent && !hasFixedPositionedParent || computedStyle.overflow === \"hidden\") {\n        if (boundingRect.left > p.left) {\n          p.left = boundingRect.left;\n        }\n\n        if (boundingRect.top > p.top) {\n          p.top = boundingRect.top;\n        }\n\n        if (boundingRect.right < p.right) {\n          p.right = boundingRect.right;\n        }\n\n        if (boundingRect.bottom < p.bottom) {\n          p.bottom = boundingRect.bottom;\n        }\n      }\n    }\n\n    const allRect = getBoundingRect(this._win, scrollingElement);\n    const allWidth = allRect.left + allRect.right;\n    const allHeight = allRect.top + allRect.bottom;\n    const ow = _props.outlineWidth;\n    p.left = p.left > ow ? p.left - ow : 0;\n    p.top = p.top > ow ? p.top - ow : 0;\n    p.right = p.right < allWidth - ow ? p.right + ow : allWidth;\n    p.bottom = p.bottom < allHeight - ow ? p.bottom + ow : allHeight;\n    const width = p.right - p.left;\n    const height = p.bottom - p.top;\n\n    if (width > ow * 2 && height > ow * 2) {\n      const leftBorderNode = outlineElements.left;\n      const topBorderNode = outlineElements.top;\n      const rightBorderNode = outlineElements.right;\n      const bottomBorderNode = outlineElements.bottom;\n      const sx = this._fullScreenElement || hasFixedPositionedParent ? 0 : win.pageXOffset;\n      const sy = this._fullScreenElement || hasFixedPositionedParent ? 0 : win.pageYOffset;\n      container.style.position = hasFixedPositionedParent ? \"fixed\" : \"absolute\";\n      container.style.background = _props.outlineColor;\n      leftBorderNode.style.width = rightBorderNode.style.width = topBorderNode.style.height = bottomBorderNode.style.height = _props.outlineWidth + \"px\";\n      leftBorderNode.style.left = topBorderNode.style.left = bottomBorderNode.style.left = p.left + sx + \"px\";\n      rightBorderNode.style.left = p.left + sx + width - ow + \"px\";\n      leftBorderNode.style.top = rightBorderNode.style.top = topBorderNode.style.top = p.top + sy + \"px\";\n      bottomBorderNode.style.top = p.top + sy + height - ow + \"px\";\n      leftBorderNode.style.height = rightBorderNode.style.height = height + \"px\";\n      topBorderNode.style.width = bottomBorderNode.style.width = width + \"px\";\n\n      this._setVisibility(true);\n    } else {\n      this._setVisibility(false);\n    }\n  }\n\n  _getDOM(contextElement) {\n    const doc = contextElement.ownerDocument;\n    const win = doc && doc.defaultView;\n\n    if (!doc || !win || !win.__tabsterOutline) {\n      return undefined;\n    }\n\n    if (!win.__tabsterOutline.style) {\n      win.__tabsterOutline.style = appendStyles(doc, _props);\n    }\n\n    if (!win.__tabsterOutline.elements) {\n      const outlineElements = {\n        container: doc.createElement(\"div\"),\n        left: doc.createElement(\"div\"),\n        top: doc.createElement(\"div\"),\n        right: doc.createElement(\"div\"),\n        bottom: doc.createElement(\"div\")\n      };\n      outlineElements.container.className = _props.outlineClass;\n      outlineElements.left.className = `${_props.outlineClass}__left`;\n      outlineElements.top.className = `${_props.outlineClass}__top`;\n      outlineElements.right.className = `${_props.outlineClass}__right`;\n      outlineElements.bottom.className = `${_props.outlineClass}__bottom`;\n      outlineElements.container.appendChild(outlineElements.left);\n      outlineElements.container.appendChild(outlineElements.top);\n      outlineElements.container.appendChild(outlineElements.right);\n      outlineElements.container.appendChild(outlineElements.bottom);\n      doc.body.appendChild(outlineElements.container);\n      win.__tabsterOutline.elements = outlineElements; // TODO: Make a garbage collector to remove the references\n      // to the outlines which are nowhere in the DOM anymore.\n\n      this._allOutlineElements.push(outlineElements);\n    }\n\n    return win.__tabsterOutline.elements;\n  }\n\n  _removeDOM(contextElement) {\n    const win = contextElement.ownerDocument && contextElement.ownerDocument.defaultView;\n    const outline = win && win.__tabsterOutline;\n\n    if (!outline) {\n      return;\n    }\n\n    if (outline.style && outline.style.parentNode) {\n      outline.style.parentNode.removeChild(outline.style);\n      delete outline.style;\n    }\n\n    const outlineElements = outline && outline.elements;\n\n    if (outlineElements) {\n      if (outlineElements.container.parentNode) {\n        outlineElements.container.parentNode.removeChild(outlineElements.container);\n      }\n\n      delete outline.elements;\n    }\n  }\n\n  static _isParentChild(parent, child) {\n    return child === parent || // tslint:disable-next-line:no-bitwise\n    !!(parent.compareDocumentPosition(child) & document.DOCUMENT_POSITION_CONTAINED_BY);\n  }\n\n}\n\nfunction appendStyles(document, props) {\n  const style = document.createElement(\"style\");\n  style.type = \"text/css\";\n  style.appendChild(document.createTextNode(getOutlineStyles(props)));\n  document.head.appendChild(style);\n  return style;\n}\n\nfunction getOutlineStyles(props) {\n  return `\n.${props.areaClass} *, .${props.areaClass} *:focus {\noutline: none !important;\n}\n\n.${props.outlineClass} {\ndisplay: none;\nposition: absolute;\nwidth: 0;\nheight: 0;\nleft: 0;\ntop: 0;\nz-index: ${props.zIndex};\n}\n\n.${props.outlineClass}.${props.outlineClass}_visible {\ndisplay: block;\n}\n\n.${props.outlineClass}__left,\n.${props.outlineClass}__top,\n.${props.outlineClass}__right,\n.${props.outlineClass}__bottom {\nposition: absolute;\nbackground: inherit;\n}`;\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * Allows default or user focus behaviour on the DOM subtree\r\n * i.e. Tabster will not control focus events within an uncontrolled area\r\n */\nclass UncontrolledAPI {\n  constructor() {\n    /**/\n  }\n\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nclass Tabster {\n  constructor(tabster) {\n    this.keyboardNavigation = tabster.keyboardNavigation;\n    this.focusedElement = tabster.focusedElement;\n    this.focusable = tabster.focusable;\n    this.root = tabster.root;\n    this.uncontrolled = tabster.uncontrolled;\n    this.core = tabster;\n  }\n\n}\n/**\r\n * Extends Window to include an internal Tabster instance.\r\n */\n\n\nclass TabsterCore {\n  constructor(win, props) {\n    var _a;\n\n    this._forgetMemorizedElements = [];\n    this._wrappers = new Set();\n    this._initQueue = [];\n    this._version = \"4.6.0\";\n    this._noop = false;\n\n    this.getWindow = () => {\n      if (!this._win) {\n        throw new Error(\"Using disposed Tabster.\");\n      }\n\n      return this._win;\n    };\n\n    this._storage = createWeakMap(win);\n    this._win = win;\n    const getWindow = this.getWindow;\n    this.keyboardNavigation = new KeyboardNavigationState(getWindow);\n    this.focusedElement = new FocusedElementState(this, getWindow);\n    this.focusable = new FocusableAPI(this);\n    this.root = new RootAPI(this, props === null || props === void 0 ? void 0 : props.autoRoot);\n    this.uncontrolled = new UncontrolledAPI();\n    this.controlTab = (_a = props === null || props === void 0 ? void 0 : props.controlTab) !== null && _a !== void 0 ? _a : true;\n    this.rootDummyInputs = !!(props === null || props === void 0 ? void 0 : props.rootDummyInputs);\n    this._dummyObserver = new DummyInputObserver(getWindow);\n    this.internal = {\n      stopObserver: () => {\n        if (this._unobserve) {\n          this._unobserve();\n\n          delete this._unobserve;\n        }\n      },\n      resumeObserver: syncState => {\n        if (!this._unobserve) {\n          const doc = getWindow().document;\n          this._unobserve = observeMutations(doc, this, updateTabsterByAttribute, syncState);\n        }\n      }\n    };\n    startFakeWeakRefsCleanup(getWindow); // Gives a tick to the host app to initialize other tabster\n    // APIs before tabster starts observing attributes.\n\n    this.queueInit(() => {\n      this.internal.resumeObserver(true);\n    });\n  }\n\n  createTabster(noRefCount) {\n    const wrapper = new Tabster(this);\n\n    if (!noRefCount) {\n      this._wrappers.add(wrapper);\n    }\n\n    return wrapper;\n  }\n\n  disposeTabster(wrapper, allInstances) {\n    if (allInstances) {\n      this._wrappers.clear();\n    } else {\n      this._wrappers.delete(wrapper);\n    }\n\n    if (this._wrappers.size === 0) {\n      this.dispose();\n    }\n  }\n\n  dispose() {\n    var _a, _b, _c, _d, _e, _f, _g;\n\n    this.internal.stopObserver();\n    const win = this._win;\n    win === null || win === void 0 ? void 0 : win.clearTimeout(this._initTimer);\n    delete this._initTimer;\n    this._initQueue = [];\n    this._forgetMemorizedElements = [];\n\n    if (win && this._forgetMemorizedTimer) {\n      win.clearTimeout(this._forgetMemorizedTimer);\n      delete this._forgetMemorizedTimer;\n    }\n\n    (_a = this.outline) === null || _a === void 0 ? void 0 : _a.dispose();\n    (_b = this.crossOrigin) === null || _b === void 0 ? void 0 : _b.dispose();\n    (_c = this.deloser) === null || _c === void 0 ? void 0 : _c.dispose();\n    (_d = this.groupper) === null || _d === void 0 ? void 0 : _d.dispose();\n    (_e = this.mover) === null || _e === void 0 ? void 0 : _e.dispose();\n    (_f = this.modalizer) === null || _f === void 0 ? void 0 : _f.dispose();\n    (_g = this.observedElement) === null || _g === void 0 ? void 0 : _g.dispose();\n    this.keyboardNavigation.dispose();\n    this.focusable.dispose();\n    this.focusedElement.dispose();\n    this.root.dispose();\n\n    this._dummyObserver.dispose();\n\n    stopFakeWeakRefsCleanupAndClearStorage(this.getWindow);\n    clearElementCache(this.getWindow);\n    this._storage = new WeakMap();\n\n    this._wrappers.clear();\n\n    if (win) {\n      disposeInstanceContext(win);\n      delete win.__tabsterInstance;\n      delete this._win;\n    }\n  }\n\n  storageEntry(element, addremove) {\n    const storage = this._storage;\n    let entry = storage.get(element);\n\n    if (entry) {\n      if (addremove === false && Object.keys(entry).length === 0) {\n        storage.delete(element);\n      }\n    } else if (addremove === true) {\n      entry = {};\n      storage.set(element, entry);\n    }\n\n    return entry;\n  }\n\n  forceCleanup() {\n    if (!this._win) {\n      return;\n    }\n\n    this._forgetMemorizedElements.push(this._win.document.body);\n\n    if (this._forgetMemorizedTimer) {\n      return;\n    }\n\n    this._forgetMemorizedTimer = this._win.setTimeout(() => {\n      delete this._forgetMemorizedTimer;\n\n      for (let el = this._forgetMemorizedElements.shift(); el; el = this._forgetMemorizedElements.shift()) {\n        clearElementCache(this.getWindow, el);\n        FocusedElementState.forgetMemorized(this.focusedElement, el);\n      }\n    }, 0);\n    cleanupFakeWeakRefs(this.getWindow, true);\n  }\n\n  queueInit(callback) {\n    var _a;\n\n    if (!this._win) {\n      return;\n    }\n\n    this._initQueue.push(callback);\n\n    if (!this._initTimer) {\n      this._initTimer = (_a = this._win) === null || _a === void 0 ? void 0 : _a.setTimeout(() => {\n        delete this._initTimer;\n        this.drainInitQueue();\n      }, 0);\n    }\n  }\n\n  drainInitQueue() {\n    if (!this._win) {\n      return;\n    }\n\n    const queue = this._initQueue; // Resetting the queue before calling the callbacks to avoid recursion.\n\n    this._initQueue = [];\n    queue.forEach(callback => callback());\n  }\n\n}\n\nfunction forceCleanup(tabster) {\n  // The only legit case for calling this method is when you've completely removed\n  // the application DOM and not going to add the new one for a while.\n  const tabsterCore = tabster.core;\n  tabsterCore.forceCleanup();\n}\n/**\r\n * Creates an instance of Tabster, returns the current window instance if it already exists.\r\n */\n\nfunction createTabster(win, props) {\n  let tabster = getCurrentTabster(win);\n\n  if (tabster) {\n    return tabster.createTabster();\n  }\n\n  tabster = new TabsterCore(win, props);\n  win.__tabsterInstance = tabster;\n  return tabster.createTabster();\n}\n/**\r\n * Returns an instance of Tabster if it was created before or null.\r\n */\n\nfunction getTabster(win) {\n  const tabster = getCurrentTabster(win);\n  return tabster ? tabster.createTabster(true) : null;\n}\n/**\r\n * Creates a new groupper instance or returns an existing one\r\n * @param tabster Tabster instance\r\n */\n\nfunction getGroupper(tabster) {\n  const tabsterCore = tabster.core;\n\n  if (!tabsterCore.groupper) {\n    tabsterCore.groupper = new GroupperAPI(tabsterCore, tabsterCore.getWindow);\n  }\n\n  return tabsterCore.groupper;\n}\n/**\r\n * Creates a new mover instance or returns an existing one\r\n * @param tabster Tabster instance\r\n */\n\nfunction getMover(tabster) {\n  const tabsterCore = tabster.core;\n\n  if (!tabsterCore.mover) {\n    tabsterCore.mover = new MoverAPI(tabsterCore, tabsterCore.getWindow);\n  }\n\n  return tabsterCore.mover;\n}\nfunction getOutline(tabster) {\n  const tabsterCore = tabster.core;\n\n  if (!tabsterCore.outline) {\n    tabsterCore.outline = new OutlineAPI(tabsterCore);\n  }\n\n  return tabsterCore.outline;\n}\n/**\r\n * Creates a new new deloser instance or returns an existing one\r\n * @param tabster Tabster instance\r\n * @param props Deloser props\r\n */\n\nfunction getDeloser(tabster, props) {\n  const tabsterCore = tabster.core;\n\n  if (!tabsterCore.deloser) {\n    tabsterCore.deloser = new DeloserAPI(tabsterCore, props);\n  }\n\n  return tabsterCore.deloser;\n}\n/**\r\n * Creates a new modalizer instance or returns an existing one\r\n * @param tabster Tabster instance\r\n * @param alwaysAccessibleSelector When Modalizer is active, we put\r\n * aria-hidden to everything else to hide it from screen readers. This CSS\r\n * selector allows to exclude some elements from this behaviour. For example,\r\n * this could be used to exclude aria-live region with the application-wide\r\n * status announcements.\r\n */\n\nfunction getModalizer(tabster, alwaysAccessibleSelector) {\n  const tabsterCore = tabster.core;\n\n  if (!tabsterCore.modalizer) {\n    tabsterCore.modalizer = new ModalizerAPI(tabsterCore, alwaysAccessibleSelector);\n  }\n\n  return tabsterCore.modalizer;\n}\nfunction getObservedElement(tabster) {\n  const tabsterCore = tabster.core;\n\n  if (!tabsterCore.observedElement) {\n    tabsterCore.observedElement = new ObservedElementAPI(tabsterCore);\n  }\n\n  return tabsterCore.observedElement;\n}\nfunction getCrossOrigin(tabster) {\n  const tabsterCore = tabster.core;\n\n  if (!tabsterCore.crossOrigin) {\n    getDeloser(tabster);\n    getModalizer(tabster);\n    getMover(tabster);\n    getGroupper(tabster);\n    getOutline(tabster);\n    getObservedElement(tabster);\n    tabsterCore.crossOrigin = new CrossOriginAPI(tabsterCore);\n  }\n\n  return tabsterCore.crossOrigin;\n}\nfunction getInternal(tabster) {\n  const tabsterCore = tabster.core;\n  return tabsterCore.internal;\n}\nfunction disposeTabster(tabster, allInstances) {\n  tabster.core.disposeTabster(tabster, allInstances);\n}\n/**\r\n * Returns an instance of Tabster if it already exists on the window .\r\n * @param win window instance that could contain an Tabster instance.\r\n */\n\nfunction getCurrentTabster(win) {\n  return win.__tabsterInstance;\n}\n/**\r\n * Allows to make Tabster non operational. Intended for performance debugging (and other\r\n * kinds of debugging), you can switch Tabster off without changing the application code\r\n * that consumes it.\r\n * @param tabster a reference created by createTabster().\r\n * @param noop true if you want to make Tabster noop, false if you want to turn it back.\r\n */\n\nfunction makeNoOp(tabster, noop) {\n  const core = tabster.core;\n\n  if (core._noop !== noop) {\n    core._noop = noop;\n\n    const processNode = element => {\n      if (!element.getAttribute) {\n        return NodeFilter.FILTER_SKIP;\n      }\n\n      if (getTabsterOnElement(core, element) || element.hasAttribute(TabsterAttributeName)) {\n        updateTabsterByAttribute(core, element);\n      }\n\n      return NodeFilter.FILTER_SKIP;\n    };\n\n    const doc = core.getWindow().document;\n    const body = doc.body;\n    processNode(body);\n    const walker = createElementTreeWalker(doc, body, processNode);\n\n    if (walker) {\n      while (walker.nextNode()) {\n        /* Iterating for the sake of calling processNode() callback. */\n      }\n    }\n  }\n}\nfunction isNoOp(tabster) {\n  return tabster._noop;\n}\n\nexport { Types, createTabster, disposeTabster, forceCleanup, getCrossOrigin, getDeloser, getGroupper, getInternal, getModalizer, getMover, getObservedElement, getOutline, getTabster, getTabsterAttribute, isNoOp, makeNoOp, mergeTabsterProps, setTabsterAttribute };\n//# sourceMappingURL=tabster.esm.js.map\n"],"names":["TabsterAttributeName","TabsterDummyInputAttributeName","DeloserEventName","ModalizerActiveEventName","ModalizerInactiveEventName","ModalizerBeforeFocusOutEventName","MoverEventName","FocusInEventName","FocusOutEventName","ObservedElementAccesibilities","Any","Accessible","Focusable","RestoreFocusOrders","History","DeloserDefault","RootDefault","DeloserFirst","RootFirst","Visibilities","Invisible","PartiallyVisible","Visible","MoverDirections","Both","Vertical","Horizontal","Grid","GridLinear","GroupperTabbabilities","Unlimited","Limited","LimitedTrapFocus","SysDummyInputsPositions","Auto","Inside","Outside","Types","Object","freeze","__proto__","ModalizerFocusInEventName","ModalizerFocusOutEventName","getTabsterOnElement","tabster","element","_a","storageEntry","updateTabsterByAttribute","dispose","_b","newAttrValue","_noop","undefined","getAttribute","newAttr","entry","attr","string","newValue","JSON","parse","Error","object","e","tabsterOnElement","oldTabsterProps","newTabsterProps","key","keys","root","onRoot","part","observedElement","onObservedElementUpdate","sys","deloser","setProps","createDeloser","createRoot","modalizer","createModalizer","focusable","groupper","createGroupper","mover","createMover","observed","uncontrolled","outline","console","error","length","_isBrokenIE11","_DOMRect","DOMRect","constructor","x","y","width","height","this","left","top","right","bottom","_uidCounter","document","createTreeWalker","NodeFilter","SHOW_ELEMENT","getInstanceContext","getWindow","win","ctx","__tabsterInstanceContext","elementByUId","basics","Promise","WeakRef","containerBoundingRectCache","lastContainerBoundingRectCacheId","fakeWeakRefs","fakeWeakRefsStarted","FakeWeakRef","target","_target","deref","static","fwr","forceRemove","documentContains","ownerDocument","WeakHTMLElement","data","context","ref","push","_ref","_data","get","getData","cleanupFakeWeakRefs","filter","cleanup","startFakeWeakRefsCleanup","getWeakRef","fakeWeakRefsTimer","setTimeout","createElementTreeWalker","doc","acceptNode","nodeType","Node","ELEMENT_NODE","getBoundingRect","cacheId","__tabsterCacheId","cached","rect","scrollingElement","documentElement","clientWidth","clientHeight","r","getBoundingClientRect","Math","max","min","containerBoundingRectCacheTimer","window","cId","isElementVerticallyVisibleInContainer","tolerance","container","getScrollableContainer","containerRect","elementRect","intersectionTolerance","totalIntersection","scrollIntoView","alignToTop","scrollTop","el","parentElement","scrollWidth","scrollHeight","shouldIgnoreFocus","__shouldIgnoreFocus","getUId","wnd","rnd","Uint32Array","crypto","getRandomValues","msCrypto","i","random","srnd","toString","Date","now","join","getElementUId","uid","__tabsterElementUID","clearElementCache","parent","wel","contains","body","matchesSelector","selector","matches","msMatchesSelector","webkitMatchesSelector","call","getPromise","_lastTabsterPartId","TabsterPart","props","_tabster","_element","_props","id","getElement","getProps","DummyInput","isOutside","_focusIn","input","onFocusIn","relatedTarget","DummyInputManager","getLastPhantomFrom","_isBackward","_focusOut","useDefaultAction","onFocusOut","createElement","tabIndex","setAttribute","style","position","opacity","zIndex","setProperty","makeFocusIgnored","isFirst","_isPhantom","isPhantom","addEventListener","__tabsterDummyContainer","_disposeTimer","_clearDisposeTimeout","clearTimeout","removeEventListener","removeChild","setTopLeft","isIn","current","previous","compareDocumentPosition","DOCUMENT_POSITION_FOLLOWING","DummyInputManagerPriorities","priority","outsideByDefault","callForDefaultAction","_instance","DummyInputManagerCore","moveOut","backwards","moveOutWithDefaultAction","_setHandlers","_onFocusIn","_onFocusOut","getHandler","setTabbable","tabbable","ret","_lastPhantomFrom","moveOutside","isBackward","insertBefore","nextElementSibling","beforeBefore","previousElementSibling","DummyInputObserver","_updateQueue","Set","_lastUpdateQueueTime","_changedParents","WeakSet","_dummies","Map","_domChanged","has","add","_updateDummyInputsTimer","_win","dummy","callback","dummyParent","set","domChanged","remove","dummyInputElements","delete","size","_updateTimer","clear","updatePositions","compute","_scheduledUpdatePositions","scrollTopLeftCache","setTopLeftCallbacks","manager","_wrappers","_isOutside","_transformElements","dummyInput","_onFocus","first","_firstDummy","last","_lastDummy","_ensurePosition","firstInput","lastInput","toFocus","isFocusable","w","wrapper","_getCurrent","_addDummyInputs","_addTimer","_getWindow","_addTransformOffsets","_dummyObserver","_computeTransformOffsets","from","transformElements","newTransformElements","scrollLeft","scrollTopLeft","transform","getComputedStyle","_callForDefaultAction","instance","__tabsterDummy","forcedDummyPosition","dummyInputsPosition","tagName","dummyElement","force","_c","_d","sort","a","b","firstDummyInput","lastDummyInput","elementParent","nextSibling","lastElementChild","appendChild","firstElementChild","getLastChild","lastChild","getAdjacentElement","prev","cur","adjacent","triggerEvent","name","details","event","createEvent","initEvent","dispatchEvent","defaultPrevented","getTabsterAttribute","plain","stringify","setTabsterAttribute","newProps","update","value","mergeTabsterProps","removeAttribute","RootDummyManager","setFocused","super","_onDummyInputFocus","_setFocused","keyboardNavigation","setNavigatingWithKeyboard","focusedElement","getFirstOrLastTabbable","ignoreAccessibility","blur","Root","onDispose","_isFocused","hasFocused","fromAdjacent","_setFocusedTimer","eventTarget","_setTabbableTimer","RootAPI","getTabsterContext","rootDummyInputs","_dummyManager","_onDispose","_sys","controlTab","addDummyInputs","subscribe","_add","_remove","dummyManager","moveWithPhantomDummy","autoRoot","_autoRootWaiting","_roots","_forceDummy","rootById","_autoRootCreate","_autoRootUnwait","_autoRoot","_onRootDispose","global","EventTarget","TypeError","createEventTarget","queueInit","forEach","rootId","newRoot","roots","__tabsterInstance","options","drainInitQueue","checkRtl","isGroupperFirst","modalizerInGroupper","isRtl","isExcludedFromMover","curElement","ignoreKeydown","dir","toLowerCase","excludeFromMover","curModalizer","curGroupper","curMover","isActive","tabbability","userId","activeId","assign","rootAPI","removed","Subscribable","_callbacks","_val","callbacks","indexOf","subscribeFirst","index","splice","unshift","unsubscribe","setVal","val","_callCallbacks","getVal","trigger","_focusableSelector","FocusableAPI","includeProgrammaticallyFocusable","noVisibleCheck","noAccessibleCheck","isVisible","isAccessible","offsetParent","defaultView","visibility","_isHidden","ignoreAriaDisabled","_isDisabled","hasAttribute","attrVal","isAugmented","findFirst","findElement","findLast","findNext","findPrev","findDefault","acceptCondition","isDefault","findAll","_findElements","found","currentElement","useActiveModalizer","ignoreUncontrolled","modalizerId","onUncontrolled","onElement","elements","acceptElementState","modalizerUserId","cachedGrouppers","walker","node","_acceptElement","prepareForNextElement","shouldContinueIfNotFound","foundElement","fromCtx","currentNode","FILTER_ACCEPT","previousNode","nextNode","nextUncontrolled","state","_e","FILTER_SKIP","FILTER_REJECT","lastToIgnore","currentCtx","result","fromMover","acceptElement","groupperElement","fromMoverElement","moverElement","Keys","FocusedElementState","_init","_onKeyDown","activeElement","_setFocusedElement","_onChanged","isFocusedProgrammatically","_validateFocusedElement","_f","keyCode","ctrlKey","contentEditable","shiftKey","next","findNextTabbable","nextElement","moveFrom","preventDefault","stopImmediatePropagation","lastMoverOrGroupper","outOfDOMOrder","DOCUMENT_POSITION_PRECEDING","nextElementCtx","triggerFocusEvent","_lastVal","d","lastCtx","_lastResetElement","_nextVal","getFocusedElement","getLastFocusedElement","focus","noFocusedProgrammaticallyFlag","focusDefault","tabsterFocusable","_focusFirstOrLast","focusFirst","focusLast","resetFocus","prevTabIndex","prevAriaHidden","_setOrRemoveAttribute","lastResetElement","nextVal","actualContainer","isTabbingTimer","_isTabbingTimer","isTabbing","callFindNext","what","lastMoverOrGroupperElement","parentCtx","parentMoverOrGroupper","newCurrent","adjacentElement","adjacentCtx","adjacentFrom","KeyboardNavigationState","_onChange","isNavigatingWithKeyboard","_keyborg","_inputSelector","MoverDummyManager","getMemorized","_onFocusDummyInput","memorized","_getMemorized","Mover","_visible","_onIntersection","entries","newVisibility","fullyVisible","_fullyVisible","intersectionRatio","getState","visibilityTolerance","trackState","visibilityAware","_intersectionObserver","IntersectionObserver","threshold","_observeState","memorizeCurrent","_current","disconnect","_allElements","_unobserve","_setCurrentTimer","setCurrent","changed","_prevCurrent","weak","getCurrent","currentIsDummy","hasDefault","MutationObserver","allElements","WeakMap","updateQueue","observer","mutations","mutation","removedNodes","added","addedNodes","type","attributeName","requestUpdate","setElement","unobserve","observe","updateElement","addNewElements","getMoverGroupper","groupperFirstFocusable","getFirst","removeWalk","toe","childList","subtree","attributes","attributeFilter","isCurrent","MoverAPI","_onMoverDispose","_movers","async","_ignoredInputTimer","_ignoredInputResolve","altKey","metaKey","focused","_isIgnoredInput","moverProps","direction","isBoth","isVertical","isHorizontal","isGridLinear","isGrid","isCyclic","cyclic","focusedElementRect","focusedElementX1","focusedElementX2","ceil","floor","nextElementX1","nextElementX2","firstColumnX1","lastColumnX1","ax1","ay1","ax2","ay2","targetElement","lastDistance","lastIntersection","bx1","by1","bx2","by2","xIntersectionWidth","minWidth","intersection","distance","xDistance","yDistance","sqrt","getDistance","moverId","newMover","asyncRet","selectionStart","selectionEnd","textLength","selection","getSelection","initialLength","modify","selStart","resolve","anchorNode","prevAnchorNode","focusNode","prevFocusNode","anchorOffset","prevAnchorOffset","focusOffset","prevFocusOffset","textContent","anchorFound","addOffsets","nodeText","firstChild","len","stop","UncontrolledAPI","Tabster","core","TabsterCore","_forgetMemorizedElements","_initQueue","_version","_storage","createWeakMap","internal","stopObserver","resumeObserver","syncState","updateTabsterElements","processNode","hiddenUpdate","observeMutations","createTabster","noRefCount","disposeTabster","allInstances","_g","_initTimer","_forgetMemorizedTimer","crossOrigin","stopFakeWeakRefsCleanupAndClearStorage","disposeInstanceContext","addremove","storage","forceCleanup","shift","forgetMemorized","queue","getCurrentTabster","getMover","tabsterCore"],"sourceRoot":""}